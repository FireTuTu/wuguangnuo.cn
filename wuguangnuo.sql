--
-- Database: `wuguangnuo`
--

-- --------------------------------------------------------

--
-- 表的结构 `wu_blog`
--

CREATE TABLE `wu_blog` (
  `id` bigint(20) UNSIGNED NOT NULL,
  `post_title` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '文章标题',
  `post_author` varchar(64) NOT NULL DEFAULT '佚名' COMMENT '文章作者',
  `post_type` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci COMMENT '文章分类',
  `post_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '文章内容',
  `post_date` datetime NOT NULL DEFAULT '0000-00-00 00:00:00' COMMENT '发布日期',
  `post_from` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '文章来源',
  `post_link` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT '' COMMENT '原链接'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='諾的博客';

--
-- 转存表中的数据 `wu_blog`
--

INSERT INTO `wu_blog` (`id`, `post_title`, `post_author`, `post_type`, `post_content`, `post_date`, `post_from`, `post_link`) VALUES
(1, 'Cookie和Session', 'onezero', 'baike', 'Cookie\r\nCookie存在于客户端，Cookie的内容有用于标识的名字、表示的值、可选项（过期时间、路径、安全设置）。每个网站的Cookie只是Web服务器存储在客户端电脑硬盘上的一个很小的文件，因此触发过期的条件是基于客户端电脑的时间设置。在PHP中可以利用setcookie指令自行设置Cookie，超全局变量$_COOKIE可以读取cookie数据。\r\n\r\n在建立cookie时最好设置过期时间，或者将其设置为0，它会在浏览器关闭时过期。也可以设置成一个过去的时间，这样它会被完全删除，因为cookie可能会被黑客利用，不过现在浏览器的安全系数提高，黑客实现XSS等攻击有难度。\r\n\r\nSession\r\n\r\nSession存在于服务器端，本质上跟Cookie类似。每个Session都是存储在服务器设定目录中的唯一文件，目录的位置由php.ini中的session.save_path控制。如果要开始一个Session，则需要使用session_start函数。如果是一段时间内第一次调用这个函数，它会在服务器上存储一个空的关联数组，否则会重新打开已有的Session文件并使数据可以访问。\r\n\r\nPHP中同样也有一个超全局变量$_SESSION用于获取Session的值，Session多数情况下需要存储一个Cookie来支持。现在的浏览器存在多标签的功能，如果在不同的标签中打开同一个网站，PHP会认为是一个访问者，Session的内容就会被共享，可能会导致意想不到的后果。', '0000-00-00 00:00:00', '个人博客', 'https://www.onezero.cc/contents/144.html'),
(2, 'PHP面试题(一)', 'onezero', 'PHP', '1、用PHP打印出前一天的时间格式是2017-9-5 15:30:21\r\n\r\necho date(‘Y-m-d H:i:s’, strtotime(‘-1 day’));\r\n\r\n2、echo(),print(),print_r()的区别\r\n\r\necho是PHP语句, print和print_r是函数,语句没有返回值,函数可以有返回值(即便没有用)\r\n\r\nprint只能打印出简单类型变量的值(如int,string)\r\n\r\nprint_r可以打印出复杂类型变量的值(如数组,对象)\r\n\r\necho — 输出一个或者多个字符串\r\n\r\n3、能够使HTML和PHP分离开使用的模板\r\n\r\nsmarty，Heyes Template Class等\r\n\r\n5、使用哪些工具进行版本控制？\r\n\r\nVS Server on Apache作服务端,WinCVS作客户端;Subversion on Apache/DAV 做服务端,TortoiseSVN做客户端,或者Subclipse做客户端.\r\n\r\n6、如何实现字符串翻转？\r\n\r\nstrrev()\r\n\r\n—————————————————————\r\n\r\n7、优化MYSQL数据库的方法。\r\n\r\n(1).选取最适用的字段属性,应该尽量把字段设置为NOT NULL，这样在将来执行查询的时候，数据库不用去比较NULL值。\r\n\r\n(2).使用连接（JOIN）来代替子查询(Sub-Queries)\r\n\r\n(3).使用联合(UNION)来代替手动创建的临时表\r\n\r\n(4).尽量少使用 LIKE 关键字和通配符\r\n\r\n(5).使用事务和外键\r\n\r\n8、PHP的意思\r\n\r\nHypertext Preprocessor\r\n\r\n9、MYSQL取得当前时间的函数是?，格式化日期的函数是\r\n\r\nnow(), DATE_FORMAT(date,format)\r\n\r\n10、实现中文字串截取无乱码的方法。\r\n\r\nmb_substr()\r\n\r\n—————————————————————\r\n\r\n11、您是否用过版本控制软件? 如果有您用的版本控制软件的名字是?\r\n\r\nTortoiseSVN-1.2.6 svn-1.2.3\r\n\r\n12、您是否用过模板引擎? 如果有您用的模板引擎的名字是?\r\n\r\nsmarty\r\n\r\n13、请简单阐述您最得意的开发之作\r\n\r\n14、对于大流量的网站,您采用什么样的方法来解决访问量问题?\r\n\r\n首先，确认服务器硬件是否足够支持当前的流量\r\n\r\n其次，优化数据库访问。\r\n\r\n第三，禁止外部的盗链。\r\n\r\n第四，控制大文件的下载。\r\n\r\n第五，使用不同主机分流主要流量\r\n\r\n第六，使用流量分析统计软件。\r\n\r\n—————————————————————–\r\n<pre><code>\r\n15、用PHP写出显示客户端IP与服务器IP的代码\r\n\r\nfunction get_client_ip() {#\r\n\r\nif(getenv(\'HTTP_CLIENT_IP\')) {\r\n\r\n$client_ip = getenv(\'HTTP_CLIENT_IP\');\r\n\r\n} elseif(getenv(\'HTTP_X_FORWARDED_FOR\')) {\r\n\r\n$client_ip = getenv(\'HTTP_X_FORWARDED_FOR\');\r\n\r\n} elseif(getenv(\'REMOTE_ADDR\')) {\r\n\r\n$client_ip = getenv(\'REMOTE_ADDR\');\r\n\r\n} else {\r\n\r\n$client_ip = $HTTP_SERVER_VAR[\'REMOTE_ADDR\'];\r\n\r\n}\r\n\r\nreturn $client_ip;\r\n\r\n}\r\n \r\n</code></pre>\r\n16、语句include和require的区别是什么?为避免多次包含同一文件，可用(?)语句代替它们?\r\n\r\nrequire()和include()除了怎样处理失败之外在各\r\n\r\n方面都完全一样。include()产生一个警告而require()则导致一个致命错误。\r\n\r\n换句话说，如果你想在丢失文件时停止处理页面,用require()。include() 就不是这样，脚本会继续运行。\r\n\r\nrequire()无论如何都会包含文件,而include()可以有选择地包含.\r\n\r\n代替用\r\n\r\ninclude_once\r\n\r\nrequire_once\r\n\r\n17、如何修改SESSION的生存时间.\r\n<pre><code>\r\n$savePath = \"./session_save_dir/\";\r\n\r\n$lifeTime = 24 * 3600;\r\n\r\nsession_save_path($savePath);\r\n\r\nsession_set_cookie_params($lifeTime);\r\n\r\nsession_start();</code></pre>\r\n18、有一个网页地址, 比如PHP开发资源网主页: ,如何得到它的内容?\r\n\r\n<code>file_get_contents($url);</code>\r\n19、在HTTP 1.0中，状态码401的含义是(?)；如果返回“找不到文件”的提示，则可用 header 函数，其语句为(?);\r\n\r\n未授权（Unauthorized)\r\n\r\n<code>header(\"http/1.0 403 Forbidden\");</code>', '0000-00-00 00:00:00', '个人博客', 'https://www.onezero.cc/contents/283.html'),
(3, 'PHP面试题（二）', 'onezero', 'PHP', '1、在PHP中，heredoc是一种特殊的字符串，它的结束标志必须?\r\n\r\n跟起始的一样，且结束标志前也要一个换行，后面加上分号\r\n\r\n2、谈谈asp,php,jsp的优缺点\r\n\r\n3、谈谈对mvc的认识\r\n\r\n——————————————————————-\r\n\r\n4、写出发贴数最多的十个人名字的SQL，利用下表：members(id,username,posts,pass,email)\r\n\r\nselect members.username\r\n\r\nfrom members\r\n\r\norder by posts DESC\r\n\r\nlimit 10\r\n\r\n16. 请说明php中传值与传引用的区别。什么时候传值什么时候传引用？(2分)\r\n\r\n按值传递：函数范围内对值的任何改变在函数外部都会被忽略\r\n\r\n按引用传递：函数范围内对值的任何改变在函数外部也能反映出这些修改\r\n\r\n优缺点：按值传递时，php必须复制值。特别是对于大型的字符串和对象来说，这将会是一个代价很大的操作。\r\n\r\n按引用传递则不需要复制值，对于性能提高很有好处。\r\n\r\n17. 在PHP中error_reporting这个函数有什么作用？\r\n\r\n用来配置错误信息回报的等级\r\n\r\n18. 请写一个函数验证电子邮件的格式是否正确 (2分)\r\n\r\n//if the email address is valid, return true,else return false\r\n\r\nfunction validateEmail($email)\r\n\r\n{\r\n\r\nif(eregi(‘^[_a-z0-9-]+(.[_a-z0-9-]+)*@[a-z0-9-]+(.[a-z0-9-]+)*$’,$email) ){\r\n\r\nreturn true;\r\n\r\n}else{\r\n\r\nreturn false;\r\n\r\n}\r\n\r\n}\r\n\r\n19. 简述如何得到当前执行脚本路径，包括所得到参数。(2分)\r\n\r\necho $_SERVER[‘scrīpt_FILENAME’].”?”.$_SERVER[‘QUERY_STRING’];\r\n\r\n20.如何修改SESSION的生存时间. (1分)\r\n\r\nsetcookie()\r\n\r\n或\r\n\r\nsession_set_cookie_params($lifeTime)\r\n\r\n——————————————————————–\r\n\r\n21、JS表单弹出对话框函数是?获得输入焦点函数是? (2分)\r\n\r\nalert(),prompt(),confirm()\r\n\r\nfocus()\r\n\r\n22、JS的转向函数是?怎么引入一个外部JS文件?(2分)\r\n\r\nwindow.location.href\r\n\r\n&lt;scrīpt src=””/&gt;\r\n\r\n23、foo()和@foo()之间有什么区别？(1分)\r\n\r\n24、如何声明一个名为”myclass”的没有方法和属性的类？ (1分)\r\n\r\nclass myclass{};\r\n\r\n25、如何实\r\n\r\n例化一个名为”myclass”的对象？(1分)\r\n\r\n$newmyclass = new myclass();\r\n\r\n26、你如何访问和设置一个类的属性？ (2分)\r\n\r\n通过-〉\r\n\r\n$newmyclass = new myclass();\r\n\r\n$temp=$newmyclass-&gt;testvalue;\r\n\r\n$newmyclass-&gt;testvalue=”a”;\r\n\r\n27、mysql_fetch_row() 和mysql_fetch_array之间有什么区别？ (1分)\r\n\r\nmysql_fetch_row — 从结果集中取得一行作为枚举数组\r\n\r\nmysql_fetch_array — 从结果集中取得一行作为关联数组，或数字数组，或二者兼有\r\n\r\n——————————————————————–\r\n\r\n28、GD库是做什么用的？ (1分)\r\n\r\nGD库提供了一系列用来处理图片的API，使用GD库可以处理图片，或者生成图片。\r\n\r\n在网站上GD库通常用来生成缩略图或者用来对图片加水印或者对网站数据生成报表。\r\n\r\n29、指出一些在PHP输入一段HTML代码的办法。(1分)\r\n\r\nprint(“&lt;table&gt;&lt;/table&gt;”);\r\n\r\n30、下面哪个函数可以打开一个文件，以对文件进行读和写操作？(1分)(c)\r\n\r\n(a) fget() (b) file_open() (c) fopen() (d) open_file()\r\n\r\n31、下面哪个选项没有将 john 添加到users 数组中？ (1分) (c)(d)\r\n\r\n(a) $users[] = ‘john’;\r\n\r\n(b) array_add($users,’john’);\r\n\r\n(c) array_push($users,‘john’);\r\n\r\n(d) $users ||= ‘john’;\r\n\r\n32、下面的程序会输入是否?(1分)\r\n\r\n&lt;?php\r\n\r\n$num = 10;\r\n\r\nfunction multiply(){\r\n\r\n$num = $num * 10;\r\n\r\n}\r\n\r\nmultiply();\r\n\r\necho $num;\r\n\r\n?&gt;\r\n\r\n否，局部变量\r\n\r\n33、使用php写一段简单查询，查出所有姓名为“张三”的内容并打印出来 (2分)\r\n\r\n表名User\r\n\r\nName Tel Content Date\r\n\r\n张三 13333663366 大专毕业 2006-10-11\r\n\r\n张三 13612312331 本科毕业 2006-10-15\r\n\r\n张四 021-55665566 中专毕业 2006-10-15\r\n\r\n请根据上面的题目完成代码：\r\n\r\n$mysql_db=mysql_connect(“local”,”root”,”pass”);\r\n\r\n@mysql_select_db(“DB”,$mysql_db);\r\n\r\n$result=mysql_query(“select * from User where Name=’张三&#x27;”);\r\n\r\nwhile($row=mysql_fetch_array($result))\r\n\r\n{\r\n\r\necho $row[‘Name’].$row[‘Tel’].$row[‘Content’].$row[‘Date’];\r\n\r\necho “&lt;br&gt;”;\r\n\r\n}\r\n\r\n34、如何使用下面的类,并解释下面什么意思?(3)\r\n\r\nclass test{\r\n\r\nfunction Get_test($num){\r\n\r\n$num=md5(md5($num).”En”);\r\n\r\nreturn $num;\r\n\r\n}\r\n\r\n}\r\n\r\n双重md5加密\r\n\r\n$testObject = new test();\r\n\r\n$encryption = $testObject-&gt;Get_test(“xiaotian_ls”);\r\n\r\n—————————————————————————-\r\n\r\n35、写出 SQL语句的格式 : 插入 ，更新 ，删除 (4分)\r\n\r\n表名User\r\n\r\nName Tel Content Date\r\n\r\n张三 13333663366 大专毕业 2006-10-11\r\n\r\n张三 13612312331 本科毕业 2006-10-15\r\n\r\n张四 021-55665566 中专毕业 2006-10-15\r\n\r\n(a) 有一新记录(小王 13254748547 高中毕业 2007-05-06)请用SQL语句新增至表中\r\n\r\nINSERT INTO User(‘Name’,’Tel’,’Content’,’Date’) VALUES(‘小王’,’13254748547′,’高中毕业’,’2007-05-06′)\r\n\r\n(b) 请用sql语句把张三的时间更新成为当前系统时间\r\n\r\nUPDATE User SET Date=DATE_FORMAT(NOW(),’%Y-%m-%d’) WHERE Name=’张三’\r\n\r\n(c) 请写出删除名为张四的全部记录\r\n\r\nDELETE FROM User WHERE Name=’张四’\r\n\r\n36、请写出数据类型(int char varchar datetime text)的意思; 请问varchar和char有什么区别(2分)\r\n\r\nint 数值类型 char 固定长度字符串 varchar 可变长字符串 datetime 日期时间型 text 字符字符串\r\n\r\nchar列的长度固定为创建表时声明的长度.varchar列中的值为可变长字符串.\r\n\r\n37、MySQ自增类型(通常为表ID字段)必需将其设为(?)字段(1分)\r\n\r\nAUTO_INCREMENT\r\n\r\n38、写出以下程序的输出结果 (1分)\r\n\r\n&lt;?\r\n\r\n$b=201;\r\n\r\n$c=40;\r\n\r\n$a=$b&gt;$c?4:5;\r\n\r\necho $a;\r\n\r\n?&gt;\r\n\r\n4\r\n\r\n39、检测一个变量是否有设置的函数是否?是否为空的函数是?(2分)\r\n\r\nisset() empty()\r\n\r\n—————————————————————————–\r\n\r\n40、取得查询结果集总数的函数是?(1分)\r\n\r\ncount()\r\n\r\n41、$arr = array(‘james’, ‘tom’, ‘symfony’); 请打印出第一个元素的值 (1分)\r\n\r\necho $arr[0];\r\n\r\n42、请将41题的数组的值用’,’号分隔并合并成字串输出(1分)\r\n\r\necho $arr[0].$arr[1].$arr[2]\r\n\r\n43、$a = ‘abcdef’; 请取出$a的值并打印出第一个字母(1分)\r\n\r\necho $a{0};\r\n\r\n44、PHP可以和sql server/oracle等数据库连接吗?(1分)\r\n\r\n可以\r\n\r\n45、请写出PHP5权限控制修饰符(3分)\r\n\r\nprivate protected public\r\n\r\n46、请写出php5的构造函数和析构函数(2分)\r\n\r\n__construct __destruct\r\n\r\n——————————————————————————\r\n\r\n47、以下请用PHPMYADMIN完成\r\n\r\n(一)创建新闻发布系统，表名为message有如下字段 (3分)\r\n\r\nid 文章id\r\n\r\ntitle 文章标题\r\n\r\ncontent 文章内容\r\n\r\ncategory_id 文章分类id\r\n\r\nhits 点击量\r\n\r\nCREATE TABLE ‘message&#x27;(\r\n\r\n‘id’ int(11) NOT NULL auto_increment,\r\n\r\n‘title’ varchar(200) default NULL,\r\n\r\n‘content’ blob,\r\n\r\n‘category_id’ int(11) default NULL,\r\n\r\n‘hits’ int(11) default NULL,\r\n\r\nPRIMARY KEY(‘id’)\r\n\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\r\n\r\n(二)同样上述新闻发布系统：表comment记录用户回复内容，字段如下 (4分)\r\n\r\ncomment_id 回复id\r\n\r\nid 文章id，关联message表中的id\r\n\r\ncomment_content 回复内容\r\n\r\n现通过查询数据库需要得到以下格式的文章标题列表,并按照回复数量排序，回复最高的排在最前面\r\n\r\n文章id 文章标题 点击量 回复数量\r\n\r\n用一个SQL语句完成上述查询，如果文章没有回复则回复数量显示为0\r\n\r\nSELECT message.id id,message.title title,IF(message.&#x60;hits&#x60; IS NULL,0,message.&#x60;hits&#x60;) hits,IF(comment.&#x60;id&#x60; is NULL,0,count(*)) number\r\n\r\nFROM message LEFT JOIN comment ON message.id=comment.id\r\n\r\nGROUP BY message.&#x60;id&#x60;\r\n\r\n(三)上述内容管理系统，表category保存分类信息，字段如下 (3分)\r\n\r\ncategory_id int(4) not null auto_increment;\r\n\r\ncategroy_name varchar(40) not null;\r\n\r\n用户输入文章时，通过选择下拉菜单选定文章分类\r\n\r\n写出如何实现这个下拉菜单\r\n<pre><code>\r\nfunction categoryList()\r\n\r\n{\r\n\r\n$result=mysql_query(&quot;select category_id,categroy_name from category&quot;)\r\n\r\nor die(&quot;Invalid query: &quot; . mysql_error());\r\n\r\nprint(&quot;&lt;select name=&#x27;category&#x27; value=&#x27;&#x27;&gt;\\n&quot;);\r\n\r\nwhile($rowArray=mysql_fetch_array($resul\r\n\r\nt))\r\n\r\n{\r\n\r\nprint(&quot;&lt;option value=&#x27;&quot;.$rowArray[&#x27;category_id&#x27;].&quot;&#x27;&gt;&quot;.$rowArray[&#x27;categroy_name&#x27;].&quot;&lt;/option&gt;\\n&quot;);\r\n\r\n}\r\n\r\nprint(&quot;&lt;/select&gt;&quot;);\r\n\r\n}</code></pre>', '0000-00-00 00:00:00', '个人博客', 'https://www.onezero.cc/contents/295.html'),
(4, '没有银弹－软件工程中的根本和次要问题', 'Frederick Brooks', 'baike', '关于这个问题，这个人已经回答的很好了：\n<img src=\"https://pic3.zhimg.com/v2-802d17b02a415ede10494ee00edaeb52_b.png\">\n他在1986年的一次茶话会上发了一篇受邀论文（论文的开头就是“谢邀”），题目就是《没有银弹－软件工程中的根本和次要问题》。这个人就是IBM大型机之父，Frederick Brooks.整个论文不太长，有兴趣的同学可以找来读读。在他的经典书《人月神话》中也有收录。在30多年后的今天，我们在知乎上讨论这个问题，他却早就回答了。他的答案，至今看来，都没有一丝一毫需要修改的地方，毫无瑕疵。\n\n布鲁克斯把软件开发中的困难分为两类：\nessence，可以译为本质困难或者主要问题，指的是软件开发中不可规避的问题，就是软件本身在概念建构上存先天的困难，也就是如何从问题领域，发展出具体的解决方案。\nAccident，可以译为次要因素或次要问题，指的是把解决方案实施到电脑上，所遇到的困难。\n他认为软件开发中无法规避的四个特性是：复杂度；一致性；可变性；不可见性。\n\n他还归纳了在次要问题上我们取得的进步：高级语言；分时系统；统一开发环境。次要问题我们就不展开了，相信大家都可以理解。\n下面所有就都是摘录了，分别描述了4个主要问题。\n\n复杂度。\n规模上，软件实体可能比任何由人类创造的其他实体要复杂，因为没有任何两个软件部分是相同的（至少是在语句的级别）。如果有相同的情况，我们会把它们合并成供调用的子函数。在这个方面，软件系统与计算机、建筑或者汽车大不相同，后者往往存在着大量重复的部分。\n数字计算机本身就比人类建造的大多数东西复杂。计算机拥有大量的状态，这使得构思、描述和测试都非常困难。软件系统的状态又比计算机系统状态多若干个数量级。\n同样，软件实体的扩展也不仅仅是相同元素重复添加，而必须是不同元素实体的添加。大多数情况下，这些元素以非线性递增的方式交互，因此整个软件的复杂度以更大的非线性级数增长。\n软件的复杂度是必要属性，不是次要因素。因此，抽掉复杂度的软件实体描述常常也去掉了一些本质属性。数学和物理学在过去三个世纪取得了巨大的进步，数学家和物理学家们建立模型以简化复杂的现象，从模型中抽取出各种特性，并通过试验来验证这些特性。这些方法之所以可行——是因为模型中忽略的复杂度不是被研究现象的必要属性。当复杂度是本质特性时，这些方法就行不通了。\n上述软件特有的复杂度问题造成了很多经典的软件产品开发问题。由于复杂度，团队成员之间的沟通非常困难，导致了产品瑕疵、成本超支和进度延迟；由于复杂度，列举和理解所有可能的状态十分困难，影响了产品的可靠性；由于函数的复杂度，函数调用变得困难，导致程序难以使用；由于结构性复杂度，程序难以在不产生副作用的情况下用新函数扩充；由于结构性复杂度，造成很多安全机制状态上的不可见性。\n复杂度不仅仅导致技术上的困难，还引发了很多管理上的问题。它使全面理解问题变得困难，从而妨碍了概念上的完整性；它使所有离散出口难以寻找和控制；它引起了大量学习和理解上的负担，使开发慢慢演变成了一场灾难。\n\n一致性。\n并不是只有软件工程师才面对复杂问题。物理学家甚至在非常“基础”的级别上，面对异常复杂的事物。不过，物理学家坚信必定存在着某种通用原理，或者在夸克中，或者在统一场论中。爱因斯坦曾不断地重申自然界一定存在着简化的解释，因为上帝不是专横武断或反复无常的。\n软件工程师却无法从类似的信念中获得安慰，他必须控制的很多复杂度是随心所欲、毫无规则可言的，来自若干必须遵循的人为惯例和系统。它们随接口的不同而改变，随时间的推移而变化，而且，这些变化不是必需的，仅仅由于它们是不同的人——而非上帝——设计的结果。\n某些情况下，因为是开发最新的软件，所以它必须遵循各种接口。另一些情况下，软件的开发目标就是兼容性。在上述的所有情况中，很多复杂性来自保持与其他接口的一致，对软件的任何再设计，都无法简化这些复杂特性。\n\n可变性。\n软件实体经常会遭受到持续的变更压力。当然，建筑、汽车、计算机也是如此。不过，工业制造的产品在出厂之后不会经常地发生修改，它们会被后续模型所取代，或者必要更改会被整合到具有相同基本设计的后续产品系列。汽车的更改十分罕见，计算机的现场调整时有发生。然而，它们和软件的现场修改比起来，都要少很多。\n其中部分的原因是因为系统中的软件包含了很多功能，而功能是最容易感受变更压力的部分。另外的原因是因为软件可以很容易地进行修改——它是纯粹思维活动的产物，可以无限扩展。日常生活中，建筑有可能发生变化，但众所周知，建筑修改的成本很高，从而打消了那些想提出修改的人的念头。\n所有成功的软件都会发生变更。现实工作中，经常发生两种情况。当人们发现软件很有用时，会在原有应用范围的边界，或者在超越边界的情况下使用软件。功能扩展的压力主要来自那些喜欢基本功能，又对软件提出了很多新用法的用户们。\n其次，软件一定是在某种计算机硬件平台上开发，成功软件的生命期通常比当初的计算机硬件平台要长。即使不是更换计算机，则有可能是换新型号的磁盘、显示器或者打印机。软件必须与各种新生事物保持一致。\n简言之，软件产品扎根于文化的母体中，如各种应用、用户、自然及社会规律、计算机硬件等等。后者持续不断地变化着，这些变化无情地强迫着软件随之变化。\n\n不可见性。\n软件是不可见的和无法可视化的。例如，几何抽象是强大的工具。建筑平面图能帮助建筑师和客户一起评估空间布局、进出的运输流量和各个角度的视觉效果。这样，矛盾变得突出，忽略的地方变得明显。同样，机械制图、化学分子模型尽管是抽象模型，但都起了相同的作用。总之，都可以通过几何抽象来捕获物理存在的几何特性。\n软件的客观存在不具有空间的形体特征。因此，没有已有的表达方式，就像陆地海洋有地图、硅片有膜片图、计算机有电路图一样。当我们试图用图形来描述软件结构时，我们发现它不仅仅包含一个，而是很多相互关联、重叠在一起的图形。这些图形可能描绘控制流程、数据流、依赖关系、时间序列、名字空间的相互关系等等。它们通常不是有较少层次的扁平结构。实际上，在上述结构上建立概念控制的一种方法是强制将关联分割，直到可以层次化一个或多个图形2。\n除去软件结构上的限制和简化方面的进展，软件仍然保持着无法可视化的固有特性，从而剥夺了一些具有强大功能的概念工具的构造思路。这种缺憾不仅限制了个人的设计过程，也严重地阻碍了相互之间的交流', '0000-00-00 00:00:00', '知乎', ''),
(5, 'Example Page', 'admin', NULL, '<img src=\"http://soooo.club/imgs/avatar.png\" style=\"float:right\">This is an example.php\n\n	文章页示例页面，提供了丰富的接口与引用方法。\n\n	重点是满足网站开发的可移植性与可拓展性，尽量使用引用的方法。\n\n	网页引用header.php和footer.php。主体内容是mainContent，再此之中以day区分多篇文章。本部分内容为postCon，postCon右上方的dayTitle链接到上一级，左上方的postTitle连接到本页面。右边是sideBar，其中的sideBarMain内，引用news.php。\n<button class=\"flip\" type=\"button\">HelloWorld.java</button>\n<pre><code>//HelloWorld.java\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World!\");\n    }\n}</code></pre><pre><code>//HelloWorld.cpp\n#include &lt;iostream&gt;\nusing namespace std;\nint main(){\n    cout &lt;&lt; \"Hello World!\";\n}</code></pre>\n<div class=\"table-responsive\"><table class=\"table table-striped table-condensed table-hover\"><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>默认，空白会被浏览器忽略</td></tr><tr><td>pre</td><td>空白会被浏览器保留，类似<code>&lt;pre&gt;</code>标签</td></tr><tr><td>nowrap</td><td>文本不会换行，直到遇到<code>&lt;br/&gt;</code></td></tr><tr><td>pre-wrap</td><td>保留空白符，正常进行换行</td></tr><tr><td>pre-line</td><td>合并空白符，保留换行符</td></tr><tr><td>inherit</td><td>从父元素继承<code>white-space</code>属性的值</td></tr></tbody></table></div>', '2017-07-27 13:59:34', 'WuGN', ''),
(6, '美好的一天', '啊諾', NULL, '?? ????? Eh- Sexy Lady / 哥哥是江南style 喔- 性感女士\r\n?? ????? Eh- Sexy Lady / 哥哥是江南style 喔- 性感女士\r\n?? ????? /哥哥是江南style', '2017-08-03 13:59:15', 'WuGN', ''),
(7, '书籍的世界', '赫尔曼·黑塞', NULL, '　　我们阅读的目的不应当是忘却我们自己和我们的日常生活，而是与此相反，我们阅读的目的是更加自信而成熟地把握我们自己的生活。我们应该走向书籍，但不应当像胆怯的学生走向冷酷的老师，也不应当像无用的人走向烧酒，而是应该像登山者走向阿尔卑斯山，像斗士走向军械库一样；我们不应当做匆匆的过客，做对生活不满的人，而是应当乐于做他人的朋友和帮手。\r\n\r\n　　一位作家是否具有影响力，归根到底，从来不取决于一种单一的能力，不取决于技巧、聪慧、趣味，而是取决于他的天性的特质，取决于他以何种完美状态和何种力量将自己的特点表现出来。关键就在于他对生活的一种明晰的态度，在于对于生活中必要之物的一种最发自内心的感受，在于与自然生命意志的一种被感悟到的，而非挖空心思想出来的和谐一致。\r\n\r\n　　对于我们来说，最重要的不应该是阅读和了解尽可能多的东西，而是自由地亲自挑选那些在纪念会上令我们陶醉于其中的杰作，并在这种挑选中了解到人类思想和追求的广度与深度，从而与全人类，与人类的生活和心跳建立起一种令人振奋的、同呼吸共命运的联系。在那些杰作没有在我们身上传承之前，我们必须首先在它们身上证明自己。\r\n（王传生摘自花城出版社《书籍的世界》一书）', '2017-08-05 08:20:01', 'WuGN', ''),
(8, '月光下的白马', '鲍尔吉·原野', NULL, '<div style=\"text-align:center;\"><img src=\"http://oourcagfr.bkt.clouddn.com/201708/月光下的白马.jpg\" style=\"height:296px;width:300px;\" /></div>\r\n    我住在牧民香加台的家里。那天晚上到公社听四胡演奏的比赛，回来快后夜两点了。刚要推门，听马厩传来沙沙声。子夜的月亮转到了天空的右边，正好照在马厩里，白马低着头嚼夜草。\r\n\r\n    月亮比前半夜更亮。亮这话也不对，像更白。两寸高的小草都拖着一根清晰的影子，屋檐下压酸菜的青石变为奶白色，砖房的水泥缝像罩在房子外的渔网。\r\n\r\n    马抬起头，见我没有丝毫惊讶，大眼睛依然安静，鼻梁有一条菱形的青斑，它的脸庞和脖颈血管粗隆。\r\n\r\n    马站着睡觉，我从小就对此感到奇怪，到现在也没人告诉我这是为什么。我此刻惊讶的是，月光下的马像从另一个世界来的动物。人类民间故事里有狼和羊的故事，有熊和老虎的故事，狐狸的故事最多，这一点狐狸自己都不知道。民间故事却很少说到马，《西游记》也没让唐僧的白龙马参与到太多不着调的事情当中。“默默”这个词最适合于马。\r\n\r\n    香加台的白马抬起头，看着马厩外边的花池子，披一脸的月色。三色堇的花瓣开累了，仰到后背；一株弯腰的向日葵，花蕊被人捋去了一半，露出带葵花子的半个脸。马看着它们，没什么表情，像在回忆自己的一生。\r\n\r\n    马的眼睛没有猫的警觉、狗的好奇，也没有猪的糊涂。对半夜有人参观马厩，马好像比人更宽容。从眼神看，马离人间的事情很远，离故事也远。而猫狗的惊慌哀怨、忠勇依赖证明它们就在人中间。\r\n\r\n    马缓慢地嚼草，好像早晚会嚼出一个金戒指来。我想，把“功课”这个词送给马蛮贴切。马嚼草与蚕食桑叶一样，仿佛从中可以构思出一部歌剧来。故事的旋律怎样与人物旋律相吻合，乐队与人声怎样对位，这些事需要彻夜不眠地思考，需要嚼干草。我从小在我爸“不要狼吞虎咽”的规劝中长大，几年前终于得了胃病。我觉得我爸的规劝像在空中飞了几十年的石子，最后落了地。我之狼吞虎咽、之不咀嚼、之消化液不足，让胃承担了负累。如今我看马慢嚼、看小猫每顿只吃几口饭、看公鸡一粒一粒地啄食，觉得它们都比我高明，虽然它们的爸什么也没说。\r\n\r\n    香加台每天早上骑这匹白马出去飞奔，像办公事，实际什么事也没办。他说马想跑一跑，马不跑就要得病了。香加台的马从毯子似的山坡跑下来，尾巴拉成直线，它的两个前蹄子像在跨越栅栏。马飞奔，像我们做操那么简便。\r\n\r\n    马跑完，香加台牵着它遛一段路，落落汗。蒙古人从马背上跨下来，双脚着地就显出了笨。他们走得不轻捷、不巧妙。没有马，他们走路沉重得不像样子。\r\n\r\n    月光下的白马嗅我的手，我摸了摸它的鼻梁，它密密的睫毛挡不住黑眼睛里的光亮。我忽然想起在锡林郭勒草原，一匹飞驰的白马背上有个小孩，敞开的红衣襟掠到后背。马在一尺多高的绿草里飞奔，小孩像泥巴粘在马背上。那匹马好像又回到了眼前，在月光下如此安静。', '2017-08-05 08:49:08', 'WuGN', ''),
(9, '好孩子的故事', '马克·吐温', NULL, '　　从前有个好孩子，名叫雅各布·布利文斯。他对父母总是唯命是从，不管他们的话多么荒唐，多么不合情理。他总是好好读书，上主日学校从不迟到。别的孩子谁也摸不清他的脾气，对他的行为感到费解。雅各布从来不撒谎，不管那有多么容易。他只是对别人说，撒谎不对，就是这个理由。即便在礼拜天，他也不玩打弹子游戏，他不摸鸟巢，不拿辣味糖给街头艺人的猴子吃。总之，他仿佛对一切正当的娱乐活动都不感兴趣。因此，别的孩子总想搞清个中缘由，能对他有所了解。可是他们始终无法得出满意的结论。\r\n\r\n　　雅各布读过主日学校的全部课本，这些书给了他莫大的乐趣，这便是他的全部秘密。他深信主日学校课本里讲的那些好孩子的故事。他巴望着有朝一日能够遇上书中讲的好孩子，可是他从来没有见过这样的人。大概，他们在他出生之前就都已死掉了吧。每当他读到某个好孩子的突出事迹时，便赶快翻到文章的结尾，看看这孩子最后究竟结局如何。他想跑到数千里之外，当面看个仔细，但结果总是镜花水月，那好孩子在最后一章总是死掉，中间还有一幅葬礼的插图——他的亲属和主日学校的同学围在他的墓旁，他们都身着很短的裤子，头戴过大的帽子，手拿一码半长的大手绢捂着面孔哭。\r\n\r\n　　雅各布怀有崇高的抱负，渴望自己被写进主日学校的课本里。他希望，课本在介绍他的事迹时，能够附些插图，描绘他不肯对妈妈说谎和妈妈为此高兴得老泪纵横的情景；还描写他站在门前的台阶上把一个便士施舍给身边一个有六个孩子的叫花婆，叫她随意花用，但不要浪费，因为浪费是一种罪恶；另外一些插图描写他气量宽宏，不肯告发一个坏孩子，那个坏孩子在放学之后，总是躲在拐角处等他，用板条抽打他的脑袋，然后赶他回家。雅各布在前面走，那坏孩子跟在后面“嗨！嗨！”地喊叫。他虽然希望自己被写进主日学校的课本，但是想到好孩子的结局老是死去，心里就不是个滋味。要知道，他是喜欢活着的。\r\n\r\n　　然而，不知怎的，这个好孩子老是倒霉，他碰到的事情与书中好孩子所碰到的总是两样。书中的好孩子总是玩得尽兴，书中的坏孩子老是摔断双腿；他呢，做啥事情都适得其反。他发现吉姆·布莱克在偷别人树上的苹果，便赶忙跑到树底下给他读起坏孩子偷邻居树上的苹果，掉下来摔断胳膊的故事。说来也奇怪，吉姆真的掉下来了，不过正好掉在他的身上，吉姆安然无恙，他的胳膊倒被砸断了。雅各布真不明白，因为书中没有这种事呀！\r\n\r\n　　有一次，几个坏孩子把一个盲人推进泥坑，雅各布赶紧跑过去把他扶起来。雅各布以为，那个盲人定会为他祝福。可是那个盲人不仅没有为他祝福，反而用拐杖打他的脑袋，说雅各布是想把他抓来重新推倒，然后再装模作样扶他起来。这件事也与书中说的全然不符。\r\n\r\n　　雅各布还想做的一件好事是，找一条挨饿受欺、无家可归的瘸腿狗，带回家里，好好照料它，让它永远感激他。后来他果然找到了这样的一条狗，真是满心喜欢。他把这条狗带回家，喂养起来，但是，当他抚弄它的时候，那狗猛地扑到他身上，把他的衣服撕得稀烂，裤子也仅剩下前裆的几片。他的那副狼狈相，叫人看了大吃一惊。雅各布遍查权威性典籍，也没找出原因何在。那条狗与书中说的狗属于同种，但它的举动与书中的大相径庭。\r\n\r\n　　一次，在去主日学校的路上，他看见一些坏孩子扬帆离岸，在船上玩耍，吓得要死，因为他从书中得知，凡在星期天出去划船的孩子没有一个不被水淹死。他赶紧乘上木筏追去告诫。可是他一脚踩到了一截圆木，失足落水。有一个人很快把他救上岸来，医生抽出他腹中的积水，又帮他恢复了呼吸。不料，他竟因此患了感冒，卧床不起，时间长达九个星期。令人不可思议的是，船上的那几个坏孩子痛快淋漓地玩了一整天，活蹦乱跳地回到家里。雅各布说，书里哪有这种事啊。他完全糊涂了。\r\n\r\n　　雅各布病愈之后，不免有些丧气。不过，他还是决心继续试下去。他知道，截至目前，他的经历还不足以被写进书里，他还没有达到好孩子年岁的极限，只要坚持下去，直到生命终止，他最终还是能够名存书卷的。即使别的全部落空，临终遗言还是靠得住的。\r\n\r\n　　于是，雅各布又去查阅权威性的典籍，发现现在正是他投身海洋、去船上当差的时候。他拜访了一位船长，并向他提出申请。当船长跟他要推荐信时，他自豪地掏出一本宗教小册子，用手指了指上面的一行字：“给雅各布·布利文斯。爱他的老师赠。”然而，这位船长是个粗俗的人，不懂斯文，他说：“啊，去他妈的，这管什么用！这丝毫不能证明你会刷盘子、倒垃圾桶。我看他不是想雇你。”这是雅各布有生以来碰到的最难理解的事情。他读过的那些书历来都是这样说的：老师写在宗教小册子上的赞语无不打动船长的心灵，这将会为你开启名利双收之门。他当时还疑心，是否听错了船长的意思。\r\n\r\n　　雅各布吃了不少苦头，而权威性典籍所描绘的那种事情他却一次也没碰上。后来，有一天，他到处寻找坏孩子，以便对他们进行劝诫。他发现在一座老铸铁厂那里聚着一群孩子。他们正在拿狗开心，把十五条狗拴成一串，还准备把硝化甘油的空桶拴到它们的尾巴上，给它们打扮一番。雅各布看了心里非常难过。他坐到一只硝化甘油的空桶上，用力抓住领头的那条狗的项圈，然后转过脸去，以斥责的目光怒视着那个淘气的汤姆·琼斯。但是，恰在这时，市参议员麦威尔特满脸怒气地走了过来。那几个坏孩子一哄而散，都跑掉了。雅各布却神态坦然地站了起来，套用主日学校课本中演讲词的庄严词语开始讲话了。演讲词的开头总是“啊，先生”之类的。事实上，任何一个孩子，不论是好的还是坏的，讲话从不用“啊，先生”开头。可是，那位市议员哪有耐性听他的下文，揪住他的耳朵原地扭转过来，照着他的屁股狠狠地揍了一巴掌。顷刻间，雅各布的身子就冲出房顶，飞向太阳。那拴成一串的十五条狗像条风筝尾巴似的也跟在他的后面飞了出去。地上那个旧铸铁厂和市参议员的身影也顿时消失殆尽。小雅各布历尽艰辛，苦心准备的临终遗言再也没有发表的机会了，除非他把遗言讲给鸟儿听。\r\n\r\n　　这个力求进取的好孩子就这样死了，但是，他的结局并不像课本中讲的那样好。', '2017-08-05 09:18:25', 'WuGN', ''),
(10, '苏七块', '冯骥才', NULL, '    苏大夫本名苏金散，民国初年在小白楼一带，开所行医，正骨拿环，天津卫挂头牌，连洋人赛马，折胳膊断腿，也来求他。\r\n\r\n    他人高袍长，手瘦有劲，五十开外，红唇皓齿，眸子赛灯，下巴儿一绺山羊须，浸了油赛的乌黑锃亮。张口说话，声音打胸腔出来，带着丹田气，远近一样响，要是当年入班学戏，保准是金少山的冤家对头。他手下动作更是“干净麻利快”，逢到有人伤筋断骨找他来，他呢？手指一触，隔皮截肉，里头怎么回事，立时心明眼亮。忽然双手赛一对白鸟，上下翻飞，疾如闪电，只听“咔嚓咔嚓”，不等病人觉疼，断骨头就接上了。贴块膏药，上了夹板，病人回去自好。倘若再来，一准是鞠大躬谢大恩送大匾来了。\r\n\r\n    人有了能耐，脾气准格色。苏大夫有个格色的规矩，凡来瞧病，无论贫富亲疏，必得先拿七块银元码在台子上，他才肯瞧病，否则决不搭理。这叫嘛规矩？他就这规矩！人家骂他认钱不认人，能耐就值七块，因故得个挨贬的绰号叫做：苏七块。当面称他苏大夫，背后叫他苏七块，谁也不知他的大名苏金散了。\r\n\r\n    苏大夫好打牌，一日闲着，两位牌友来玩，三缺一，便把街北不远的牙医华大夫请来，凑上一桌。玩得正来神儿，忽然三轮车夫张四闯进来，往门上一靠，右手托着左胳膊肘，脑袋瓜淌汗，脖子周围的小褂湿了一圈，显然摔坏胳膊，疼得够劲。可三轮车夫都是赚一天吃一天，哪拿得出七块银元？他说先欠着苏大夫，过后准还，说话时还哼哟哼哟叫疼。谁料苏大夫听赛没听，照样摸牌看牌算牌打牌，或喜或忧或惊或装作不惊，脑子全在牌桌上。一位牌友看不过去，使手指指门外，苏大夫眼睛仍不离牌。“苏七块”这绰号就表现得斩钉截铁了。\r\n\r\n    牙医华大夫出名的心善，他推说去撒尿，离开牌桌走到后院，钻出后门，绕到前街，远远把靠在门边的张四悄悄招呼过来，打怀里摸出七块银元给了他。不等张四感激，转身打原道返回，进屋坐回牌桌，若无其事地接着打牌。\r\n过一会儿，张四歪歪扭扭走进屋，把七块银元“哗”地往台子上一码。这下比按铃还快，苏大夫已然站在张四面前，挽起袖子，把张四的胳膊放在台子上，捏几下骨头，跟手左拉右推，下顶上压，张四抽肩缩颈闭眼呲牙，预备重重挨几下，苏大夫却说：“接上了。”当下便涂上药膏，夹上夹板，还给张四几包活血止疼口服的药面子。张四说他再没钱付药款，苏大夫只说了句：“这药我送了。”便回到牌桌旁。\r\n\r\n    今儿的牌各有输赢，更是没完没了，直到点灯时分，肚子空得直叫，大家才散。临出门时，苏大夫伸出瘦手，拦住华大夫，留他有事。待那二位牌友走后，他打自己座位前那堆银元里取出七块，往华大夫手心一放。在华大夫惊愕中说道：\r\n\r\n    “有句话，还得跟您说。您别以为我这人心地不善，只是我立的这规矩不能改！”\r\n\r\n    华大夫把这话带回去，琢磨了三天三夜，到底也没琢磨透苏大夫这话里的深意。但他打心眼儿里钦佩苏大夫这事这理这人。', '2017-08-05 09:22:04', 'WuGN', ''),
(11, '认牙', '冯骥才', NULL, '　　治牙的华大夫，医术可谓顶天了。您朝他一张嘴，不用说哪个牙疼、哪个牙酸、哪个牙活动，他往里瞅一眼全知道。他能把真牙修理得赛假牙一样漂亮，也能把假牙做得赛真牙一样得用。他哪来的这么大的能耐，费猜！\r\n\r\n　　华大夫人善、正派、规矩，可有个毛病，便是记性差，记不住人，见过就忘，忘得干干净净。您昨天刚去他的诊所瞧虫子牙，今儿在街头碰上，一打招呼，他不认得您了，您恼不恼？要说他眼神差，他从不戴镜子，可为嘛记性这么差？也是费猜！\r\n\r\n　　后来，华大夫出了一件事，把这两个费猜的问题全解开了。\r\n\r\n　　一天下晌，巡捕房来了两位便衣侦探，进门就问，今儿上午有没有一个黑脸汉子到诊所来？长相是络腮胡子，肿眼泡儿，挨着右嘴角一颗大黑痣。华大夫摇摇头说：“记不得了。”\r\n\r\n　　侦探问：“您一上午看几号？”\r\n\r\n　　华大夫回答：“半天只看六号。”\r\n\r\n　　侦探说：“这就奇了！总共一上午才六个人，怎么会记不住？再说这人的长相，就是在大街上扫一眼，保管也会记一年。告明白你吧，这人上个月在估衣街持枪抢了一家首饰店，是通缉的要犯，您不说，难道跟他有瓜葛？”\r\n\r\n　　华大夫平时没脾气，一听这话登时火起，“啪！”一拍桌子，拔牙的钳子在桌面上蹦得老高。他说：“我华家三代行医，治病救人，从不做违背良心的事。记不得就是记不得！我也明白告诉你们，那祸害人的家伙要给我瞧见，甭你们来找我，我找你们去！”\r\n\r\n　　两位侦探见牙医动怒，龇着白牙，露着牙花，不像装假。他们迟疑片刻，扭身走了。\r\n\r\n　　天冷了的一天，华大夫真的急急慌慌跑到巡捕房来。跑得太急，大褂都裂了。他说那抢首饰店的家伙正在开封道上的“一壶春酒楼”喝酒呢！巡捕闻知马上赶去，居然把这黑脸巨匪捉拿归案了。\r\n\r\n　　侦探说：“华大夫，您怎么认出他来的？”\r\n\r\n　　华大夫说：“当时我也在‘一壶春’吃饭，看见这家伙正跟人喝酒。我先认出他嘴角那颗黑痣，这长相是你们告诉我的，可我还不敢断定就是他，天下不会只有一个嘴角长痣的，万万不能弄错！但等到他咧嘴一笑，露出那颗虎牙，这牙我给他看过，记得，没错！我便赶紧报信来了！”\r\n\r\n　　侦探说：“我还是不明白，怎么一看牙就认出来了呢？”\r\n\r\n　　华大夫哈哈大笑，说：“我是治牙的呀，我不认识人，可认识牙呀！”\r\n\r\n　　侦探听罢，惊奇不已。\r\n\r\n　　这事传出去，人们对他那费猜的事就全明白啦。他记不住人，不是毛病，因为他不记人，只记牙；治牙的，把全部心思都使在牙上，医术还能不高？', '2017-08-05 09:30:40', 'WuGN', ''),
(12, '刷子李', '冯骥才', NULL, '    码头上的人，全是硬碰硬。手艺人靠的是手，手上就必得有绝活。有绝活的，吃荤，亮堂，站在大街中央；没能耐的，吃素，发蔫，靠边呆着。这一套可不是谁家定的，它地地道道是码头上的一种活法。自来唱大戏的，都讲究闯天津码头。天津人迷戏也懂戏，眼刁耳尖，褒贬分明。戏唱得好，下边叫好捧场，像见到皇上，不少名角便打天津唱红唱紫、大红大紫；可要是稀松平常，要哪没哪，戏唱砸了，下边一准起哄喝倒彩，弄不好茶碗摇篮上去；茶叶末子沾满戏袍和胡须上。天下看戏，哪儿也没天津倒好叫得厉害。您别说不好，这一来也就练出不少能人来。各行各业，全有几个本领齐天的活神仙。刻砖刘、泥人张、风筝魏、机器王、刷子李等等。天津人好把这种人的姓，和他们拿手擅长的行当连在一起称呼。叫长了，名字反没人知道。只有这一个绰号，在码头上响当当和当当响。\r\n\r\n    刷子李是河北大街一家营造厂的师傅。专干粉刷一行，别的不干。他要是给您刷好一间屋子，屋里任嘛甭放，单坐着，就赛升天一般美。最别不叫绝的是，他刷浆时必穿一身黑，干完活，身上绝没有一个白点。别不信！他还给自己立下一个规矩，只要身上有白点，白刷不要钱。倘若没这一本事，他不早饿成干儿了？\r\n\r\n    但这是传说。人信也不会全信。行外的没见过的不信，行内的生气愣说不信。\r\n刷子李收个徒弟叫曹小三。徒弟的开头都是端茶、点烟、提东西。曹小三当然早就听说过师傅那手绝活，一直半信半疑这回非要亲眼瞧瞧。\r\n\r\n    那天，头一次跟随师傅出去干活，到英租界镇南道给李善人新造的洋房刷浆。到了那儿，刷子李跟随管事的人一谈，才知道师傅派头十足。照他的规矩一天只刷一间屋子。这洋楼大小九间屋，得刷九天。干活前，他把随身带的一个四四方方的小包袱打开，果然一身黑衣黑裤，一双黑布鞋。穿上这身黑，就赛跟地上一桶白浆较上了劲。\r\n\r\n    一间屋子，一个屋顶四面墙，先刷屋顶后刷墙。顶子尤其难刷，蘸了稀溜溜粉浆的板刷往上一举，谁能一滴不掉？一掉准掉在身上。可刷子李一举刷子，就赛没有蘸浆。但刷子划过屋顶，立时匀匀实实一道白，白得透亮，白得清爽。有人说这蘸浆的手法有高招，有人说这调浆的配料有秘方。曹小三怎看出来？只见师傅的手臂悠然摆来，悠然摆去，好赛伴着鼓点，和着琴音，每一摆刷，那长长的带浆的毛刷便在墙面“啪”的清脆一响，极是好听。啪啪声里，一道道浆，衔接得天衣无缝，刷过去的墙面，真好比平平整整打开一面雪白的屏障。可是曹小三最关心的还是刷子李身上到底有没有白点。\r\n\r\n    刷子李每刷完一面墙，必得在凳子上坐一大会儿，抽袋烟，喝一碗茶，再刷下一面墙。此刻，曹小三借着给师傅倒水点烟的机会，拿目光仔细搜索刷子李的全身。每一面墙刷完，他搜索一遍，居然连一个芝麻大小的粉点也没发现。他真觉得这身黑色的衣服有种神圣不可侵犯的威严。\r\n\r\n    可是，当刷子李刷完最后一面墙，坐下来，曹小三给他点烟时，竟然瞧见刷子李裤子上出现一个白点，黄豆大小。黑中白，比白中黑更扎眼。完了！师傅露馅了，他不是神仙，往日传说中那如山般的形象轰然倒去。但他怕师父难堪，不敢说，也不敢看，可妨不住还要扫一眼。\r\n\r\n    刷子李忽然朝他说话：“小三，你瞧见我裤子上的白点了吧。你以为师傅的能耐有假，名气有诈，是吧。傻小子，你再细瞧瞧吧——”\r\n\r\n    说着，刷子李手指捏着裤子轻轻往上一提，那白点即刻没了，再一松手，白点又出现，奇了！他凑上脸用神再瞧，那白点原是一个小洞！刚才抽烟时不小心烧的。里边的白衬裤打小洞透出来，看上去就跟粉浆落上去的白点一模一样！\r\n\r\n    刷子李看着曹小三发怔发傻的模样，笑道：“你以为名气全是虚的？好好学本事吧！”\r\n\r\n    曹小三学徒头一天，见到听到学到的，恐怕别人一辈子也未准明白呢！', '2017-08-05 09:32:24', 'WuGN', ''),
(13, '蓝眼', '冯骥才', NULL, '    古玩行中有对天敌，就是造假画的和看假画的。造假画的，费尽心机，用尽绝招，为的是骗过看假画的那双又尖又刁的眼；看假画的，却凭这双眼识破天机，看破诡计，捏着这造假的家伙没藏好的尾巴尖儿，打一堆画里把它抻出来，晾在光天化日底下。\r\n\r\n    这看假画的名叫蓝眼。在锅店街裕成公古玩铺做事，专看画。蓝眼不姓蓝，他姓江，原名在棠，蓝眼是他的外号。天津人好起外号，一为好叫，二为好记。这蓝眼来源于他的近视镜，镜片厚得赛瓶底，颜色发蓝，看上去真赛一双蓝眼，而这蓝眼的关键还是在他的眼上。据说他关灯看画，也能看出真假；话虽有点玄，能耐不掺假。他这蓝眼看画时还真的大有玄机——看假画，双眼无神；看真画，一道蓝光。\r\n\r\n    这天，有个念书打扮的人来到铺子里，手拿一轴画。外边的题签上写着“大涤子湖天春色图”蓝眼之神看似没看，他知道这题签上无论写嘛，全不算数，真假还得看画。他刷地一拉，疾如闪电，露出半尺画心。这便是蓝眼之神出名的“半尺活”，他看画无论大小，只看半尺。是真是假，全拿这半尺画说话，绝不多看一寸一分。蓝眼之神面对半尺画，眼镜片刷地闪过一道蓝光，他抬起头问来者：\r\n\r\n    “你打算卖多少钱？”\r\n\r\n    来者没急着要价，而是说：\r\n\r\n    “听说西头的黄三爷也临摹过这幅画。”\r\n\r\n    黄三爷是津门造假画的第一高手。古玩铺里的人全怕他。没想到蓝眼听赛没听，又说一遍：\r\n\r\n    “我眼里从来没有什么黄三爷。你说你这画打算卖多少钱吧。”\r\n\r\n    “两条。”来者说。这两条是二十两黄金。\r\n\r\n    要价不低，也不算太高，两边稍稍地你抬我压，十八两便成交了。\r\n\r\n    打这天起，津门的古玩铺都说锅店街的裕成公买到一轴大涤子石涛的山水，水墨浅绛，苍润之极，上边还有大段题跋，尤其难得。有人说这件东西是打北京某某王府流落出来的。来卖画的人不大在行，蓝眼之神却抓个正着。花钱不少，东西更好。这么精的大涤子，十年内天津的古玩行就没现过。那时没有报纸，嘴巴就是媒体，愈说愈神，愈传愈广。接二连三总有人来看画，裕成公都快成了绸缎庄了。\r\n\r\n    世上的事，说足了这头，便开始说那头。大约事过三个月，开始有人说裕成公那幅大涤子靠不住。初看挺唬人，可看上几遍就稀汤寡水，没了精神。真假画的分别是，真画经得住看，假画受不住瞧。这话传开之后，就有新闻冒出来——有人说这画是西头黄三爷一手造的赝品！这话不是等于拿盆脏水往人家蓝眼的袍子上泼吗？\r\n\r\n    蓝眼有根，理也不理。愈是不理，传得愈玄。后来就说得有鼻子有眼儿了。说是有人在针市街一个人家里，看到了这轴画的真品。于是，又是接二连三，不间断有人去裕成公古玩铺看画，但这回是想瞧瞧黄三爷用嘛能耐把蓝眼的眼蒙住的。向来看能人栽跟头都最来神儿！\r\n\r\n    裕成公的老板佟五爷心里有点发毛，便对蓝眼说：“我信您的眼力，可我架不住外头的闲话，扰得咱铺子整天乱哄哄的。咱是不是找个人打听打听那画在哪儿。要真有张一模一样的画，就想法把它亮出来，分清楚真假，更显得咱高。”\r\n\r\n    蓝眼听出来老板没底，可是流言闲语谁也没辙，除非就照老板的话办，真假一齐亮出来。人家在暗处闹，自己在明处赢。\r\n\r\n    佟老板打来尤小五。尤小五是天津卫的一只地老鼠，到处乱钻，嘛事都能叫拿耳朵摸到。他们派尤小五去打听，转天有了消息。原来还真的另有一幅大涤子，也叫《湖天春色图》，而且真的就在针市街一个姓崔的人家！佟老板和蓝眼都不知道这崔家是谁。佟老板便叫尤小五引着蓝眼去看。蓝眼不能不去，待到了那家一看，眼镜片刷刷闪过两道蓝光，傻了！\r\n\r\n    真画原来是这幅。铺子里那幅是假造的！这两幅画的大小、成色、画面，全都一样，连图章也是仿刻的。可就是神气不同——瞧，这幅真的是神气！\r\n\r\n    他当初怎么打的眼，已经全然不知。此时面对这画，真恨不得钻进地里去。他二十年没错看过一幅。他蓝眼简直成了古玩行里的神。他说真必真，说假准假，没人不信。可这回一走眼，传了出去，那可毁了。看真假画这行，看对一辈子全是应该的，看错一幅就一跟头栽到底。\r\n\r\n    他没出声。回到店铺跟老板讲了实话。裕成公和蓝眼是连在一块的，要栽全栽。佟老板想了一夜。有了主意，决定把崔家那轴大涤子买过来，花大价钱也在所不惜。两幅画都攥在手里，哪真哪假就全由自己说了。但办这事他们决不能露面，便另外花钱请个人，假装买主，跟随尤小五到崔家去买那轴画。谁料人家姓崔的开口就是天价。不然就自己留着不卖了。买东西就怕一边非买，一边非不卖。可是去装买主这人心里有底，因为来时黄老板对他有话“就是砸了我铺子，你也得把画给我买来”。这便一再让步，最后竟花了七条金子才买到手，反比先前买的那轴多花了两倍的钱还多。\r\n\r\n    待把这轴画拿到裕成公，佟老板舒口大气，虽然心疼钱，却保住了裕成公的牌子。他叫伙计们把两轴画并排挂在墙上，彻底看个心明眼亮。等画挂好，蓝眼上前一瞧，眼镜片刷刷刷闪过三道光。人竟赛根棍子立在那里。万事大吉下的怪事就在眼前——原来还是先前那幅是真的，刚买回来的这幅反倒是假的！\r\n\r\n    真假不放在一起比一比，根本分不出真假——这才是人家造假画的本事，也是最高超的本事！\r\n\r\n    可是蓝眼长的一双是嘛眼？肚脐眼？\r\n\r\n    蓝眼差点一口气闭过去。转过三天，他把前前后后的事情缕了一遍，这才明白，原来这一切都有是黄三爷在暗处做的圈套。一步步叫你钻进来。人家真画卖得不吃亏，假画卖得比天高。他忽然想起，最早来卖画的那个书生打扮的人，不是对他说过“黄三爷也临摹过这幅画”吗？人家有话在先，早就说明白这幅画有真有假。再看打了眼怨谁？看来，这位黄三爷不单冲着钱来的，干脆说是冲着自己来的。人家叫你手里攒着真画，再去买他造的假画。多绝！等到他明白了这一层，才算明白到家，认栽到底！打这儿起，蓝眼卷起被袱卷儿离开了裕成公。自此不单天津古玩行他这号，天津地面也瞧不见了的影子。有人说他得一场大病，从此躺下，再没起来。栽得真是太惨了！\r\n\r\n    再想想看，他还有更惨的——他败给人家黄三爷，却只见到黄三爷的手笔，人家的面也没叫他见过呢！\r\n\r\n    所幸的是，他最后总算想到黄三爷的这一手。死得明明白白。', '2017-08-05 09:38:10', 'WuGN', ''),
(14, '大回', '冯骥才', NULL, '    大回姓回，人高马大，手大脚大嘴大耳朵大，人叫他大回。\r\n\r\n    叫惯了大回，反倒没人知道他的名字。\r\n\r\n    大回是能人，专攻垂钓。手里一根竹竿子，就是钓鱼竿；一个使针敲成的钩，就是鱼钩；一根纳鞋底子用的上了蜡的细线绳，就是鱼线；还有一片鸽子的羽毛拴在线绳上，就是鱼漂。只凭这几样再普通不过的东西，他蹲在坑边，顶多七天，能把坑里几千条鱼钓光了。连鱼秧子也逃不掉。\r\n\r\n    甭管水里的鱼多杂，他想要哪种就专上哪种鱼；他还能钓完公鱼钓母鱼，一对对地往上钓。他钓的大鱼比他还沉，钓的小鱼比鱼钩还小。\r\n\r\n    人说钓鱼凭的是运气，他凭的便能耐。\r\n\r\n    钓鲫鱼用的红虫子，又小又细，好赛线头，而且只有一层薄皮儿，里边一兜儿血红的水。要想把鱼钩穿进去，那可不易；弄不好钩尖一斜，一股红水出来，单剩下一层皮儿了。可人家大回把红虫子全放在嘴里，在腮帮子那里存着。用的时候，手指捏着鱼钩，张开嘴把钩往里边一挂，保管把那小红虫漂漂亮亮穿在鱼钩上。就这手活，谁会？\r\n\r\n    他无论钓什么都有绝法，比方钓王八。\r\n\r\n    钓鱼时勾到王八，都是竿儿弯，线不动，很容易疑惑是勾上了水下边的石块。心里急，一使劲，线断了！大回不急，稳稳绷住。停了会儿，见线一走，认准那是王八在爬，就更不急着提竿。\r\n\r\n    尤其大王八，被鱼钩勾住之后，便用两只前爪子抓住了草，假若用力提竿，竿不折线断。每到这时候，大回便从腰间摸出一个铜环，从鱼竿的底把套进去，穿过鱼竿一松手，铜环便顺着鱼线溜下去。\r\n\r\n    水底下的王八正吃着劲儿，忽见一个锃亮的东西直朝自己的脑袋飞来，不知是嘛，扬起前爪子一挡，这便松开下边的草。嘿，就势把它舒舒服服地提上来！\r\n\r\n    这招这法，还在哪儿见过？\r\n\r\n    天津卫人过年有个风俗，便是放生。就是把一条活鲤鱼放到河里。为的是行善，求好报。放鱼时，要在鱼的背鳍上拴一根红绳，做个记号。倘若第二年把这鱼打上来，就再拴一根红绳。第三年照样还拴一根。据说这种背上拴着三根红绳的鲤鱼，放到河里，可以跳龙门。一切人间的福禄寿财，就全招来了。\r\n\r\n    可是鲤鱼到处有，拴红绳的鱼无处弄到。鱼要是给鱼钩勾过一次，就变得又灵又贼。拴一根红绳的鲤鱼在鱼市上偶尔还能看见，拴两根红绳的鲤鱼看不见，拴三根红绳的连撒网打鱼的也没瞧见过。你想花大价钱买，他会笑着说：“你有本事把河淘干了，我就有本事把它弄上来。”\r\n\r\n    怎么办？找大回。天津卫八大家都是一进腊月，就跟大回定这种三根红绳的鲤鱼了。\r\n大回站在河边，看好鱼道。鱼道就是鱼在水里常走的路，大回有双神眼，能一眼看到水里。他瞧准鲤鱼常呆的地界，把一个面团扔下去。这面团比栗子大，小鱼吃不进嘴，大鱼一口一个。\r\n\r\n    但这面团里边决不下钩，纯粹是扔到河里喂鱼，一天扔一个。开头，那贼乎乎的大鱼冒着危险试着吃，一吃没事，第二天再来一个，胆儿便渐渐大起，以后见了面团张嘴就吞。半个月二十天后，大回心想差不多了，用鱼钩勾个面团扔下去。错不了——一条拴红绳的大鲤鱼就结结实实绷住了。\r\n\r\n    可是这法子最多只能钓到拴两根红绳的鲤鱼。三根红绳的鲤鱼决不上钩。这三根绳的鲤鱼已经被钓到三次，就是吃屎也不敢再吃面团了。使嘛法子？就用小孩的巴巴做鱼食！大回不是把鱼琢磨透了？\r\n\r\n    南门外那些水坑，哪个坑里有嘛鱼，哪个坑里的鱼大小，哪个坑的鱼有多少条，他心里全一清二楚。他能把坑里的鱼全钓绝了，但他也决不把任何一个坑里的鱼钓绝了。钓绝了，他玩嘛？\r\n\r\n    故而，小鱼不钓，等它长大；母鱼不钓，等它潲子。远近钓者就称他“鱼绝后”，这可不是骂他，是夸他。\r\n\r\n    这外号并不好——\r\n\r\n    辛亥变革后的第三年，夏至后转一天。大回钓了一天鱼，人困马乏。多半辈子，整天站在坑边河边，风吹日晒，身子里的油耗得差不多了。他在鼓楼北的聚合成饭庄，吃饱肚子喝足酒，提着一篓子鱼摇摇晃晃回家。走不动就靠墙睡会儿。他家在北城根，这一段路不近，他走走停停直到午夜，迷迷糊糊就趴在大街上了。\r\n\r\n    这时街上走过来一辆拉东西的马车，赶车人在车上睡着了。但就是醒着也瞧不见他——凑巧这段路的几盏街灯给风吹灭了。这真是该活死不了，该死活不了。马车从他身上压过去时，车夫那老家伙睡得太死，居然也没觉出来，转天亮才叫人发现，大回给车压成一个片儿了，赛张纸似的贴在地面上。奇怪的是，人压瘪了，鱼篓子却没压着，里边的鱼还都活着。等巡警一追查，更奇怪的是，那车上拉的东西，竟然是一车鱼！这事叫人听了一怔一惊，脖子后边冒出凉气来。\r\n\r\n    有人说，这事坏就坏在他那个外号上了，“鱼绝后”就是叫“鱼”把他“绝后”了。但也有人说，这是上天的报应，他一辈子钓的鱼实在太多了，龙王爷叫他去以命抵命。可事情传到东城里的文人裴文锦——裴五爷那里，人家念书的人说的话就另一个味儿了。人家说：\r\n\r\n    <strong>能人全都死在能耐上。</strong>', '2017-08-05 09:44:43', 'WuGN', ''),
(15, '酒婆', '冯骥才', NULL, '    酒馆也分三六九等。首善街那家小酒馆得算顶末尾的一等。不插幌子，不挂字号，屋里连座位也没有；柜台上不卖菜，单摆一缸酒。来喝酒的，都是扛活拉车卖苦力的底层人。有的手捏一块酱肠头，有的衣兜里装着一把五香花生，进门要上二三两，倚着墙角窗台独饮。逢到人挤人，便端着酒碗到门外边，靠树一站，把酒一点点倒进嘴里，这才叫过瘾解馋其乐无穷呢！\r\n\r\n    这酒馆只卖一种酒，是山芋干造的，价钱贱，酒味大。首善街养的猫从来不丢，跑迷了路，也会循着酒味找回来。这酒不讲余味，只讲冲劲，讲嘴赛镪水，非得赶紧咽，不然烧烂了舌头嘴巴牙花嗓子眼儿。可一落进肚里，跟手一股劲“腾”地蹿上来，直撞脑袋，晕晕乎乎，劲头很猛。好赛大年夜里放的那种炮仗“炮打灯”，点着一炸，红灯蹿天。这酒就叫做“炮打灯”。好酒应是温厚绵长，绝不上头。但穷汉子们挣一天命，筋酸骨乏，心里憋闷，不就为了花钱不多，马上来劲，晕头涨脑地洒脱洒脱放纵放纵吗？\r\n\r\n    要说最洒脱，还是数酒婆。天天下晌，这老婆子一准来到小酒馆，衣衫破烂，赛叫花子；头发乱，脸色黯，没人说清她嘛长相，更没人知道她姓嘛叫嘛，却都知道她是这小酒馆的头号酒鬼，尊称酒婆。她一进门，照例打怀里掏出个四四方方小布包，打开布包，里头是个报纸包，报纸有时新有时旧；打开报纸包，又是个绵纸包，好赛里头包着一个翡翠别针；再打开这绵纸包，原来只是两角钱。她拿钱撂在柜台上，老板照例把多半碗“炮打灯”递过去，她接过酒碗，举手扬脖，碗底一翻，酒便直落肚中，好像倒进酒桶。待这婆子两脚一出门坎，就赛在地上划天书了。\r\n\r\n    她一路东倒西歪向北去，走出一百多步远的地界，是个十字路口，车来车往，常常出事。您还甭为这婆子揪心，瞧她烂醉如泥，可每次将到路口，一准是“噔”地一下，醒过来了竟赛常人一般，不带半点醉意，好端端地穿街而过。她天天这样，从无闪失。首善街上人家，最爱瞧酒婆这醉醺醺的几步扭——-上摆下摇，左歪右斜，悠悠旋转乐陶陶，看似风摆荷叶一般；逢到雨天，雨点淋身，便赛一张慢慢旋动的大伞了……但是，为嘛酒婆一到路口就醉意全消呢？是因为“炮打灯”就这么一点劲头儿，还是酒婆有超人的能耐说醉就醉说醒就醒？\r\n\r\n    酒的诀窍，还是在酒缸里。老板人奸，往酒里掺水。酒鬼们对眼睛里的世界一片模糊，对肚子里的酒却一清二楚，但谁也不肯把这层纸捅破，喝美了也就算了。老板缺德，必得报应，人近六十，没儿没女，八成要绝后。可一日，老板娘爱酸爱辣，居然有喜了！老板给佛爷叩头时，动了良心，发誓今后老实做人，诚实卖酒，再不往酒里掺水掺假了。\r\n\r\n    就是这日，酒婆来到这家小酒馆，进门照例还是掏出包儿来，层层打开，花钱买酒，举手扬脖，把改假为真的“炮打灯”倒进肚里……真货就有真货色。这次酒婆还没出屋，人就转悠起来了。而且今儿她一路上摇晃得分外好看，上身左摇，下身右摇，愈转愈疾，初时赛风中的大鹏鸟，后来竟赛一个黑黑的大漩涡。首善街的人看得惊奇，也看得纳闷，不等多想，酒婆已到路口，竟然没有酒醒，破天荒头一遭转悠到大马路上，下边的惨事就甭提了……\r\n\r\n    自此，酒婆在这条街上绝了迹。小酒馆里的人们却不时念叨起她来。说她才算真正够格的酒鬼。她喝酒不就菜，照例一饮而尽，不贪解馋，只求酒劲。在酒馆既不多事，也无闲话，交钱喝酒，喝完就走，从来没赊过账。真正的酒鬼，都是自得其乐，不搅和别人。\r\n\r\n    老板听着，忽然想到，酒婆出事那日，不正是自己不往酒里掺假的那天吗？原来祸根竟在自己身上他便别扭开了，心想这人间的道理真是说不清道不明了。到底骗人不对，还是诚实不对？不然为嘛几十年拿假酒骗人，却相安无事，都喝得挺美，可一旦认真起来反倒毁了？', '2017-08-05 09:46:36', 'WuGN', ''),
(16, '好嘴杨巴', '冯骥才', NULL, '　　津门胜地，能人如林，此间出了两位卖茶汤的高手，把这种稀松平常的街头小吃，干得远近闻名。这二位，一位胖黑敦厚，名叫杨七；一位细白精明，人称杨八。杨七杨八，好赛哥俩，其实却无亲无故，不过他俩的爹都姓杨罢了。杨八本名杨巴，由于“巴”与“八”音同，杨巴的年岁长相又比杨七小，人们便错把他当成杨七的兄弟。不过要说他俩的配合，好比左右手，又非亲兄弟可比。杨七手艺高，只管闷头制作；杨巴口才好，专管外场照应，虽然里里外外只这两人，既是老板又是伙计，闹得却比大买卖还红火。\r\n\r\n　　杨七的手艺好，关键靠两手绝活。\r\n\r\n　　一般茶汤是把秫米面沏好后，捏一撮芝麻洒在浮头，这样做香味只在表面，愈喝愈没味儿。杨七自有高招，他先盛半碗秫米面，便洒上一次芝麻，再盛半碗秫米面，沏好后又洒一次芝麻。这样一直喝到见了碗底都有香味。\r\n\r\n　　他另一手绝活是，芝麻不用整粒的，而是先使铁锅炒过，再拿擀面杖压碎。压碎了，里面的香味才能出来。芝麻必得炒得焦黄不糊，不黄不香，太糊便苦；压碎的芝麻粒还得粗细正好，太粗费嚼，太细也就没嚼头了。这手活儿别人明知道也学不来。手艺人的能耐全在手上，此中道理跟写字画画差不多。\r\n\r\n　　可是，手艺再高，东西再好，拿到生意场上必得靠人吹。三分活，七分说，死人说活了，破货变好货，买卖人的功夫大半在嘴上。到了需要逢场作戏、八面玲珑、看风使舵、左右逢源的时候，就更指着杨巴那张好嘴了。\r\n\r\n　　那次，李鸿章来天津，地方的府县道台费尽心思，究竟拿嘛样的吃喝才能把中堂大人哄得高兴？京城豪门，山珍海味不新鲜，新鲜的反倒是地方风味小吃，可天津卫的小吃太粗太土：熬小鱼刺多，容易卡嗓子；炸麻花梆硬，弄不好硌牙。琢磨三天，难下决断，幸亏知府大人原是地面上走街串巷的人物，嘛都吃过，便举荐出“杨家茶汤”；茶汤粘软香甜，好吃无险，众官员一齐称好，这便是杨巴发迹的缘由了。\r\n\r\n　　这日下晌，李中堂听过本地小曲莲花落子，饶有兴味，满心欢喜，撒泡热尿，身爽腹空，要吃点心。知府大人忙叫“杨七杨八”献上茶汤。今儿，两人自打到这世上来，头次里外全新，青裤青褂，白巾白袜，一双手拿碱面洗得赛脱层皮那样干净。他俩双双将茶汤捧到李中堂面前的桌上，然后一并退后五步，垂手而立，说是听候吩咐，实是请好请赏。\r\n\r\n　　李中堂正要尝尝这津门名品，手指尖将碰碗边，目光一落碗中，眉头忽地一皱，面上顿起阴云，猛然甩手“啪”地将一碗茶汤打落在地，碎瓷乱飞，茶汤泼了一地，还冒着热气儿。在场众官员吓懵了，杨七和杨巴慌忙跪下，谁也不知中堂大人为嘛犯怒？\r\n\r\n　　当官的一个比一个糊涂，这就透出杨巴的明白。他眨眨眼，立时猜到中堂大人以前没喝过茶汤，不知道洒在浮头的碎芝麻是嘛东西，一准当成不小心掉上去的脏土，要不哪会有这大的火气？可这样，难题就来了——\r\n\r\n　　倘若说这是芝麻，不是脏东西，不等于骂中堂大人孤陋寡闻，没有见识吗？倘若不加解释，不又等于承认给中堂大人吃脏东西？说不说，都是要挨一顿臭揍，然后砸饭碗子。而眼下顶要紧的，是不能叫李中堂开口说那是脏东西。大人说话，不能改口。必须赶紧想辙，抢在前头说。\r\n\r\n　　杨巴的脑筋飞快地一转两转三转，主意来了！只见他脑袋撞地，“咚咚咚”叩得山响，一边叫道：“中堂大人息怒！小人不知道中堂大人不爱吃压碎的芝麻粒，惹恼了大人。大人不记小人过，饶了小人这次，今后一定痛改前非！”说完又是一阵响头。\r\n\r\n　　李中堂这才明白，刚才茶汤上那些黄渣子不是脏东西，是碎芝麻。明白过后便想，天津卫九河下梢，人情练达，生意场上，心灵嘴巧。这卖茶汤的小子更是机敏过人，居然一眼看出自己错把芝麻当做脏土，而三两句话，既叫自己明白，又给自己面子。这聪明在眼前的府县道台中间是绝没有的，于是对杨巴心生喜欢，便说：\r\n\r\n　　“不知者当无罪！虽然我不喜欢吃碎芝麻（他也顺坡下了），但你的茶汤名满津门，也该嘉奖！来人呀，赏银一百两！“\r\n\r\n　　这一来，叫在场所有人摸不着头脑。茶汤不爱吃，反倒奖巨银，为嘛？傻啦？杨巴趴在地上，一个劲儿地叩头谢恩，心里头却一清二楚全明白。\r\n\r\n　　自此，杨巴在天津城威名大震。那“杨家茶汤”也被人们改称做“杨巴茶汤”了。杨七反倒渐渐埋没，无人知晓。杨巴对此毫不内疚，因为自己成名靠的是自己一张好嘴，李中堂并没有喝茶汤呀！', '2017-08-05 09:49:50', 'WuGN', ''),
(17, '刘道元出殡', '冯骥才', NULL, '　　天津卫的买卖家多如牛毛。两家之间只要纠纷一起，立时就有一种人钻进来，挑词架讼，把事闹大，一边代写状子，一边去拉拢官府，四处奔忙，借机搂钱。这种人便是文混混儿。\r\n\r\n　　混混儿是天津卫土产的痞子。历来分文武两种。武混混儿讲打讲闹，动辄断臂开瓢，血战一场；文混混却只凭手中一支笔，专替吃官司的买卖家代理讼事。别看笔毛是软的，可文混混儿的毛笔里藏着一把尖刀；白纸黑字，照样要人命。这文混混之中，拔尖的要数刘道元。\r\n\r\n　　买卖家打官司，谁使刘道元的状子谁准赢，没跑。人说，他手里的笔就是判官笔，他本人就是本地人间的判官，谁死谁活，全看他笔下的一撇一捺了。可是他决不管小店小铺的事，只给大买卖写状子。大买卖有钱，要多少给多少。他要是缺钱，也用不着去借，只要到大买卖门前，往门框上一靠，掌柜的立时就包一包钱，笑嘻嘻送上来。那些武混混儿们来要钱，都是用爬头钉打嘴里把自己的嘴巴子钉在门框上，不给钱不算完。那模样龇牙咧嘴，鲜血直流，真把人吓死。但人家文混混儿刘道元决不这么干，他倚在门框上的神气，好赛闲着没事晒太阳。只要钱一到手，扭身就走，决不多事。这便是文混混儿的这个“文”字了。\r\n\r\n　　刘道元有钱，不买房置地，不耍钱，不逛窑子，连仆婢也一概不用。光棍一个人，一直住在西门外掩骼会北边的一个院子，由两个徒弟金三和马四伺候着。赚来的钱，吃用之外，全都使在义气上了。他走在路上，只要听到谁家在屋里哭哭啼啼，说穷道苦，或者穷得打架，便一撩窗子，一把钱哗哗啦扔进去。掩骼会那一带，不少人家受过他的恩惠。可谁也不敢当面谢他；你谢他，他不认账，还翻脸骂你。\r\n\r\n　　要论混混儿的性子，不管文武，全一个混样。\r\n\r\n　　一天，他忽把两徒弟金三和马四叫到跟前说：“师傅我今年五十六，人间的事看遍了，阴间的事一点也不知道。近来我总琢磨着，这人死后到底嘛样？我今儿有个好主意，我装死，活着出一次殡，我呢，就躲在棺材里，好好开开眼。可我人在棺材里，外边事不能料理，就全交给你们俩了。听着！你们俩王八蛋别心一黑，把我钉死在棺材里！”\r\n\r\n　　金三灵又快，马四笨又慢。金三说：“哪能呢，师傅要是完了，我俩还不如一对丧家犬呢。师傅！您的主意虽好，可人家死人，都得累七作斋，至少也得七天。您哪能天天躲在棺材里？那里边又黑又窄又闷，您受得住？再说您要是急着吃东西、急着拉屎怎么办？我的意思，棺材摆在灵堂上是空的，您人藏在后院那间堆东西的小屋里。后院绝对不准人去。吃喝一切，我俩天天照样伺候您。等到出殡那天，你再往棺材里一钻。至于那棺材盖儿，哪能钉呀，您还得掀开一点往外瞧呢！”\r\n\r\n　　刘道元笑了。说：“你这王八蛋还真灵，就这么办吧！”\r\n跟着，天津卫全知道大文混混儿刘道元死了。还知道他是半夜得暴病死的。于是刘家门外贴出讣告，家内设了灵堂，放棺材，摆牌位，还供上那支大名鼎鼎的判官笔，再请来和尚，吹吹打打，作斋七天。来吊唁的人真不少，门口排成长龙，好赛大年夜卞家开粥场。\r\n\r\n　　刘道元藏在后院小屋里，有吃有喝，还有个盆，能够拉尿，倒蛮舒服。金三一直在前边盯着应酬，马四不时跑来向师傅送个消息。开头，刘道元很是得意。心想自己活着时威风八面，人“死”后一样神气十分。可是两天过后，一寻思，有点不对，那些给他打赢官司的大掌柜们，怎么一个没来；没名没姓的人倒是蜂拥而至。是不是来看热闹来的？这些人平时走过他家门口，连扭头朝里边瞥上一眼都不敢，此刻居然能登堂入室，把他这个大混混儿日常的活法，看个明白。马四说，头年里叫他一纸状子几乎倾家荡产的福顺成洋货店的贺老板，这次也来了。他大模大样走上灵堂，非但不行礼，却“呸”地把一口大黏痰留在地上。随后，任嘛稀奇古怪的事全来了。\r\n\r\n　　作斋的第四天，一条大汉破门而入，居然还牵着一条狼狗进了灵堂。进门就骂：“姓刘的，你一死，借我那十条金子，叫我找谁要去？你不还我钱，我就坐在这儿不起来。”他真的就坐在堂屋中央一动不动。占着地界儿，叫别人没法进来行礼。金三马四从来没见过这汉子，知道是找茬儿讹钱来的。上去连说带劝也没用，只好动手去拉，谁料这汉子劲儿奇大，一拳一个，把金三马四打得各一个元宝大翻身。金三马四都是文混混儿，下笔千斤，手中无力，拿他没辙，干瞪眼等着。直到后晌，他闹得没劲才起身离去。临出门时说十天后要来收这几间屋子顶债。他牵来那只大狼狗一蹿，把摆在桌上用来施舍给孤魂野鬼的大白馒头叼走一个。\r\n\r\n　　马四人实，把这些事全都照实说了。刘道元一听，火冒三丈，气得直叫：“哪个王八蛋敢来坑我！我刘道元跟谁借过钱？我不死啦！我看看这个王八蛋是谁？”\r\n\r\n　　马四顶不住，赶紧把金三找来。金三说：“您一出去，还不是诈尸了？咱的戏可就没法往下演了。师傅您先压压火，一切都等着出完大殡再说。您不也正好能看看这些人都是嘛变的吗？”\r\n\r\n　　金三最后这句话管用。眼瞧着刘道元的火下去了。自此，马四不再对师傅学舌前边的事。刘道元忍不住时，向他打听平时那些熟人们，哪个来哪个没来。马四明白，师傅心里问的是另一个文混混儿，大名叫一枝花。那家伙整天往他们这儿跑，跟刘道元称兄道弟，两好得穿一条裤子，可是打刘道元一“死”，他也跟死了一样，一面不露。马四哪敢把这情形对师傅说？马四愈不说，他心里愈明白。脸就愈拉愈长，好赛下巴上挂个秤砣。后来干脆眼一闭，不闻不问了，看上去真跟死人差不多。\r\n\r\n　　这天下晌，院里忽有响动。不像是金三马四。侧耳朵再听，原来是邻居那个卖开水的乔二龙，还有他儿子狗子，翻过墙头，来到他的后院。隔窗只听狗子说：“爹，金三马四一来，咱再翻墙跑可就来不及了。”乔二龙说：“怕嘛？脓包！金三马四连苍蝇都打不死，你还怕他们。这刘家无后，东西没主，咱不拿别人也拿！跟我来――”\r\n\r\n　　刘道元肺快气炸了。心想，我“活”着的时候给你们钱，你们拿我当爷爷；我“死”了就来抄我的家！你们还要干嘛？扒我的皮做拨浪鼓吗？\r\n\r\n　　他想砸开门出去，但不行，不能为这两个狗操的把事坏了。心里一急，不知哪来的主意，竟装出一个女人腔，拿着嗓子细声叫：“快来人呀！有坏人呀！”这一喊，竟把乔家父子吓得赛两个瞎驴，连跑带蹿，噼哩叭啦翻墙跑了。幸好的是，前边念经的和尚们鼓乐正欢，没听到他这边的叫声。可马四再来时，却见他一桌子吃的东西，全扔在地上了。\r\n\r\n　　过了一七，总算没出太大差错，万事大吉。金三把供桌上的判官笔放进棺材。对人说这支判官笔必须给师傅陪葬；还说，这支笔是支金笔，华世奎那支笔只是支草笔，这支金笔只配他师傅一个人使。然后，他悄悄去请师傅，乘人不注意，赶紧入棺，起灵出殡。刘道元骂一句：“真他妈不知是活够了，还是死够了。”便一头钻进了棺材。\r\n\r\n　　棺材里,金三给他一切准备得舒舒服服。盖是活的，想开就开；里边照旧有吃有喝，还有个枕头可以睡觉。他哪有空儿睡觉，好不容易“死”一次,他得“死”得再明白些。\r\n\r\n　　棺材抬起，往灵车上摆放的时候，就听到金三和马四一左一右哭起来。金三灵，说哭就哭，声音就赛撕肝扯肺一般。刘道元想，还是金三好，马四这王八蛋连假哭也不会。可是金三的假哭却长不了，闹一会就没声了。这才听出马四这边也有哭声。马四来得慢，声音不大，可动了真格的，呜呜哭了一路，好赛死了亲爹。这没完没了的哭，反而扰得刘道元心烦，愈听愈丧气。刘道元已经弄不明白，到底是真的好还是假的好了。\r\n\r\n　　走着走着，刘道元忽听，外边乱嘈嘈，声音挺大，好赛出了嘛事。跟着灵车也停住了。他心里奇怪，两手托住棺材盖，使劲举开一条缝，朝外一瞧，只见纸人纸马，纸车纸轿，黑白无常，银幡雪柳，白花花一片。街两旁却黑压压，站满瞧出殡的人。到底嘛事叫出殡的队伍停住了？他透过旗杆再一瞧，竟看见一些人伸拳伸腿挡在前面，原来是会友脚行的滕黑子那帮武混混儿。他心想这帮人平日跟他一向讲礼讲面，怎么也翻脸了，想干嘛？这时他突然瞧见，他那弟兄一枝花也站在那帮人中间。只听一枝花在叫喊着：“那支判官笔本来就该归我，他算个屁！死了还想把笔带走？没门！不交给我，甭想过去！”\r\n\r\n　　刘道元的脑袋“哄”的一下——但这次没急，反倒豁朗了。心里说：“原来人死了是这么回事，老子全明白了！”双手发力一推棺材盖，哐啷一响，他站了起来。\r\n\r\n　　这一下，不但把出殡的和看热闹的全吓得鸡哇喊叫，连截道的那帮混混儿也四散而逃。\r\n刘道元站在灵车上大笑不绝。', '2017-08-05 09:50:38', 'WuGN', ''),
(18, '泥人张', '冯骥才', NULL, '　　手艺道上的人，捏泥人的“泥人张”排第一。而且，有第一，没第二，第三差着十万八千里。\r\n\r\n　　泥人张大名叫张明山。咸丰年间常去的地方有两处。一是东北城角的戏院大观楼，一是北关口的饭馆天庆馆。坐在那儿，为了瞧各样的人，也为捏各样的人。去大观楼要看戏台上的各种角色，去天庆馆要看人世间的各种角色。这后一种的样儿更多。\r\n\r\n　　那天下雨，他一个人坐在天庆馆里饮酒，一边留神四下里吃客们的模样。这当儿，打外边进来三个人。中间一位穿得阔绰，大脑袋，中溜个子，挺着肚子，架式挺牛，横冲直撞往里走。站在迎门桌子上的“撂高的”一瞅，赶紧吆喝着：“益照临的张五爷可是稀客，贵客，张五爷这儿总共三位──里边请!”\r\n\r\n　　一听这喊话，吃饭的人都停住嘴巴，甚至放下筷子瞧瞧这位大名鼎鼎的张五爷。当下，城里城外气最冲的要算这位靠着贩盐赚下金山的张锦文。他当年由于为盛京将军海仁卖过命，被海大人收为义子，排行老五。所以又有“海张五”一称。但人家当面叫他张五爷，背后叫他海张五。天津卫是做买卖的地界儿，谁有钱谁横，官儿也怵三分。\r\n\r\n　　可是手艺人除外，手艺人靠手吃饭，求谁?怵谁?故此，泥人张只管饮酒，吃菜，西瞧东看，全然没有把海张五当个人物。\r\n\r\n　　但是不一会儿，就听海张五那边议论起他来。有个细嗓门的说：“人家台下一边看戏一边手在袖子里捏泥人。捏完拿出来一瞧，台上的嘛样，他捏的嘛样。”跟着就是海张五的大粗嗓门说：“在哪儿捏?在袖子里捏?在裤裆里捏吧!”随后一阵笑，拿泥人张找乐子。\r\n\r\n　　这些话天庆馆里的人全都听见了。人们等着瞧艺高胆大的泥人张怎么“回报”海张五。一个泥团儿砍过去?\r\n\r\n　　只见人家泥人张听赛没听，左手伸到桌子下边，打鞋底抠下一块泥巴。右手依然端杯饮酒，眼睛也只瞅着桌上的酒菜，这左手便摆弄起这团泥巴来，几个手指飞快捏弄，比变戏法的刘秃子还灵巧。海张五那边还在不停地找乐子，泥人张这边肯定把那些话在他手里这团泥上全找回来了。随后手一停，他把这泥团往桌上“叭”地一戳，起身去柜台结账。\r\n\r\n　　吃饭的人伸脖一瞧，这泥人张真捏绝了!就赛把海张五的脑袋割下来放在桌上一般。瓢似的脑袋，小鼓眼，一脸狂气，比海张五还像海张五。只是只有核桃大小。\r\n\r\n　　海张五在那边，隔着两丈远就看出捏的是他。他朝着正走出门的泥人张的背影叫道：“这破手艺也想赚钱，贱卖都没人要。”\r\n\r\n　　泥人张头都没回，撑开伞走了。但天津卫的事没有这样完的——\r\n\r\n　　第二天，北门外估衣街的几个小杂货摊上，摆出来一排排海张五这个泥像，还加了个身子，大模大样坐在那里。而且是翻模子扣的，成批生产，足有一二百个。摊上还都贴着个白纸条，上边使墨笔写着：贱卖海张五。\r\n\r\n　　估衣街上来来往往的人，谁看谁乐。乐完找熟人来看，再一块乐。\r\n\r\n　　三天后，海张五派人花了大价钱，才把这些泥人全买走，据说连泥模子也买走了。泥人是没了，可“贱卖海张五”这事却传了一百多年，直到今个儿。', '2017-08-05 09:51:35', 'WuGN', ''),
(19, '绝盗', '冯骥才', NULL, '　　老城区和租界之间那块地，是天津卫最野的地界。人头极杂，邪事横生。二十年代，这里一处临街小屋，来了一对青年男女租房结婚。新床新柜，红壶绿盆，漂漂亮亮装满一屋。大门外两边墙垛子上还贴了一双红喜字。结婚转天一早，小两口就出门做事上班。邻居也不知他们姓甚名谁。\r\n\r\n　　事过三天，小两口去上班不久，忽然打东边飞也似来了一辆拉货的平板三轮。蹬车的是个老头子，骨瘦肉紧，皮黑牙黄，小腿肚子赛两个铁球，一望便知是个长年蹬车的车夫。车板上蹲着两个小子，全是十七八岁，手拿木棍、板斧和麻绳。这爷仨面色都凶，看似来捉冤家。\r\n\r\n　　老头子把车直蹬到那新婚小两口的门前，猛一刹车，车上两小子蹦下来，奔到门前一看，扭头对那老头子说：“爹，人不在家，门还锁着呢！”门板上确是挂着一把大洋锁。\r\n老头子登时火冒三丈，眼珠子瞪得全是眼白，脑袋脖子上的青筋直蹦，跳下车大骂起来：“这不孝的禽兽，不管爹娘，跑到这儿造他妈宫殿来了。小二、小三，给我把门砸开！”\r\n\r\n　　应声，那两个小子抡起板斧，把门锁砸散。门儿大开，一屋子新房的物品全亮在眼前。老头子一看更怒，手指空屋子，又跳又叫，声大吓人：\r\n\r\n　　“好呵，没心没肺的东西！从小疼你抱你喂你宠你，把你这白眼狼养活成人，如今你娘一身病，请大夫吃药没钱，你一个子儿不给，弄个小妖精藏到这儿享福来，你娘快死啦！你享福？我就叫你享福享福享福！小二、小三！站着干嘛！把屋里东西全给我弄回家去！要敢偏向你们大哥，我就砸折你俩的腿！”\r\n\r\n　　那两个小子七手八脚，把屋里的箱子包袱、被褥衣服抱出来，往车上堆。邻居们跑出来围观。听这老头子一通骂，才知道那新婚小两口的来历。这种连快死的老娘都不管的白眼狼，自然没人出来管。再说那老头子怒火正旺，人像过年放的火炮，一个劲儿往上蹿，谁拦他，他准和谁玩命！\r\n\r\n　　东西搬得差不多，那两个小子说：“爹，大家伙抬不动，怎么办？”\r\n\r\n　　老头子一声惊雷落地：“砸！”\r\n\r\n　　跟手一通乱响，最后玻璃杯子打屋里也扔了出来，这才罢手。老头子依旧怒气难消，吼一句：“明儿见面再说！”便扬长而去。\r\n\r\n　　门儿大敞开没人管，晾了一整天。邻居们远远站着，没人上前，可谁也没离开。等着那小两口回来有戏看。\r\n\r\n　　下晌，新婚的小两口打西边有说有笑地回来。到家门口一看，懵了。过去问邻居，一直站在那里的邻居反而纷纷散开。有位大爷出来说话，显然他对这不尽孝心的年轻人不满，朝新郎说道：\r\n\r\n　　“早上，你爹和你兄弟们来了，是他们干的。你回你爹妈那儿去看看吧！”\r\n\r\n　　新郎一听，更懵。忽然禁不住大声叫道：“我哪还有爹呀！我三岁时爹就死了，我娘大前年也死了。只一个姐姐嫁到关外去，哪来的兄弟？”\r\n\r\n　　“嘛？”大爷一惊。可早上的事真真切切，一时脑筋没转过来，还是说，“那明明是你爹呀！”\r\n\r\n　　小两口赶紧去局子报案。但案子往下足足查了十年，也没找到他们那个“爹”。\r\n\r\n　　天津卫的盗案千奇百怪，这一桩却数第一。偷盗的居然做了人家的“爹”；被盗的损失财物不说，反当了“儿子”，而且还叫人哑巴吃黄连——有苦说不出来。若是忍不住跟人说了，招不来同情，反叫人取笑，更倒霉。看这，多损，多辣，多绝——多邪！', '2017-08-05 09:52:16', 'WuGN', ''),
(20, '小达子', '冯骥才', NULL, '　　其貌儿不扬，短脖短腿，灰眼灰皮，软绵绵赛块烤山芋；站着赛个影子，走路赛一道烟儿，人说这种人天生是当贼的材料。没错！小达子眼刁手疾，就是你把票子贴在肚皮上，转眼也会到他手里，还保管叫你不知不觉，连肚皮贴票子的感觉也没变。可他最看家的本事，是在电车上。你在车上要是遇到他，千万别往他身上靠，否则你身上有什么，就一准没什么。\r\n\r\n　　举个例子说，比方那种穿西服的小子，要是上了电车，保他没跑！因为那种小子好时髦，钱包都掖在西服裤子的屁股后边口袋里，口袋没盖，上边露着钱包窄窄一道边儿。可要想伸手把钱包抻出来，也是妄想。口袋小，钱包鼓，紧绷绷，屁股上的神经不比脸皮的神经差，一动就察觉，小达子却自有招儿。逢到此时，他往车门边的柱了一倚，等车一停，那小子下车的一刹那，他手比电光还快，刷地过去，用食指和中指的指尖夹住钱包的边儿。下车时人的重心和注意力都向下，于是口袋的钱包不用去抻，它自个儿就舒舒服服不知不觉出来了。\r\n\r\n　　话说到这儿，别以为这电车上的天下就是小达子的。\r\n\r\n　　一天，小达子在车上，打白帽衙门那站上来一位中年男子，黑礼服呢的褂子外边亮晶晶晃荡着一条纯金的怀表链，还挺粗。小达子呆着没动，等车快到梨栈时，他靠上去。这儿的车轨有一截S型。车到这里，必得一晃，他借势往那人身上一靠，表就到他手里，跟手揣入怀中。动作快得连眼珠子也跟不上。等车到梨栈，下车人多，他便挤在人群中，快快下车离开了现场。\r\n\r\n　　他一边走，一边美滋滋琢磨着今天的收获。忽然间发现走在前边的一个人，很像刚才车上那个中年男子。他正犹疑的当口，那人转过身来，果真就是那人；奇怪的是，那人胸口地方亮闪闪，依然晃着那条又粗又亮的表链！难道他还有一块表？小达子不自觉用手一摸自己怀中，吓了一跳，竟然空空如也。他半辈子偷别人，头一遭尝到挨偷后的感觉。更栽跟斗似的，他怎么也琢磨不出这家伙用什么法儿从他身上把表取回去。这人见他发傻的样子，龇牙一笑，笑里分明带着几分轻贱他的意味，好似说：“你笨手笨脚也想干这个！”然后收起笑来，转身而去。\r\n\r\n　　打这天，小达子不再上电车。', '2017-08-05 09:53:26', 'WuGN', ''),
(21, '蔡二少爷', '冯骥才', NULL, '    蔡家二少爷的能耐特别——卖家产。\r\n\r\n    蔡家的家产有多大？多厚？没人能说清。反正人家是天津出名的富豪，折腾盐发的家，有钱做官，几代人还全好古玩。庚子事变时，老爷子和太太逃难死在外边。大少爷一直在上海做生意，有家有业。家里的东西就全落在二少爷身上。二少爷没能耐，就卖着吃，打小白脸吃到满脸胡 茬，居然还没有“坐吃山空”。人说，蔡家的家产够吃三辈子。\r\n\r\n    敬古斋的黄老板每听这句话，就心里暗笑。他多少年卖蔡家的东西。名人家的东西较比一般人的东西好卖。而黄老板凭他的眼力，看得出二少爷上边几代人都是地道的玩主。不单没假，而且一码是硬梆梆的好东西，到手就能出手。蔡家卖的东西一多半经他的手。所以他知道蔡家的水有多深。十五年前打蔡家出来的东西是珠宝玉器，字画珍玩；十年前成了瓷缸石佛，硬木家具；五年前全是一包皮一包皮的旧衣服了。东西虽然不错，却渐渐显出河干见底的样子。这黄老板对蔡二少爷的态度也就一点点地变化。十五年前，他买二少爷的东西，全都是亲自去蔡家府上；十年前，二少爷有东西卖，派人叫他，他一忙就把事扔在脖子后边；五年前，已经变成二少爷胳肢窝里夹着一包皮旧衣服，自个儿跑到敬古斋来。\r\n\r\n    这时候，黄老板耷拉着眼皮说：“二少爷，麻烦您把包皮儿打开吧！”连伙计们也不上来帮把手。黄老板拿个尺子，把包皮里的衣服一件件挑出来，往旁边一甩，同时嘴里叫个价钱，好赛估衣街上卖布头的。最后结账时，全是伙计的事，黄老板人到后边喝茶抽烟去了。黄老板自以为摸透了蔡家的命脉。可近两年这脉相可有点古怪了。\r\n\r\n    蔡家二少爷忽然不卖旧衣，反过来又隔三差五派人叫他到蔡家去。海阔天空地先胡 扯半天，扭身从后边柜里取出一件东西给他看。件件都是十分成色的古玩精品。不是康熙五彩的大碟子，就是一把沈石田细笔的扇子。二少爷把东西往桌上一撂那神气，好赛又回到十多年前。黄老板说：“真是瘦死的骆驼比马大，二少爷的箱底简直没有边啦！东西卖了快二十年，还是拿出一件是一件！”蔡二少爷笑笑，只淡淡说一句：“我总不能把祖宗留下来的全卖了，那不成败家子了吗？”可一谈价就难了，每件东西的要价比黄老板心里估计的卖价还高，这在古玩里叫做：脖梗价。就是逼着别人上吊。\r\n\r\n    像蔡家这种人家卖东西，有两种卖法：一是卖穷，一是卖富。所谓卖穷，就是人家急等着用钱，着急出手，碰上这种人，就赛撞上大运；所谓卖富，就是人家不缺钱花，能卖大价钱才卖。遇到这种人，死活没办法。蔡二少爷一直是卖穷，嘛时候改卖富了？\r\n\r\n    一天，北京琉璃厂大雅轩的毛老板来到敬古斋。这一京一津两家古玩店，平日常有往来，彼此换货，互找买主，熟得很。\r\n\r\n    毛老板进门就瞧见古玩架上有件东西很眼熟，走近一看，一个精致的紫檀架上，放着一叠八片羊脂玉板刻的《金刚经》，馆阁体的蝇头小字，讲究之极，还描了真金。他扭脸对黄老板说：“这东西您打哪来的？”脸上的表情满是疑惑。\r\n\r\n    黄老板说：“半个月前新进的，怎么？”\r\n\r\n    毛老板追问一句：“谁卖您的？”\r\n\r\n    黄老板眼珠一转。心想你们京城人真不懂规矩，古玩行里，对人家的买主或卖主都不能乱打听。他笑了笑，没搭茬。\r\n\r\n    毛老板觉出自己问话不当。改口说：“是不是你们天津的蔡二少爷匀给您的？这东西是打我手里买的。”\r\n\r\n    黄老板怔住。禁不住说：“他是卖主呀！怎么还买东西？”\r\n\r\n    毛老板接过话：“我一直以为他是买主，怎么还卖，要不我刚才问你。”\r\n\r\n    两人大眼对小眼，都发傻。\r\n\r\n    毛老板忽指着柜上的一个大明成化的青花瓶子说：“那瓶子也是我卖给他的！他多少钱给您的？我可是跟白扔一样让给他的。”\r\n\r\n    毛老板还蒙在鼓里，黄老板心里头已经真相大白。他不能叫毛老板全弄明白。待毛老板走后，他马上对伙计们说：“记住，蔡二少爷不能再打交 道了。这王八蛋卖东西卖出能耐来了，已经成精了！”\r\n\r\n    闲言碎语：干什么都能成“精”，今儿咱们选了这篇放在“财富频道”上，就是想让几位瞧瞧，活个心眼儿就是钱。虽说，故事里这主儿的手段有点儿黑，但那点子您还真得学着点，省得让人蒙。', '2017-08-05 10:13:10', 'WuGN', ''),
(22, '小杨月楼义结李金敖', '冯骥才', NULL, '    民国二十八年，龙王爷 闯进天津卫，大小楼房全赛站在水里。三层楼房水过腿，两层楼房水齐腰，小平房便都落得“没顶之灾”了。街上行船，窗户当门，买卖停业，车辆不通，小杨月楼和他的一班人马，被困在南市的庆云戏院。那时候，人都泡在水里，哪有心思看戏？这班子二十来号人便睡在戏台上。\r\n\r\n    龙王爷 赖在天津一连几个月，戏班照样人吃马喂，把钱使净，便将十多箱行头道具押在河北大街的“万成当”。等到水退了，火车通车，小杨月楼急着返回上海，凑钱买了车票，就没钱赎当了，急得他闹牙疼，腮帮子肿得老高。戏院一位热心肠的小伙计对他说：“您不如去求李金鏊帮忙，那人仗义，拿义气当命。凭您的名气，有求必应。”\r\n\r\n    李金鏊是天津卫出名的一位大锅伙，混混头儿。上刀山、下火海、跳油锅，绝不含糊，死千一个。虽然黑白道上，也讲规矩讲脸面讲义气，拔刀相助的事，李金鏊干过不少，小杨月楼却从来不沾这号人。可是今儿事情逼到这地步，不去也得去了。\r\n\r\n    他跟随这小伙计到了西头，过街穿巷，抬眼一瞧，怔住了。篱笆墙，栅栏门，几间爬爬屋，大名鼎鼎的李金鏊就住在这破瓦寒窑里？小伙计却截门一声呼：“李二爷！”\r\n\r\n    应声打屋里猫腰走出一个人来，出屋直起身，吓了小杨月楼一跳。这人足有六尺高，肩膀赛门宽，老脸老皮，胡 子拉碴；那件灰布大褂，足够改成个大床 单，上边还油了几块。小杨月楼以为找错了人家，没想到这人说话嘴上赛扣个罐子，瓮声瓮气问道：“找我干吗？”口气挺硬，眼神极横，错不了，李金鏊！\r\n\r\n    进了屋，屋里赛破庙，地上是土，条案上也是土，东西全是东倒西歪；迎面那八仙桌子，四条腿缺了一条，拿砖顶上；桌上的茶壶，破嘴缺把，磕底裂肚，盖上没疙瘩。小杨月楼心想，李金鏊是真穷还是装穷？若是真穷，拿嘛帮助自己？于是心里不抱什么希望了。\r\n\r\n    李金鏊打量来客，一身春绸裤褂，白丝袜 子，黑礼服呢！鞋，头戴一顶细辫巴拿马草帽，手拿一柄有字有画的斑竹折扇。他瞄着小杨月楼说：“我在哪儿见过你？”眼神还挺横，不赛对客人，赛对仇人。\r\n\r\n    戏院小伙计忙做一番介绍，表明来意。李金鏊立即起身，拱拱手说：“我眼拙，杨老板可别在意。您到天津卫来唱戏，是咱天津有耳朵人的福气！哪能叫您受治、委屈！您明儿晌后就去‘万成当’拉东西去吧！”说得真爽快，好赛天津卫是他家的。这更叫小杨月楼满腹狐疑，以为到这儿来做戏玩。\r\n\r\n    转天一早，李金鏊来到河北大街上的“万成当”，进门朝着高高的柜台仰头叫道：“告你们老板去，说我李金鏊拜访他来了！”这一句，不单把柜上的伙计吓跑了，也把来典当的主顾吓跑了。老板慌张出来，请李金鏊到楼上喝茶，李金鏊理也不理，只说：“我朋友杨老板有几个戏箱押在你这里，没钱赎当，你先叫他搬走，交 情记着，咱们往后再说。”说完拨头便走。\r\n\r\n    当日晌后，小杨月楼带着几个人碰运气赛的来到“万成当”，进门却见自己的十几个戏箱——大衣箱、二衣箱、三衣箱、盔头箱、旗把箱等等，早已摆在柜台外边。小杨月楼大喜过望，竟然叫好喊出声来。这样便取了戏箱，高高兴兴返回上海。\r\n\r\n    小杨月楼走后，天津卫的锅伙们听说这件事，佩服李金鏊的义气，纷纷来到“万成当”，要把小杨月楼欠下的赎当钱补上。老板不肯收，锅伙们把钱截着柜台扔进去就走。多少亦不论，反正多得多。这事又传到李金鏊耳朵里。李金鏊在北大关的天庆馆摆了几桌，将这些代自己还情的弟兄们着实宴请一顿。\r\n\r\n    谁想到小杨月楼回到上海，不出三个月，寄张银票到天津“万成当”，补还那笔欠款，“万成当”收过锅伙们的钱，哪敢再收双份，老板亲自捧着钱给李金鏊送来了。李金鏊嘛人？不单分文不取，看也没看，叫人把这笔钱分别还给那帮代他付钱的弟兄。至此，钱上边的事清楚了，谁也不欠谁的了。这事本该了结，可是情没结，怎么结？\r\n\r\n    转年冬天，上海奇冷，黄浦江 冰冻三尺，大河盖上盖儿。甭说海上的船开不进江 来，江 里的船晚走两天便给冻得死死的，比抛锚还稳当。这就断了码头上脚伕们的生路，尤其打天津去扛活的弟兄们，肚子里的东西一天比一天少，快只剩下凉气了。恰巧李金鏊到上海办事，见这情景，正愁没辙，抬眼瞅见小杨月楼主演《芸娘》的海报，拔腿便去找小杨月楼。\r\n\r\n    赶到大舞台时，小杨月楼正是闭幕卸装时候，听说天津的李金鏊在大门外等候，脸上带着油彩就跑出来。只见台阶下大雪里站着一条高高汉子。他口呼：“二哥！”三步并两步跑下台阶。脚底板给冰雪一滑，一屁股坐在地上，仰脸对李金鏊还满是欢笑。\r\n\r\n    小杨月楼在锦江 饭店盛宴款待这位心中敬佩的津门恩人。李金鏊说：“杨老板，您喂得饱我一个脑袋，喂不饱我黄浦江 边的上千个扛活的弟兄。如今大河盖盖儿，弟兄们没饭辙，眼瞅着小命不长。”\r\n\r\n    小杨月楼慨然说：“我去想办法！”\r\n\r\n    李金鏊说：“那倒不用。您只要把上海所有名角约到一块儿，义演三天就成！戏票全给我，我叫弟兄们自个儿找主去卖。这么做难为您吗？”\r\n\r\n    小杨月楼说：“二哥真行，您叫我帮忙，又不叫我费劲。这点事还不好办吗？”第二天就把大上海所有名角，像赵君玉、周信芳、黄玉麟、刘筱衡、王芸芳、刘斌昆、高百岁等等，全都约齐，在黄金戏院举行义演。戏票由天津这帮弟兄拿到平日扛活的主家那里去卖。这些主家花钱买几张票，又看戏，又帮忙，落人情，过戏瘾，谁不肯？何况这么多名角同台献技，还是《龙凤呈祥》、《红鬃烈马》一些热闹好看的大戏，更是千载难逢。一连三天过去，便把冻成冰棍的上千个弟兄全救活了。\r\n\r\n    李金鏊完事要回天津，临行前，小杨月楼又是设宴送行。酒足饭饱时，小杨月楼叫人拿出一大包皮银子，外头拿红纸包皮得四四方方，送给李金鏊。既是盘缠，也有对去年那事谢恩之意。李金鏊一见钱，面孔马上板起来，沉下来的嗓门更显得瓮声瓮气。他说道：“杨老板，我这人，向例只交 朋友，不交 钱。想想看，您我这段交 情，有来有往，打谁手里过过钱？谁又看见过钱？折腾来折腾去，不都是那些情义吗？钱再多也经不住花，可咱们的交 情使不完！”说完起身告辞。\r\n\r\n    小杨月楼叫李金鏊这一席话说得又热又辣，五体流畅。第二天唱《花木兰》，分外的精气神足，嗓门冒光，整场都是满堂彩。', '2017-08-05 10:15:41', 'WuGN', ''),
(23, '张大力', '冯骥才', NULL, '    张大力，原名叫张金璧，津门一员赳赳武夫，身强力蛮，力大没边，故称大力。津门的老少爷们喜欢他，佩服他，夸他。但天津人有自己夸人的方法。张大力就有这么一件事，当时无人不晓，现在没人知道，因此写在下边——\r\n\r\n    侯家后一家卖石材的店铺，叫聚合成。大门口放一把死沉死沉的青石大锁，锁把也是石头的。锁上刻着一行字：\r\n\r\n    凡举起此锁者赏银百两\r\n\r\n    聚合成设这石锁，无非为了证明它的石料都是坚实耐用的好料。\r\n\r\n    可是，打石锁撂在这儿，没人举起过，甚至没人能叫它稍稍动一动，您说它有多重？好赛它跟地壳连着，除非把地面也举到头上去！\r\n\r\n    一天，张大力来到侯家后，看见这把锁，也看见上边的字，便俯下身子，使手问一问，轻轻一撼，竟然摇动起来，而且赛摇一个竹篮子，这就招了许多人围上来看。只见他手握锁把，腰一挺劲，大石锁被他轻易地举到空中。胳膊笔直不弯，脸上笑容满面，好赛举着一大把花儿！\r\n\r\n    众人叫好呼好喊好，张大力举着石锁，也不撂下来，直等着聚合成的伙计老板全出来，看清楚了，才将石锁放回原地。老板上来笑嘻嘻说：\r\n\r\n    “原来张老师来了，快请到里头坐坐，喝杯茶！”\r\n\r\n    张大力听了，正色道：“老板，您别跟我弄这套您的石锁上写着嘛，谁举起它，赏银百两，您就快把钱拿来，我还忙着哪！”\r\n\r\n    谁料聚合成的老板并不理会张大力的话。待张大力说完，他不紧不慢地说道：“张老师，您只瞧见石锁上边的字了，可石锁底下还有一行字，您瞧见了吗？”\r\n\r\n    张大力怔了。刚才只顾高兴，根本没瞧见锁下边还有字。不单他没瞧见，旁人也都没瞧见。张大力脑筋一转，心想别是老板唬他，不想给钱，以为他使过一次劲，二次再举不起来了，于是上去一把又将石锁高高举到头顶上，可抬眼一看，石锁下边还真有一行字，竟然写着：\r\n\r\n    惟张大力举起来不算\r\n\r\n    把这石锁上边和下边的字连起来，就是：\r\n\r\n    凡举起此锁赏银百两，惟张大力举起来不算！\r\n\r\n    众人见了，都笑起来。原来人家早知道惟有他能举起这家伙。而这行字也是人家佩服自己、夸赞自己——张大力当然明白。\r\n\r\n    他扔了石锁，哈哈大笑，扬长而去。', '2017-08-05 10:21:27', 'WuGN', ''),
(24, '死鸟', '冯骥才', NULL, '    天津卫的人好戏谑，故而人多有外号。有人的外号当面叫，有人的外号只能背后说，这要看外号是怎么来的。凡有外号，必有一个好笑的故事；但故事和故事不同，有的故事可以随便当笑话说，有的故事人却不能乱讲；比方贺道台这个各色的雅号——死鸟。\r\n\r\n    贺道台相貌普通，赛个猪崽。但真人不露相，能耐暗中藏。他的能耐有两样，一是伺候头儿，一是伺候鸟。\r\n\r\n    伺候上司的事是挺特别的一功。整天跟在上司的屁股后边，跟慢跟紧全都不成。跟得太慢，遇事上不去，叫上司着急；跟得太紧，弄不好一脚踩在上司的后脚跟上，反而惹恼了上司。而且光是赛条小狗那样跟在后边也不成。还得善于察言观色，摸透上司脾气，知道嘛时候该说嘛，嘛时候不该说嘛；挨训时俯首贴耳，挨骂时点头称是。上司骂人，不准是你的不是，有时不过是上司发发威和舒舒气罢了。你要是耐不住性子，皱眉撇嘴，露出烦恼，那就叫上司记住了。从此，官儿不是愈做愈大，而是愈做愈小———就这种不是人干的事，贺道台却得心应手，做得从容自然。人说，贺道台这些能耐都出自他的天性，说他天生是上司的撒气篓子，一条顺毛驴，三脚踹不出个屁来，对么？\r\n\r\n    说完他伺候头儿，再说他伺候鸟儿。\r\n\r\n    伺候鸟的事也是另外一功。别以为把鸟关在笼子里，放点米，给点虫，再加点水，就能又蹦又跳。一种鸟有一种鸟的习惯，差一点就闭眼戗毛，耷拉翅膀；一只鸟有一只鸟的性子，不依着它就不唱不叫，动也不动，活的赛死的差不多。人说贺道台上辈子准是鸟儿。他对鸟儿们的事全懂，无论嘛鸟，经他那双小胖手一摆弄，毛儿鲜亮，活蹦乱跳，嗓子个个赛得过在天福茶园里那个唱落子的一毛旦。\r\n\r\n    过年立夏转天，在常关做事的一位林先生，打江 苏常州老家歇假回来，带给他一只八哥。这八哥个大肚圆，腿粗爪硬，通身乌黑，嘴儿金黄；叫起来，站在大街上也听得清清楚楚。贺道台心里欢喜说：“公鸡的嗓门也没它大。”\r\n\r\n    林先生笑道：“就是学人说话还差点。它总不好好学。怎么教也不会，可有时不留神的话，却给他学去了。不过，到您手里一调理，保准有出息。”\r\n\r\n    贺道台也笑了。说道：“过三个月，我叫它能说快板书。”\r\n\r\n    然而，这八哥好比烈马，一时极难驯服。贺道台用尽法子，它也学不会。贺道台骂它一句：“笨鸟。”第二天它却叫了一天“笨鸟”。叫它停嘴，它偏不停。前院后院都听得清清楚楚，午觉也没法儿睡。贺道台用罩子把笼子严严实实罩了多半天，它才不叫。到了傍晚，太太怕把它闷死，叫丫鬟把罩子摘去，它一露面，竟对太太说：“太太起痱子了吧？”把太太吓了一跳。再一想，这不是前几天老爷对她说的话吗，不留神竟给它学去了。逗得太太格格笑半天。待贺道台回来，对老爷说了。没等她去叫八哥再说一遍，八哥自己又说：“太太起痱子了吧！”\r\n\r\n    贺道台给逗得咧嘴直笑，还说：“这东西，连声音也学我。”\r\n\r\n    太太说：“没想到这坏东西竟这么聪明。”\r\n\r\n    自此，贺道台分外仔细照料它。日子一长，它倒是学会了几句什么“给大人请安”、“请您坐上座”、“您走好了”之类的话，只是不好好说。可是，它抽冷子蹦出几句老爷太太平时说的“起痱子”那类的话，反倒把客人逗得大笑，直笑得前仰后合。\r\n\r\n    知府大人说：“贺大人，从它身上就知道您有多聪明了。”\r\n\r\n    贺道台得意这鸟，更得意自己。这话就暂且按下不提。\r\n\r\n    九月初九那天，东城外的玉皇阁“攒九”，津门百姓照例都去登阁，俗称九九登高。此时，天高气爽，登高一望，心头舒畅，块垒皆无。这天直隶总督裕禄也来到了玉皇阁，兴致非常好，顺着那又窄又陡的楼梯，一口气直爬到顶上的清虚阁。随同来的文武官员全都跑前跑后，哄他高兴。贺道台自然也在其中。他指着三岔河口上的往来帆影，说些提兴致的话，直叫裕禄大人心头赛开了花。从阁上下来，贺道台便说，自己的家就在不远，希望大人赏脸，到他家去坐坐。裕大人平日决不肯屈尊到属下家中作客。但今日兴致高，竟答应了。贺道台的轿子便在前面开道，其余官员跟随左右，骑龙驾虎一般去了。\r\n\r\n    贺道台的八哥笼子就挂在客厅窗前，裕大人一进门，它就叫：“给大人请安。”声音嘹亮，一直送进裕禄的耳朵里。\r\n\r\n    裕大人愈发兴高采烈，说道：“这东西竟然比人还灵。”\r\n\r\n    贺道台应声便说：“还不是因为大人来了。平时怎么叫它说，它也不肯说。”\r\n\r\n    待端茶上来，八哥忽又叫道：“这茶是明前茶。”\r\n\r\n    裕大人一怔，扭头对那笼子里的八哥说：“这是你的错了。现在什么时候了，哪还有明前茶？”\r\n\r\n    上司打趣，下司拾笑。笑声贯满客厅，并一齐讪笑八哥是个傻瓜。\r\n\r\n    贺道台说：“大人真是一句切中了要害。其实这话并不是我教的，这东西总是时不时蹦出来一句，不知哪来的话。”\r\n\r\n    知府笑道：“还不是平日里说者无意，听者有心。想必贺大人总喝好茶，它把茶名全记住了！”\r\n\r\n    裕禄笑道：“有什么好茶，也请裕禄我尝尝。”\r\n\r\n    大家又笑起来。但八哥听到了“裕禄”两字，忽然翅膀一抖，跟着全身黑毛全日方起来，好赛发怒，声音又高又亮地叫道：“裕禄那王八蛋！”\r\n\r\n    满厅的人全怔往。其实这一句众人全听到了，就在惊呆的一刻，这八哥又说一遍：“裕禄那王八蛋！”说得又清楚又干脆。裕禄忽地手一甩，把桌上的茶碗全抽在地上，怒喝一声：“太放肆了！”\r\n\r\n    贺道台慌忙趴在地上，声音抖得快听不见：“这不是我教给它的———”话到这里，不觉卡住了。他想到，八哥的这句话，正是他每每在裕禄那里受了窝囊气后回来说的。怎么偏偏给它记住了？这不是要他的命吗？他浑身全是凉气。\r\n\r\n    等他明白过来，裕禄和众官员已经离去。只他一个人还趴在客厅地上，他突然跳起来，朝那八哥冲去，一边吼着：“你毁了我！我撕了你，你这死鸟！”\r\n\r\n    他两手抓着笼子一扯，用力太大，笼子扯散，鸟飞出来，一把没有抓住。这八哥穿窗飞出，落在树上。居然把贺道台刚刚说的这话学会了，朝他叫道：“死鸟！”\r\n\r\n    贺道台叫仆人们用杆子打，用砖头砍，爬上树抓，八哥在树顶上来回蹦了一会儿，还不住地叫：“死鸟！死鸟！死鸟！”最后才挥翅飞去，很快就无影无踪了。\r\n\r\n    自此，贺道台就得了“死鸟”的外号。而且人们传这外号的时候，还总附带着这个故事。', '2017-08-05 10:29:53', 'WuGN', ''),
(25, '背头杨', '冯骥才', NULL, '    光绪庚子后，社会维新，人心思变，光怪陆离，无奇不有，大直沽冒出一个奇人，人称背头杨。当时，男人的辫子剪得太急，而且头发受之父母，不肯剪去太多，剪完后又没有新发型接着，于是就剩下一头长长的散发，赛玉米穗子背在后脑壳上，俗称马子盖，大名叫背头。背头便成了维新的男人们流行的发式了。\r\n\r\n    既然如此，这个留背头姓杨的还有嘛新鲜的？您问得好，我告您——这人是女的！\r\n\r\n    大直沽有个姓杨的大户。两个没出门的闺女。杨大小姐，斯文好静，整天呆在家；杨二小姐，激进好动，终日外边跑，模样和性情都跟小子们一样，而且好时髦，外边流行什么，她就立即弄到自己身上来。她头次听到革命二字，马上就铰了头发，仿照维新的男人们留个背头，这在当时可是个大新闻。可她不管家里怎么闹，外头怎么说，我行我素，快意得很。\r\n\r\n    但没出十天，麻烦就来了——\r\n\r\n    这天榜晚，背头杨打老龙头的西学堂听完时事演讲回家，下边憋了一泡尿。她急着往家赶，愈急愈憋不住。简直赛江 河翻浪，要决口子。她见道边有间茅厕，便一头钻进去。\r\n\r\n    天下的茅厕都是一边男一边女，中间隔道墙，左男右女。她正解裤带的当口，只听蹲着的一个女的大声尖叫：“流氓 ，流氓 ！”跟着，另一个也叫起来，声音更大，她给这一叫弄懵了。闹不清流氓 在哪儿，提着裤子跑出去，谁料里边的几个女的跟着跑出来，喊打叫骂，认准她是个到女厕所占便宜的坏小子。过路的人上来把她截住，一拥而上，连踢带打。背头杨叫着：“别打，别打，我是女的！”谁料招致更凶猛的殴打：“打就打你这冒牌的‘女的’！”直到巡警来，认出这是杨家的二小姐，才把她救出来送回家。背头杨给打得一身包皮，脸上挂了彩，见了爹娘，又哭又闹，一连多少天，那就不去说了。\r\n\r\n    打这儿，背头杨在外边再不敢进茅厕。憋急了就是尿在裤兜里，也不去茅厕。她不能进男厕，更不能进女厕。一时间，连自己是男是女也弄不清了。\r\n\r\n    她不去找事，可是事来找她。\r\n\r\n    她听说，大直沽一带的女厕所接连出事。据说总有个留背头的男子闯进去，进门就说：“我是背头杨。”唬住对方，占些便宜后扭身就跑。虽然没出大事，却闹得人心惶惶。还有些地面上的小混混也趁火打劫，在女厕所的墙外时不时叫一嗓子：“背头杨来了！”叫这一带的女厕所都赛闹鬼的房子，没人敢进去。\r\n\r\n    背头杨真弄不明白，维新怎么会招来这么多麻烦，不过留一个背头，连厕所也进不得。而且是进厕所不行，不进厕所也不行。不知是她把事情扰乱，还是事情把她扰乱。一赌气，她在屋里呆了两个月。慢慢头发长了，恢复了女相，哎，这一来女厕所自然就随便进了，而且女厕所也肃静起来，好似天底下的麻烦全没了。', '2017-08-05 10:31:06', 'WuGN', '');
INSERT INTO `wu_blog` (`id`, `post_title`, `post_author`, `post_type`, `post_content`, `post_date`, `post_from`, `post_link`) VALUES
(26, '青云楼主', '冯骥才', NULL, '    青云楼主，海河边一小文人的号。嘛叫小文人？就是在人们嘴边绝对挂不上号，可提起他来差不多还都知道的那类文人。\r\n\r\n    此君脸窄身簿，皮黄肉干，胳膊大腿又细又长，远瞧赛几根竹竿子上凉着的一张豆皮。但人不可貌相，海不可斗量。他能写能画，能刻图章，连托裱的事也行；可行家们说他——手糙了点儿。因故，天津卫的买卖没他写的匾，饭庄药铺的墙上不挂他的画。他于书画这行，是又在行里，又在行外。文人落到这步，那股子“怀才不遇”的滋味，是苦是酸，还是又苦又酸，只有他自己知道了。\r\n\r\n    于是，青云楼这斋号就叫他想出来了。他自号青云楼主，还写了一副对子挂在迎面墙壁上：“人在青山里，心卧白云中”。他常常自言自语念这对子。每每念罢，闭目摇肩，真如隐士。然而，天津卫是个凡夫俗子的花花世界，青云楼就在大胡 同东口，买东西的和卖东西的挤成个团 儿。再说他隔墙就是四季春大酒楼，整天鱼味肉味葱味酱味换着样儿往窗户里边飘。关上窗户？那管屁用窗玻璃拦得住鱼鲜肉香，却拦不住灯红酒绿。一位邻居对他说：“你这青云楼干脆也改成饭馆算了。这青云楼三字听着还挺好听，一叫准响！”\r\n\r\n    这话当时差点叫他死过去。\r\n\r\n    乾旋地转，运气有变。一天，有个好事的小子陈八，带来一位美国人拜访他。这人五十多岁，秃头鼓眼大胡 子，胡 子里头瞧不见嘴。陈八说这老美喜欢中国的老东西，尤其是字画。青云楼主头一回与洋人会面，脑子发乱，手脚也忙，踩凳子挂画时，差点来个人仰马翻。那老美并没注意到他，只管去瞧墙上的画，每瞧一幅，就哇啦哇啦叫一嗓子，好赛洗屁股时叫水烫着了。然后，嘬起嘴啧啧赞赏一翻。这一嘬嘴，就见有一个樱桃样的东西，又湿又红，从他的胡 子中间拱出来。青云楼主定神一看，原是这老美的嘴唇。最后他用中文一个字一个字对青云楼主说：“我、太、高、兴、了、谢、谢——我、太、高、兴、了、谢、谢——”他大概只学了这几个字，反反复复地说，一直告辞而去。\r\n\r\n    青云楼主高兴得要疯。他这辈子，头次叫人这么崇拜。两个月后，他收到一封洋文写的信。他拿到《大公报》的报馆去找懂洋文的朱先生。朱先生一看就笑了，对他说：“你用嘛法子，把人家老美都折腾出神经病来了他说他回国后天天眼睛里都是你写的字，晚上做梦也是你的字，还说他感到中国的艺术家绝对都是天才！”\r\n\r\n    青云楼主如上青云，身子发飘，一夜 没睡，天亮时，忽来灵感，挥笔给那老美写了“宁静致远”四个大字，亲手裱成横披，送到邮局寄去。邮件里还附一张信纸，提个要求，要人家把字挂在墙上后，无论如何站在这字前面，照张照片寄来。他想，他要拿这照片给人看。给亲友看，给街坊邻居看，给那些小看他的人看，再给买卖家那几个大老板看，给报馆的编辑们看，最后在报上刊登出来。都看吧！瞪圆你们的狗眼看看吧！你们不认我，人家老美认我！\r\n\r\n    他在青云楼中坐等三个月，直等到有点疑惑甚至有点泄气时，一封外皮上写着洋文的信终于寄来了。他忙撕开，抻出一封信，全是洋文，他不懂，里边并没照片。再看信封，照片竟卡在里边，他捏住照片抻出来一瞧，有点别扭，不大对劲，他再细瞧，竟傻了。那老美倒是站在他那字的前边照了像，可是字儿却挂倒了，全朝下了！', '2017-08-05 10:32:22', 'WuGN', ''),
(27, '冯五爷', '冯骥才', NULL, '    冯五爷是浙江 宁波人。冯家出两种人，一经商，一念书。冯家人聪明，脑袋瓜赛粤人翁伍章雕刻的象牙球，一层套一层，每层一花样。所以冯家人经商的成巨富，念书的当文豪做大官。冯五爷这一辈五男二女，他排行末尾。几位兄长远在上海天津开厂经商，早早的成家立业，站住脚跟。惟独冯五爷在家啃书本。他人长得赛条江 鲫，骨细如鱼刺，肉嫩如鱼肚，不是赚钱发财的长相，倒是舞文弄墨的材料。凡他念过的书，你读上句，他背下句，这能耐据说只有宋朝的王安石才有。至于他出口成章，落笔生花，无人不服。都说这一辈冯家的出息都在这五爷身上了。\r\n\r\n    冯五爷二十五，父母入土，他卖房地、携家带口来到天津卫，为的是投兄靠友，谋一条通天路。\r\n\r\n    他心气高，可天津卫是商埠，毛笔是用来记帐的，没人看书，自然也没人瞧得起念书的。比方说，地上有黄金也有书本，您捡哪样？别人发财，冯五爷眼热，脑筋一歪，决意下海做买卖。但此道他一窍不通，干哪行呢？\r\n\r\n    中国人想赚钱，第一个念头便是开饭馆。民以食为天，民为食花钱；一天三顿饭，不吃腿就软，钱都给了饭馆老板。天津的钱又都在商人手里，商界的往来大半在饭桌上。再说，天津产盐，吃菜口重，宁波菜咸，正合口味。于冯五爷拿定主意，开个宁波风味的馆子，便在马家口的闹市里，选址盖房，取名“状元楼”。择个吉日，升匾挂彩，燃鞭放炮，饭馆开张了。冯五爷身穿藏蓝暗花大褂，胸前晃着一条纯金表链，中印分头，满头抹油，地道的老板打扮，站在大厅迎宾迎客，应付八方。念书的人，讲究礼节，谈吐又好，很得人缘。再说，状元楼是天津卫独一家宁波馆，海鱼河虾都是天津人解馋的食品，在宁波厨子手里一做，比活鱼活虾还鲜。故此开张以来，天天坐满堂，晚上一顿还得“翻台”，上一长，赚钱并不多。冯五爷纳闷，天天一把把银钱，赛一群群鸟飞进来，都落到哪儿去了？往后再瞧帐，哟，反倒出了赤字！\r\n\r\n    一日，一个打宁波帮工来的小伙计，抖着胆子告诉他，厨房里的鸡鸭鱼肉，进到客人嘴里的有限，大多给厨子伙计们截墙扔出去，外边有人接应。状元楼有多少钱经得住天天往外扔？\r\n\r\n    冯五爷盛怒之后，心想自己嘛脑袋，《二十四史》背得滚瓜烂熟，能拿这帮端盘子炒菜的没辙？这就开刀了。除去那个打宁波老家带来的胖厨子没动，其余伙计全轰走，斩草除根换一拨人，还在后院墙头安装电网，以为从此相安无事，可帐上仍是赤字，怎么回事？\r\n\r\n    又一日，住在状元楼邻近一位婆子，咬耳朵对他说，每天后晌，垃圾车一到，一摇铃铛，打状元楼里抬出的七八个土箱子，只有上边薄薄一层是垃圾，下边全是铁皮罐头、整袋咸鱼、好酒好烟。原来内外勾结，用这法儿把东西弄走。这不等于拿土箱子每天往外抬钱吗？冯五爷赶在一个后晌倒垃圾的时候，上前一查，果然如此。大怒之下，再换一拨人。人是换了，但帐本上的赤字还是没有换掉。\r\n\r\n    冯五爷不信自己无能。天天到馆子瞪大眼珠，内内外外巡视一番，却看不出半点毛病。文人靠想象过日子，真落到生活的万花筒里，便是“自作聪明真傻瓜”。状元楼就赛破皮球，撒气露风，眼瞅着败落下来。买卖赛人，靠一股气儿活着，气泄了，谁也没辙。愈少客人，客人愈少；油水没油，伙计散伙。饭厅有时只开半边灯了。\r\n\r\n    冯五爷心里只剩下一点不服。\r\n\r\n    再一日，身边使唤的小僮对他说，外头风传，状元楼里最大的偷儿不是别人，就是那个打老家带来的胖厨子。据说他偷瘾极大，无日不偷，无时不偷，无物不偷，每晚回家必偷一样东西走，而且偷术极高，绝对查看不出。冯五爷不肯相信，这胖厨子当年给自己父亲做饭，胖厨子的父亲给自己爷爷做饭，他家的根早扎在冯家了。倘若他是贼，谁还会不是贼？\r\n\r\n    但是，冯五爷究竟干了两年的买卖，看到的假笑比真笑多，听到的假话比真话多，心里也多了一个心眼儿了。当日晚上，状元楼该关灯闭门时候，冯五爷带着小僮到饭馆前厅，搬一把藤椅，撂在通风处，仰面一躺，说是歇凉，实是捉贼。\r\n\r\n    等了不久，胖厨子封上炉火，打后头厨房出来，正要回家。他光着脑袋一身肉，下边只穿一条大白裤衩，趿拉一双破布鞋，肩上搭一条汗巾，手提一盏纸灯笼。他瞅见老板，并不急着脱身离去，而是站着说话。那模样赛是说：“您就放开眼瞧吧！\r\n\r\n    冯五爷嘴里搭讪，一双文人的锐目利眼却上上下下打量他，心中一边揣度——这光头光身，往哪儿藏掖？破鞋里也塞不了一盒烟呵！灯笼通明雪亮，里头放点嘛也全能照出来。裤衩虽大，但给大厅里来回来去的风一吹，大腿屁股的轮廓都看得清清楚楚，还能有嘛？是不是搭在肩上那条擦汗的手巾里裹着点什么？心刚生疑，不等他说，胖厨子已把汗巾从肩上拿下，甩手扔给小僮，说道：“外边都凉了，我带这条大毛巾做什么，烦你给搭在后院的晾衣绳上吧！”说完辞过冯五爷，手提灯笼，大摇大摆走了。\r\n\r\n    冯五爷叫小僮打开毛巾，里头嘛也没有，差点冤枉好人。\r\n\r\n    可是转天，这小僮打听到，胖厨子昨晚使的花活，在那灯笼上。原来插洋蜡的灯座不是木头的，而是拿一块冻肉镟的，这块肉足有二斤沉！可人家居然就在冯五爷眼皮子底下，使灯照着，大模大样提走了，真叫绝了！\r\n\r\n    冯五爷听罢，三天没说话，第四天就把状元楼关了。有人劝他重返文苑，接着念书，他摇头叹息。念书得信书。他连念书的人能耐还是不念书的人能耐都弄不清，哪还会有念书的心思？', '2017-08-05 10:33:27', 'WuGN', ''),
(28, '有哪些看着像Ps过的照片,实际却没有?', 'ZhiHu', NULL, '他在雪后的湖边喂食，他完全不知道他在一张美到什么程度的照片里……\r\n\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/阴阳.png\" height=\"333\" /><br />\r\n\r\n《阴阳》\r\n\r\n拍摄者—— Marcin Ryczek\r\n\r\n2\r\n\r\n《四象》\r\n\r\n拍摄者——贝拉\r\n\r\n这是一张照片而不是四张，但是谁又会发现呢？\r\n\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/四象.jpg\" height=\"600\" /><br />\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/四象2.jpg\" height=\"370\" /><br />\r\n\r\n3\r\n\r\nXP系统的Bliss壁纸\r\n\r\n拍摄者——O’Rear\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/Bliss.jpg\" height=\"338\" /><br />\r\n\r\n那是一年初春，外面刚刚下过一场大雨，草地愈发的翠绿。\r\n\r\n我开着车驶过这片美丽的蜿蜒小道去见达芙妮，暴风雨刚过，天空飘着白云。\r\n\r\n我觉得是时候出来拍几张照片了。\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/Bliss2.jpg\" height=\"358\" /><br />\r\n\r\n4\r\n\r\nwin10壁纸————Hero \r\n\r\n拍摄者——Bradley G Munkowitz\r\n\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/Hero.jpg\" height=\"337\" /><br />\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/Hero2.jpg\" height=\"331\" /><br />\r\n\r\n一群像处女座一样苛刻的人拿着摄像机对着一扇窗子折腾了一整天，只为捕捉那一瞬间的光影。\r\n\r\n5\r\n\r\n安卓6.0Material Design风格的抽象壁纸\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/MaterialDesign.jpg\" height=\"412\" /><br />\r\n\r\n拍摄者——谷歌设计团队\r\n\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/MaterialDesign2.jpg\" height=\"412\" /><br />\r\n\r\n论二向箔在设计领域的具象化应用\r\n\r\n6\r\n\r\n《挤牙膏》\r\n\r\n拍摄者—— Steve Richards\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/挤牙膏.jpg\" height=\"858\" /><br />\r\n\r\n8\r\n\r\n《飞蛙在天》\r\n\r\n当火箭腾空的时候，剧烈的气流将一只青蛙带上了天空。\r\n\r\n月宫也许有人在等它，然而那棵桂树已经很久没有发芽。\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/飞蛙在天.jpg\" height=\"900\" /><br />\r\n\r\n9\r\n\r\n碰碰车上的金正日\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/碰碰车上的金正日.jpg\" height=\"492\" /><br />\r\n1977年10月2日，金正日在平壤一所游乐场视查，并亲自测试儿童碰碰车性能。\r\n\r\n10\r\n\r\n剪刀手的周总理\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/剪刀手的周总理.jpg\" height=\"600\" /><br />\r\n11\r\n\r\n吐舌头的爱因斯坦\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/吐舌头的爱因斯坦.jpg\" height=\"450\" /><br />\r\n\r\n1951年3月，爱因斯坦72岁。过完生日庆典后，疲惫的爱因斯坦僵硬的脸上已经维持不住微笑，为了应付一定要多拍几张的摄影师，爱因斯坦摆出了这个表情。\r\n\r\n12\r\n\r\n《黑白》\r\n\r\n拍摄者—— Loui Nydelius\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/黑白.jpg\" height=\"293\" /><br />\r\n\r\n黑与白的车流被道路犁出一道明显的分野，如泾渭分明又彼此交融。\r\n\r\n13\r\n\r\n《呐喊》\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/呐喊.jpg\" height=\"762\" /><br />\r\n\r\n如果世界都在扭曲，你需要做的事情也许只有一件——快快拍照发朋友圈。\r\n\r\n14\r\n\r\n《月之帆》\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/月之帆.jpg\" height=\"550\" /><br />\r\n渔船在白莲花般的海水里穿行，孤单的月亮是它高悬的船帆。\r\n\r\n15\r\n\r\n《灯弄影》\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/灯弄影.jpg\" height=\"570\" /><br />\r\n月照华灯下，人随疏影前。\r\n\r\n16\r\n\r\n《蝴蝶梦》\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/蝴蝶梦.jpg\" height=\"366\" /><br />\r\n若我不再能奔跑，请让我在梦中飞翔。\r\n\r\n17\r\n\r\n《赛飞》\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/赛飞.jpg\" height=\"365\" /><br />\r\n晴空一鹰排云上，九行战机落碧霄。\r\n\r\n18\r\n\r\n《黄昏》\r\n\r\n拍摄者——弗兰斯?兰丁\r\n<img class=\"lazy\" data-original=\"http://oourcagfr.bkt.clouddn.com/201708/黄昏.png\" height=\"357\" /><br />\r\n照片摄于非洲的一片沙漠，黄色天空实为远方的沙海，白色小点是白沙堆积成的沙丘。黄昏时，远方的沙漠仍旧在夕阳余晖照耀之下，而近处的地面和树则已经处于黑夜的阴影之中，由此成就了这张如梵高油画般的照片。\r\n', '2017-08-06 09:47:30', 'WuGN', ''),
(29, '我爱这土地', '艾青', NULL, '<strong>我爱这土地</strong>\r\n\r\n假如我是一只鸟，\r\n\r\n我也应该用嘶哑的喉咙歌唱：\r\n\r\n这被暴风雨所打击着的土地，\r\n\r\n这永远汹涌着我们的悲愤的河流，\r\n\r\n这无止息地吹刮着的激怒的风，\r\n\r\n和那来自林间的无比温柔的黎明……\r\n\r\n——然后我死了，\r\n\r\n连羽毛也腐烂在土地里面。\r\n\r\n为什么我的眼里常含泪水？\r\n\r\n因为我对这土地爱得深沉……\r\n\r\n<b>I Love This Land</b>\r\n\r\nIf I were a bird,\r\n\r\nI would sing with my hoarse voice：\r\n\r\nOf this land was buffeted by storms,\r\n\r\nOf this river turbulent with our grief,\r\n\r\nOf these angry winds ceaselessly blowing,\r\n\r\nAnd of the dawn, infinitely gentle over the woods...\r\n\r\n——Then I would die,\r\n\r\nAnd even my feathers would rot in the soil.\r\n\r\nWhy are my eyes always brimming with tears?\r\n\r\nBecause I love this land so deeply...', '2017-08-06 09:54:19', 'WuGN', ''),
(30, '五色漆和巧克力豆', '岑嵘', NULL, '    朋友在一家大型钢结构公司任职，公司承接一些国外大型工程。有一天，朋友抱怨说：“和老外做生意太难了，合同里经常出现匪夷所思的条款。比如有次我们在欧洲做一个项目，合同要求我们对某个结构用五种不同颜色的油漆，按照一定的顺序一道道刷上去。”\r\n    “为什么非要五种颜色？这样做完全没有必要，其实就是刁难人。”朋友愤愤的说。\r\n    也许他听完美国经济学家史蒂芬·列维特讲的关于M&M豆的故事，就不会再这么认为了。\r\n    20世纪80年代初期，范·海伦乐队是当时全球著名的摇滚乐团之一。乐队的巡演合同总是带有53页的附文，详细说明了技术、安保的每个细节， 还对食物和饮品的要求。\r\n    冗长附文的第40页里是他们对零食的要求，他们指定了薯片、坚果、蝴蝶酥和M&M巧克力豆，旁边还特别声明：绝对不要棕色的M&M豆。\r\n    当关于M&M豆的条款被泄露给媒体后，人们愤怒地认为这是摇滚乐团放纵无度、耍大牌的恶性。想到供餐公司可怜的工作人员一粒粒地挑选着M&M豆，人们就气不打一处来。但是多年之后，该乐团的主唱大卫·李·罗斯回忆说：“人们觉得我们为所欲为、肆意凌辱别人，但事实并非如此。”\r\n    原来，范·梅伦的演唱会现场总是盛大而华丽，庞大的舞台、震撼的音效、炫目的灯光，为达到这些效果，每个设备都要逐一构架调试。\r\n    罗斯说，大多数摇滚乐团的合同都足足有一本电话黄页这么厚，里面对每个细节都会逐个说明，以确保主办方在每个场地都能提供足够的空间，又有相应的承重能力和供电能力，乐团要确保没人会被倒塌的舞台和短路的灯柱夺去生命。\r\n    那么乐团每到一个新城市，是如何确定当地主办方真的读了附文做足了安全措施呢？\r\n    答案就在这些棕色的M&M豆里。罗斯到达场地后，就会立刻去后台检查那碗M&M豆，如果他看到了棕色的巧克力豆，就知道主办方没有认真阅读附文，那么他们就要认真检查，确保每个重要设备都安装妥当。\r\n    现在我们回到哪家钢结构公司要求的五种颜色油漆上来。\r\n    大型钢结构建筑的合同远比演唱会的合同复杂的多。同样的问题，客户怎样来确定承建方是尽职尽责对照合同完成了工程呢？找第三方监理公司也许是个办法，但是很多地方的质量是看不到的，只能“凭良心”。比如有的部件需要刷若干道油漆，但施工方到底刷了多少道，只有他们自己知道。\r\n    这时，五色油漆的作用和M&M豆的作用是一样的。对方很容易检查出，施工方在这个结构上是不是按顺序一道道上了漆。如果是，说明承建方细心阅读了合同的每一个细节，并且做事不偷工减料。\r\n    假如承建方没有按要求做，那么这个工程很可能存在隐患，每个地方都的细心检查。\r\n    因此，五色油漆和M&M豆的作用，用经济学的术语来说，就是起到了“分离均衡”的作用，把那些认真做事的人和那些马虎做事的人区分开来。\r\n    （惜 茹摘自《深圳商报》2016年11月2日）', '2017-08-14 02:17:38', 'WuGN', ''),
(31, 'TO BE OR NOT TO BE', 'William Shakespeare', NULL, 'To be, or not to be: that is the question.\nWhether it\'s nobler in the mind to suffer\nthe slings and arrows of outrageous fortune,\nor to take arms against a sea of troubles,\nand by opposing end them. To die,to sleep;\nNo more; And by a sleep to say we end\nthe heartache, and the thousand natural shocks\nthat flesh is heir to, it\'s a consummation\ndevoutly to be wished. To die, to sleep.\nTo sleep, perchance to dream: ay, there\'s the rub\nfor in that sleep of death what dreams may come\nwhen we have shuffled off this mortal coil,\nmust give us pause.\nThere\'s the respect that makes calamity of so long life\nfor who would bear the whips and scorns of time,\nthe oppressor\'s wrong, the proud man\'s contumely,\nthe pangs of despised love, the law\'s delay,\nthe insolence of office, and the spurns\nthat patient merit of the unworthy takes,\nwhen he himself might his quietus make\nwith a bare bodkin? Who would fardels bear\nto grunt and sweat under a weary life,\nbut that the dread of something after death,\nThe undiscovered country from whose bourn.\nNo traveller returns, puzzles the will,\nand makes us rather bear those ills we have\nthan fly to others that we know not of?\nThus conscience does make cowards of us all,\nand thus the native hue of resolution\nis sicklied o\'er with the pale cast of thought,\nand enterprises of great picth and moment\nwith this regard their currents turn awry\nand lose the name of action.', '2017-08-24 09:34:04', 'WuGN', ''),
(32, '生存还是毁灭', '英·莎士比亚', NULL, '生存或毁灭, 这是个问题:\r\n\r\n是否应默默的忍受坎坷命运之无情打击,\r\n\r\n还是应与深如大海之无涯苦难奋然为敌,\r\n\r\n并将其克服。\r\n\r\n此二抉择, 究竟是哪个较崇高?\r\n\r\n死即睡眠, 它不过如此!\r\n\r\n倘若一眠能了结心灵之苦楚与肉体之百患,\r\n\r\n那么, 此结局是可盼的!\r\n\r\n死去, 睡去...\r\n\r\n但在睡眠中可能有梦, 啊, 这就是个阻碍:\r\n\r\n当我们摆脱了此垂死之皮囊,\r\n\r\n在死之长眠中会有何梦来临?\r\n\r\n它令我们踌躇,\r\n\r\n使我们心甘情愿的承受长年之灾,\r\n\r\n否则谁肯容忍人间之百般折磨,\r\n\r\n如暴君之政、骄者之傲、失恋之痛、法章之慢、贪官之侮、或庸民之辱,\r\n\r\n假如他能简单的一刀了之?\r\n\r\n还有谁会肯去做牛做马, 终生疲於操劳,\r\n\r\n默默的忍受其苦其难, 而不远走高飞, 飘於渺茫之境,\r\n\r\n倘若他不是因恐惧身后之事而使他犹豫不前?\r\n\r\n此境乃无人知晓之邦, 自古无返者。', '2017-08-24 09:37:44', 'WuGN', ''),
(33, '二维码的生产原理', 'admin', NULL, '    二维条码是指在一维条码的基础上扩展出另一维具有可读性的条码，使用黑白矩形图案表示二进制数据，被设备扫描后可获取其中所包含的信息。一维条码的宽度记载着数据，而其长度没有记载数据。二维条码的长度、宽度均记载着数据。二维条码有一维条码没有的“定位点”和“容错机制”。容错机制在即使没有辨识到全部的条码、或是说条码有污损时，也可以正确地还原条码上的信息。二维条码的种类很多，不同的机构开发出的二维条码具有不同的结构以及编写、读取方法。\n    堆叠式/行排式二维条码，如，Code 16K、Code 49、PDF417（如下图）等。\n<img src=\"http://oourcagfr.bkt.clouddn.com/201708/QR-Code%20(0).jpg\" />\n\n    矩阵式二维码，最流行莫过于QR CODE，二维码的名称是相对与一维码来说的，比如以前的条形码就是一个“一维码”。它的优点有：二维码存储的数据量更大；可以包含数字、字符，及中文文本等混合内容；有一定的容错性（在部分损坏以后可以正常读取）；空间利用率高等。\n    <strong>二维码编码过程</strong>\n    <strong>1、数据分析：</strong>确定编码的字符类型，按相应的字符集转换成符号字符； 选择纠错等级，在规格一定的条件下，纠错等级越高其真实数据的容量越小。\n\n    <strong>2、数据编码：</strong>将数据字符转换为位流，每8位一个码字，整体构成一个数据的码字序列。其实知道这个数据码字序列就知道了二维码的数据内容。\n<img src=\"http://oourcagfr.bkt.clouddn.com/201708/QR-Code%20(1).png\" />\n\n下面就用一个案例来了解二维码的编码过程，以对数据01234567编码为例\n    1）分组：012 345 67\n    2）转成二进制：012→0000001100      345→0101011001     67 →1000011\n    3）转成序列：0000001100 0101011001 1000011\n    4）字符数 转成二进制：8→0000001000\n    5）加入模式指示符（上图数字）0001：0001 0000001000 0000001100 0101011001 1000011\n    对于字母、中文、日文等只是分组的方式、模式等内容有所区别，基本方法是一致的。二维码虽然比起一维条码具有更强大的信息记载能力，但也是有容量限制，通过下面这个表格了解二维码的容量到底有多大。\n<img src=\"http://oourcagfr.bkt.clouddn.com/201708/QR-Code%20(2).png\" />\n\n    <strong>3、纠错编码：</strong>按需要将上面的码字序列分块，并根据纠错等级和分块的码字，产生纠错码字，并把纠错码字加入到数据码字序列后面，成为一个新的序列。在二维码规格和纠错等级确定的情况下，其实它所能容纳的码字总数和纠错码字数也就确定了，比如：版本10，纠错等级时H时，总共能容纳346个码字，其中224个纠错码字。就是说二维码区域中大约1/3的码字时冗余的。对于这224个纠错码字，它能够纠正112个替代错误（如黑白颠倒）或者224个据读错误（无法读到或者无法译码），这样纠错容量为：112/346=32.4%\n\n    <strong>4、构造最终数据信息：</strong>在规格确定的条件下，将上面产生的序列按次序放如分块中按规定把数据分块，然后对每一块进行计算，得出相应的纠错码字区块，把纠错码字区块 按顺序构成一个序列，添加到原先的数据码字序列后面。如：D1, D12, D23, D35, D2, D13, D24, D36, … D11, D22, D33, D45, D34, D46, E1, E23,E45, E67, E2, E24, E46, E68，…\n\n    <strong>5 、构造矩阵：</strong>在构造矩阵之前，我们先来了解一个普通二维码的基本结构。\n<img src=\"http://oourcagfr.bkt.clouddn.com/201708/QR-Code%20(3).png\" />\n    位置探测图形、位置探测图形分隔符、定位图形：用于对二维码的定位，对每个QR码来说，位置都是固定存在的，只是大小规格会有所差异；\n    校正图形：规格确定，校正图形的数量和位置也就确定了；\n    格式信息：表示改二维码的纠错级别，分为L、M、Q、H；\n    版本信息：即二维码的规格，QR码符号共有40种规格的矩阵（一般为黑白色），从21×21（版本1），到177×177（版本40），每一版本符号比前一版本 每边增加4个模块。\n    数据和纠错码字：实际保存的二维码信息，和纠错码字（用于修正二维码损坏带来的错误）。\n    了解了二维码的基本结构后，将探测图形、分隔符、定位图形、校正图形和码字模块放入矩阵中，并把上面的完整序列填充到相应规格的二维码矩阵的区域中。\n<img src=\"http://oourcagfr.bkt.clouddn.com/201708/QR-Code%20(4).png\" />\n\n    <strong>6、掩膜：</strong>将掩摸图形用于符号的编码区域，使得二维码图形中的深色和浅色（黑色和白色）区域能够比率最优的分布。\n\n    <strong>7、格式和版本信息：</strong>生成格式和版本信息放入相应区域内。版本7-40都包含了版本信息，没有版本信息的全为0。二维码上两个位置包含了版本信息，它们是冗余的。版本信息共18位，6X3的矩阵，其中6位时数据为，如版本号8，数据位的信息时 001000，后面的12位是纠错位。', '2017-08-24 09:38:33', 'WuGN', ''),
(34, '我爱soooo.club', 'admin', NULL, '<img src=\"http://oourcagfr.bkt.clouddn.com/201709/sooooclub.png\" style=\"float:right;width:196px;height:196px;\" />\n    在没有系统的学习前端技术之前，我天真的认为网页上所有的一切全内容都存在于一个个html文件之中，在我发现了浏览器可以查看网页源码之后，开始查看布局精美的网页源码，下载并学习它。删除多余的代码，做成一个个含有独立功能的本地demo网页并以此为乐。\n\n    到后来，我在不断的上网学习之中，渐渐的接触到了css，JavaScript等概念，并渐渐的熟练使用它们。同时也接触到了一些专门学习这些知识的网站w3school，runoob等，通过这些教程的系统学习，和我自己的实践操作，对这些语言有了新的认识，同时也补充和总结了前端知识，更加规范了自己的代码。\n\n    到目前为止，我粗略的学习了font awsome、bootstrap、jQuery、PHP、mysql等教程，同时也对其他拓补知识有所了解。自认为这些知识足够我独立去做一些简单的网页。于是，我逐渐放弃了使用WordPress等建站系统，开始着手建立自己的网站帝国。WP，Dz，dede等建站系统，我都试用过，这些建站系统功能很强大，可扩展性也很高，拥有完善的开发团队和丰富的插件。但是，这些系统在宣传上都明示或暗示着“傻瓜式建站”的旗号，这使正在学习前端知识的我感到屈辱，于是我下定决心自己创作属于自己的网站。\n\n    经历了几个月的学习与实践之后，我的网站初具模型，各种功能也愈加完善。由于我的这个网站主要内容是我自己的日记，存储一些比较私密的文章，所以我并不期待有很多人来访问提升流量（便宜的云主机也不一定能支持这么大的访问量），我只希望我能有一个实践的地方，一个观赏自己成品的空间。网站还在不断的发展，一些功能也在不断完善，我希望自己掌握越来越多的网站知识，前端后端技术都熟练运用，在网络空间上做出更多更精美的世界。\n\n    我爱前端，我爱我的soooo.club。', '2017-09-13 06:53:14', 'WuGN', ''),
(35, '建站主机选择', 'admin', NULL, '    既然要建立属于自己的网站，那就需要一个云端主机。我买虚拟主机的时候是捡着便宜的选，使用性能最低的机器，毕竟我的网站功能也少，访问量也不大。稀里糊涂的买完之后才发现选购建站主机也有很多讲究。\r\n\r\n    一般来说，纯静态页面没必要购买主机，在国外找一个可提供免费放静态页面的地方，买个域名绑定一下即可，国内也许也有这样的地方，不过不推荐国内，不稳定。动态页面的主机选择如果是动态页面，先考虑是数据库类型+页面类型，比如jsp+mysql或者asp+access之类的，这种选择决定了你用的主机是Windows环境还是Linux环境。——这是一个大前提。如果是一个初级网站建设者，网站规模不大，就自己一个人维护，对网站没有特别的要求，那么一般的虚拟主机就可以了。\r\n\r\n    国内买域名或者国内买主机/空间是都需要备案的。这个有时会比较麻烦，天朝特色嘛，而国外就不需要。个人blog一类的网站对带宽和CPU要求不高，这些网站重点考察的是速度以及空间大小（空间性价比），而BBS之类的网站一般对CPU都有要求，比如同时在线用户大于50人以上的BBS，对CPU和数据库性能都有要求。\r\n\r\n    主机的空间配置硬盘空间肯定跟网站大小有关，如果做下载站或者中转站，空间必须足够大。并且，有些主机对mssql数据库的大小有限制，对于BBS之类的网站来说，连接数是很关键的，通常：最大在线用户数量×2，CPU限制这个参数一般影响BBS之类的网站，全站搜索的时候，很耗CPU时间。另外有些独立主机限制的是总带宽，这里需要自己会计算：1Mbps大概相当于120KB/s的速度。如果你的硬盘空间满了，流量也用完了，那么就该升级空间。', '2017-09-13 06:58:28', 'WuGN', ''),
(36, '层叠样式表CSS', 'admin', NULL, '    在网页源码中，头部常常会引用一个或多个css文件，那么何为css？css是指层叠样式表(Cascading Style Sheets)，作用是定义如何显示HTML元素。元素的样式通常存储在样式表中，把样式添加到HTML中，是为了解决内容与表现分离的问题。外部样式表可以极大提高工作效率，外部样式表通常存储在CSS文件中，多个样式定义可层叠为一，一个HTML文档可以显示不同的样式。\n\n    样式表定义如何显示 HTML 元素，就像html的字体标签和颜色属性所起的作用那样。样式通常保存在外部的.css 文件中。通过仅仅编辑一个简单的 CSS 文档，外部样式表使你有能力同时改变站点中所有页面的布局和外观。万维网联盟（W3C），这个非营利的标准化联盟，肩负起了 HTML 标准化的使命，并在HTML4.0之外创造出样式（Style）。当代浏览器都支持 CSS。CSS 样式表极大地提高了工作效率。\n\n    CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明，选择器通常是您需要改变样式的HTML元素。每条声明由一个属性和一个值组成。属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。\n\n    例如：\n\n<pre><code>p{\n    color:red;\n    text-align:center;\n}</code></pre>\n标签p内容红色居中。', '2017-09-13 08:27:57', 'WuGN', ''),
(37, 'Bootstrap简介', 'admin', NULL, '<img src=\"http://oourcagfr.bkt.clouddn.com/201709/bootstrap.jpg\" style=\"float:right\" />\n    Bootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。\n\n    Bootstrap 为所有开发者、所有应用场景而设计。Bootstrap 让前端开发更快速、简单。所有开发者都能快速上手、所有设备都可以适配、所有项目都适用。虽然可以直接使用 Bootstrap 提供的 CSS 样式表，不要忘记 Bootstrap 的源码是基于最流行的 CSS 预处理脚本 - Less 和 Sass 开发的。你可以采用预编译的 CSS 文件快速开发，也可以从源码定制自己需要的样式。网站和应用能在 Bootstrap 的帮助下通过同一份代码快速、有效适配手机、平板、PC 设备，这一切都是 CSS 媒体查询（Media Query）的功劳。Bootstrap 提供了全面、美观的文档。你能在这里找到关于 HTML 元素、HTML 和 CSS 组件、jQuery 插件方面的所有详细文档。\n\n    <strong>Bootstrap 特点</strong>\n    移动设备优先：自 Bootstrap 3 起，框架包含了贯穿于整个库的移动设备优先的样式。\n    浏览器支持：所有的主流浏览器都支持 Bootstrap。\n    容易上手：只要您具备 HTML 和 CSS 的基础知识，您就可以开始学习 Bootstrap。\n    响应式设计：Bootstrap 的响应式 CSS 能够自适应于台式机、平板电脑和手机。\n    它为开发人员创建接口提供了一个简洁统一的解决方案。\n    它包含了功能强大的内置组件，易于定制。\n    它还提供了基于 Web 的定制。\n    它是开源的。\n\n    <strong>Bootstrap 包的内容：</strong>\n    基本结构：Bootstrap 提供了一个带有网格系统、链接样式、背景的基本结构。\n    CSS：Bootstrap 自带以下特性：全局的 CSS 设置、定义基本的 HTML 元素样式、可扩展的 class，以及一个先进的网格系统。\n    组件：Bootstrap 包含了十几个可重用的组件，用于创建图像、下拉菜单、导航、警告框、弹出框等等。\n    JavaScript 插件：Bootstrap 包含了十几个自定义的 jQuery 插件。您可以直接包含所有的插件，也可以逐个包含这些插件。\n    定制：您可以定制 Bootstrap 的组件、LESS 变量和 jQuery 插件来得到您自己的版本。', '2017-09-13 08:38:14', 'WuGN', ''),
(38, 'JavaScript简介', 'admin', NULL, '    JavaScript 是 Web 的编程语言。所有现代的 HTML 页面都使用 JavaScript。JavaScript web 开发人员必须学习的 3 门语言中的最后一门：HTML 定义了网页的内容，CSS 描述了网页的布局，JavaScript 网页的行为。也就是说，html使网页具有内容，css使网页美观，js使网页动起来有活力。\r\n\r\n    JavaScript是互联网上最流行的脚本语言，这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。JavaScript也是一种轻量级的编程语言，它是可插入 HTML 页面的编程代码，可由所有的现代浏览器执行。您会经常看到 document.getElementById(\"some id\")。这个方法是 HTML DOM 中定义的。\r\n\r\n    HTML 中的脚本必须位于&ltscript&gt与&lt/script&gt标签之间。&ltscript&gt和&lt/script&gt会告诉 JavaScript 在何处开始和结束。脚本可被放置在 HTML 页面的&ltbody&gt和&lthead&gt部分中。也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。外部 JavaScript 文件的文件扩展名是 .js。如需使用外部文件，请在&ltscript&gt标签的 \"src\" 属性中设置该 .js 文件链接。\r\n\r\n    值得注意的是，很多新手会把这门语言与Java语言相关联，但实际上JavaScript 与 Java 是两种完全不同的语言，无论在概念上还是设计上。Java（由 Sun 发明）是更复杂的编程语言。JavaScript 由 Brendan Eich 发明，JavaScript 标准的官方名称是ECMA-262。它于 1995 年出现在 Netscape 中（该浏览器已停止更新），并于 1997 年被 ECMA（一个标准协会）采纳。', '2017-09-13 08:59:14', 'WuGN', ''),
(39, '标题变换', 'admin', NULL, '    如果你细心的话，就会发现我的网站上部的title会随着标签的切换而变化：当你打开网页的时候，正常显示title，切换标签后，显示为“(●—●)你还会回来吗？”，切回来后显示“今天，又是充满希望的一天！”，显示2秒钟后自动消失，显示正常title。这些话都是DNF中赛利亚的经典句子，用在我的网页上显得很亲切又有趣。\n\n    这些动态的功能需要JavaScript来实现，当然，在这之中也需要jQuery的配合。以下就是本站关于标题变换的源码。\n<pre><code>jQuery(document).ready(function($) {\n    var OriginTitile = document.title;\n    var titleTime;\n    document.addEventListener(\'visibilitychange\', function() {//标签可见性\n    if (document.hidden) {//被隐藏时\n        document.title = \'(●—●)你还会回来吗？\' + OriginTitile;\n        clearTimeout(titleTime);\n    }\n    else {//非隐藏状态下\n        document.title = \'今天，又是充满希望的一天！\' + OriginTitile;\n        titleTime = setTimeout(function() {//设置时间\n        document.title = OriginTitile;\n        }, 2000);\n    }\n});\n});</code></pre>\n    其中第一句代码“$(document).ready(function(){”是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。如果在文档没有完全加载之前就运行函数，操作可能失败。很多功能代码都要放在这个句子内运行。', '2017-09-13 09:33:12', 'WuGN', ''),
(40, '控制台console', 'admin', NULL, '    console是控制台。在JavaScript中，使用console.log语句就可以输出到控制台显示，利用chrome浏览器F12键可以很容易的进入控制台并看到这部分内容。\n\n    在一些网站上，console部分通常显示网页调试信息，也有些在此发布招聘信息，还有些在此处打印彩色的文字、图片，甚至还有些个人的博客网站在此处扩展网页功能用以炫耀技术。console.log的运用完善了网页功能，丰富了网页内容，增加了网页的可玩性。我在自己的网页源码中添加了以下内容，用以显示图片和文字。\n<pre><code>console.log(\"%c My heart is with you.\\n\n%c囊中羞涩,租不起云主机,求大佬赏赐 (/≧▽≦/)\\n\n支付宝/微信:13646019112 (●￣ε￣●)\\n\n转账请备注 %c来自:wuguangnuo.cn,console\",\n\"padding:40px 100px;line-height:100px;font-size:28px;font-weight:bold;background:url(\'http://love.png\') no-repeat\",\n\"font-size:16px;\",\n\"color:crimson;font-weight:bold;font-size:16px;\");</code></pre>\n    在这段代码中，有三个换行符，所以分成四行文字展示。有三个“%c”标志，在代码后半段也分别为其定义了样式。第一个样式显示了背景图片并定义了文字样式。第二个改变了字体大小。第三个改变了字体颜色粗细和大小。\n\n    这段代码的具体执行结果还是有请大家自行按F12打开观看吧。(如果你用的是IE浏览器就当我没说，只有chrome内核才支持conlose语句)', '2017-09-13 16:19:51', 'WuGN', ''),
(41, '我的编辑器Notepad', 'admin', NULL, '<img src=\"http://oourcagfr.bkt.clouddn.com/201704/notepad.png\" style=\"float:right\" />\n    我用过的文本编辑器并不多，Notepad++是我最喜欢的一款文本编辑器。它可以被看作是Windows自带的记事本扩展板。但功能比记事本多得多，除了可以用来制作一般的纯文字说明文件，也十分适合编写计算机程序代码。\n\n    Notepad++不仅有语法高亮显示，也有语法折叠功能，并且支持宏以及扩充基本功能的外挂模具。让我感到方便的是它可以自由的改变文档编码字符集，UTF8,、ANSI、USC-2等等编码格式自由转换。面对日益标准化的UTF8编码格式，Windows自带的记事本的默认编码格式ASNI已经不太适合用来写代码了。\n\n    此外，Notepad++还是一款免费软件，自带中文，并且支持众多计算机语言，听说过的、没见过的语言格式，它都支持，甚至你还可以自定义语言。\n\n    Notepad++可以自动检测文件类型，根据关键字显示节点，节点可自由折叠/打开，可显示缩进引导线，使代码富有层次感。可打开双窗口，在分窗口中又可打开多个子窗口。可显示选中文本的字节数，并非普通编辑器所显示的字数；提供了一些实用工具，如邻行互换位置、宏功能等。强大的查找机制，支持正则表达式查询。我之前还专门写了一篇文章来介绍Notepad++的正则表达式。\n\n    Notepad++是一款好软件，极大的提高了我的学习效率。', '2017-09-14 01:51:30', 'WuGN', ''),
(42, '请点赞', 'admin', NULL, '    今天我来介绍一个点赞演示。请注意网页右侧的sidebar，当你点击区域时，就会有出现爱心并且逐渐上升，好像点赞一样。这是我偶然间在WordPress大神陌小雨的博客发现的，感觉很有趣，于是就查看源码扒了下来...借鉴一下。刚刚发现，他本人已经把这个小小的功能去掉了，没关系，下面放上代码共赏。\n<pre><code>jQuery(document).ready(function($) {\n$(\".newsItem\").click(function(e){//选中区域class = newsItem\n    var n=Math.round(Math.random()*100);//随机数\n    var $i=$(\"&ltb&gt\").text(\"+\"+n+\"?\");//添加到页面的元素\n    var x=e.pageX,y=e.pageY;//鼠标点击的位置\n    $i.css({//改变样式\n        \"z-index\":99999,\n        \"top\":y-15,\n        \"left\":x,\n        \"position\":\"absolute\",\n        \"color\":\"red\",\n	\"user-select\":\"none\"\n    });\n    $(\"body\").append($i);\n    $i.animate(\n        {\"top\":y-180,\"opacity\":0},\n        1500,//持续1500毫秒\n        function(){$i.remove();}\n    );\n    e.stopPropagation();//停止播放\n});\n});</code></pre>\n    这么严谨的逻辑功能当然需要引用万能的jQuery啦。其中，$i指的是新建的心形图标，$i的样式设置为z轴距离99999，绝对定位，红色不可选中。append()附加，animate()活动，remove()移动,这些都是jQuery的方法，引用jQuery方法可以大大简化代码结构，更加高效快捷灵活的实现网页动态功能。\n', '2017-09-14 08:32:32', 'WuGN', ''),
(43, '滚动条样式', 'admin', NULL, '    最近在浏览博客大神迷津渡口的网站时候，给人一种眼前一亮的感觉，虽然这是利用emlog平台搭建的网站，但是简洁不失简单：极其精美的主页配色，随处可见的动态展现，精心设计的的功能布局，让人看上一眼就印象深刻，这么舒服的网页真让人羡慕不已。\n\n    在这之中，我也注意到了两点细节：鼠标指针和滚动条的样式变化。这使我很惊奇，我以前从来不知道在网页上鼠标指针样式和滚动条的样式可以随意修改。（当然，经过我的测试，滚动条并不支持IE浏览器）关于滚动条部分的实例，我发现这是通过CSS样式表实现的。于是我把关于滚动条部分的样式复制下来，经过自己的修改，有了以下代码。\n<button class=\"flip\" type=\"button\">scrollbar.css</button>\n<pre><code>//scrollbar.css\n::-webkit-scrollbar {//滚动条整体部分\n	width:10px;\n	height:10px\n}\n::-webkit-scrollbar-button {//滚动条两端按钮\n	width:0;\n	height:0\n}\n::-webkit-scrollbar-thumb {//滚动条内滑块\n	-webkit-border-radius:8px;\n	border-radius:8px;\n	background-color:rgba(0,0,0,0.2)\n}\n::-webkit-scrollbar-thumb:hover {//滚动条内滑块覆盖\n	-webkit-border-radius:8px;\n	border-radius:8px;\n	background-color:rgba(0,0,0,0.5)\n}\n::-webkit-scrollbar-track,//滚动条的轨道（里面装有Thumb）\n::-webkit-scrollbar-thumb {\n	border-right:1px solid transparent;\n	border-left:1px solid transparent\n}\n::-webkit-scrollbar-track:hover {//滚动条轨道覆盖\n	background-color:rgba(0,0,0,0.15)\n}\n//以下是滚动条两端箭头样式选择\n::-webkit-scrollbar-button:start {\n	width:10px;\n	height:10px;\n	background:url(\"http://arrow.png\") no-repeat 0 0\n}\n::-webkit-scrollbar-button:start:hover {\n	background:url(\"http://arrow.png\") no-repeat -15px 0\n}\n::-webkit-scrollbar-button:start:active {\n	background:url(\"http://arrow.png\") no-repeat -30px 0\n}\n::-webkit-scrollbar-button:end {\n	width:10px;\n	height:10px;\n	background:url(\"http://arrow.png\") no-repeat 0 -18px\n}\n::-webkit-scrollbar-button:end:hover {\n	background:url(\"http://arrow.png\") no-repeat -15px -18px\n}\n::-webkit-scrollbar-button:end:active {\n	background:url(\"http://arrow.png\") no-repeat -30px -18px\n}</code></pre>\n    显而易见，这是webkit内核专用语法。所以这段代码只会在使用了基于webkit内核的浏览器上运行。', '2017-09-14 09:17:26', 'WuGN', ''),
(44, 'MySQL数据库', 'admin', NULL, '<img src=\"http://oourcagfr.bkt.clouddn.com/201709/mysql.jpg\" style=\"float:right\" />\n    Mysql是最流行的关系型数据库管理系统，在WEB应用方面MySQL是最好的RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。\n\n    <strong>RDBMS即关系数据库管理系统(Relational Database Management System)的特点：</strong>\n	1.数据以表格的形式出现\n	2.每行为各种记录名称\n	3.每列为记录名称所对应的数据域\n	4.许多的行和列组成一张表单\n	5.若干的表单组成database\n\n    <strong>关于 RDBMS 的一些专业术语：</strong>\n\n	1.数据库: 数据库是一些关联表的集合。.\n	2.数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。\n	3.列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。\n	4.行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。\n	5.冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。\n	6.主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。\n	7.外键：外键用于关联两个表。\n	8.复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。\n	9.索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。\n	10.参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。\n\n    MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle公司。MySQL是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\n\n	1.Mysql是开源的，所以你不需要支付额外的费用。\n	2.Mysql支持大型的数据库。可以处理拥有上千万条记录的大型数据库。\n	3.MySQL使用标准的SQL数据语言形式。\n	4.Mysql可以允许于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP、Eiffel、Ruby和Tcl等。\n	5.Mysql对PHP有很好的支持，PHP是目前最流行的Web开发语言。\n	6.MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。\n	7.Mysql是可以定制的，采用了GPL协议，你可以修改源码来开发自己的Mysql系统。\n', '2017-09-14 15:41:27', 'WuGN', ''),
(45, '世界上最好的语言', 'admin', NULL, '<img src=\"http://oourcagfr.bkt.clouddn.com/201709/php.jpg\" style=\"float:right\" />\n    世界上最好的语言是什么？答案当然是PHP啦，它简单易学，使用方便。\n\n    PHP（PHP: Hypertext Preprocessor超文本预处理器）是一种通用开源脚本语言。语法吸收了C语言、Java和Perl的特点，利于学习，使用广泛，主要适用于Web开发领域。PHP 独特的语法混合了C、Java、Perl以及PHP自创的语法。它可以比CGI或者Perl更快速地执行动态网页。用PHP做出的动态页面与其他的编程语言相比，PHP是将程序嵌入到HTML（标准通用标记语言下的一个应用）文档中去执行，执行效率比完全生成HTML标记的CGI要高许多；PHP还可以执行编译后代码，编译可以达到加密和优化代码运行，使代码运行更快。\n\n    PHP的优点数不胜数：\n\n	PHP 可在不同的平台上运行（Windows、Linux、Unix、Mac OS X 等）\n	PHP 与目前几乎所有的正在被使用的服务器相兼容（Apache、IIS 等）\n	PHP 提供了广泛的数据库支持\n	PHP 是免费的，可从官方的 PHP 资源下载它\n	PHP 易于学习，并可高效地运行在服务器端\n	PHP 可以生成动态页面内容\n	PHP 可以创建、打开、读取、写入、关闭服务器上的文件\n	PHP 可以收集表单数据\n	PHP 可以发送和接收 cookies\n	PHP 可以添加、删除、修改您的数据库中的数据\n	PHP 可以限制用户访问您的网站上的一些页面\n	PHP 可以加密数据\n\n    通过 PHP，将不再限于输出 HTML。您可以输出图像、PDF 文件，甚至 Flash 电影。您还可以输出任意的文本，比如 XHTML 和 XML。WordPress，Discuz，织梦等等都是基于 PHP 制作的，实际上，我的网站主要也是由 PHP 编写而成的。', '2017-09-15 02:25:57', 'WuGN', ''),
(46, '凡勃伦效应', 'admin', NULL, '    随着社会经济的发展，人们的消费会随着收入的增加，而逐步由追求数量和质量过渡到追求品位格调。了解了“凡勃伦效应”，我们也可以利用它来探索新的经营策略。比如凭借媒体的宣传，将自己的形象转化为商品或服务上的声誉，使商品附带上一种高层次的形象，给人以“名贵”和“超凡脱俗”的印象，从而加强消费者对商品的好感。\r\n\r\n    那么，什么才是 凡勃伦 效应？\r\n\r\n    美国经济学家凡勃伦提出了凡勃伦效应：商品价格定得越高越能畅销。它是指消费者对一种商品需求的程度因其标价较高而不是较低而增加。它反映了人们进行挥霍性消费的心理愿望。凡勃伦效应需求规律是：当旅游产品或服务价格上升时，被认为是提高质量，其需求量也随之上升。即旅游需求与价格的关系与一般的供求关系规律相悖离，价格上升，需求量反而会增加，即“挥霍消费”。当消费者购买能彰显其身份地位的豪华旅游产品和服务时，被认为是得到了更多更好的体验及享受，需求随价格上升而增加。\r\n\r\n    我们经常在生活中看到这样的情景：款式、皮质差不多的一双皮鞋，在普通的鞋店卖80元，进入大商场的柜台，就要卖到几百元，却总有人愿意买。1.66万元的眼镜架、6.88万元的纪念表、168万元的顶级钢琴，这些近乎“天价”的商品流通，往往也能在市场上走俏。\r\n\r\n    其实，消费者购买这类商品的目的并不仅仅是为了获得直接的物质满足和享受，更大程度上是为了获得心理上的满足。这就出现了一种奇特的经济现象，即一些商品价格定得越高，就越能受到消费者的青睐。\r\n\r\n    所以，经济学的凡勃伦效应告诉我们，高端消费人群影响并带动消费行为。也可以理解为领袖的意见导向。即商品价格下降，有的消费者会认为是该商品品质滑落，或视为其独占性的丧失，而停止再购买该商品。\r\n\r\n    价值的转换在消费者从数量、质量购买阶段过渡到感性购买阶段时，就成为可能。当感性消费成为一种时尚，只要消费者有能力进行这种感性购买时，“凡勃伦效应”就可以被有效地转化为提高市场份额的营销策略。', '2017-09-15 02:51:27', 'WuGN', ''),
(47, '数据库操作', 'admin', NULL, '    数据库操作网站操作的重要一环。通常的，网站上的许多数据如用户信息，文章内容等等都是储存在数据库中。通过 MySQL，我们可以向数据库查询具体的信息，并得到返回的记录集。例如，本网站上的博客文章就是存储在MySQL数据库中的，通过数据库我可以很方便的查询和管理这些文章。数据库总共有增、删、改、查四种基本操作。在您能够访问并处理数据库中的数据之前，您必须创建到达数据库的连接。在 PHP 中，这个任务通过mysql_connect() 函数完成。\n\n	这个函数的语法是“<strong>mysql_connect(servername,username,password);</strong>”\n	servername	可选。规定要连接的服务器。默认是 \"localhost:3306\"。\n	username	可选。规定登录所使用的用户名。默认值是拥有服务器进程的用户的名称。\n	password	可选。规定登录所用的密码。默认是 \"\"。\n\n    举个栗子，以下是我的本地模拟数据库PHP链接connect.php代码：\n\n<pre><code>&lt?php\n	$servername=\"127.0.0.1\";//主机\n	$username=\"root\";//数据库用户名\n	$password=\"root\";//数据库密码\n	$con = mysql_connect($servername,$username,$password);//链接数据库\n	mysql_query(\"SET NAMES \'UTF8\'\");//数据库编码规则UTF8\n	if(!$con){\n		die(\"can\'t connect \".mysql_error());//如果链接失败输出错误\n	}\n	mysql_close($con);\n?&gt</code></pre>\n    mysql_query(\"SET NAMES \'UTF8\'\");可以消除字符乱码，同理，你也可以设置为 GBK 或者其他格式。值得一提的是，脚本一结束，就会关闭连接。如需提前关闭连接，请使用 mysql_close() 函数。', '2017-09-15 08:26:11', 'WuGN', ''),
(48, '网站重构', 'admin', NULL, '    随着网站文章数量的增多，我早期设定的一些网站结构和网页结构已经渐渐的不适应新的节奏了。网站上的内容越来越多，就有许多新类型的组件不适用于之前的分类而无处安放，这就导致了网站的构架混乱繁缛，网站结构愈加混乱，树枝就越多，管理就越困难。当着形成恶性循环时，就要考虑进行网站搬家和网站重构了。\r\n\r\n    在最初建立网站布局的时候，那时我也是入门级搬砖工，什么都不懂，只知道把网页搬到主机上欣赏。如今随着网站规模逐渐扩大，许许多多并不常用的陈旧文件无人问津，而经常访问的部分却有着很长的链接，既不简洁又不美观。\r\n\r\n    实际上，我已经对网站进行了好几次升级换代，每次无不是把几乎所有的文件删除重排，分门别类的存放起来。文件内的各种链接也需要一一重写，毕竟网站建立之初就没有考虑到许多细节，也没想到短短几个月间网站的功能变得如此之多，内容如此之广，数据如此之复杂。\r\n\r\n    第一代网站是地图网站，是一个现在看起来很简单的demo，仅仅数个页面就搞定了。第二代则是一个由WordPress制作的网站，网站很漂亮，我在之中倾注了许多心血，我也很喜欢。但是经过一段时间的考虑后，我觉得自己制作网站，而不是利用别人搭好的桥，走别人走过的路。于是便有了后面的第三代、第四代网站。现在的网站还有许多地方亟待优化，有些设计也缺乏考量，但我会持续优化，持续添加内容，不断的为我的soooo.club注入新活力。', '2017-09-16 09:12:04', 'WuGN', ''),
(49, '代码隐藏', 'admin', NULL, '    我发布的内容有许多(伪)技术文章，所以部分文章含有大量代码源码。这在文章布局结构上看起来显得很突兀，排版很不美观。于是我想到我以前的文章是如何解决这个问题的，源码内容填写在&ltblockquote&gt&lt/blockquote&gt之间，这样方便使用外部css文件来进行样式设计。添加一个可以隐藏/显示源码的按钮，源码默认是处于隐藏状态，这样可以解决很长的代码占用大量篇幅的问题。当需要在文章内添加代码时，只需要在代码外部添加以下代码：\n\n<pre><code>&ltbutton class=\"flip\" type=\"button\"&gtscrollbar.css&lt/button&gt\n&ltdiv class=\"panel\"&gt\n    &lt!--some code--&gt\n&lt/div&gt</code></pre>\n注：你的代码需用正则表达式转换(发布栏已默认使用此功能)\n\n    经由JavaScript控制按钮button的功能实现。以下是关于隐藏部分的function.js代码\n\n<pre><code>$(function() {\n    $(\".panel\").hide();\n    $(\".flip\").click(function() {\n        $(\".panel:eq(\" + $(this).index(\".flip\") + \")\").slideToggle(\"slow\");\n    });\n});</code></pre>', '2017-09-16 09:40:42', 'WuGN', ''),
(50, '软件开发——复杂度', 'admin', NULL, '<img src=\"http://oourcagfr.bkt.clouddn.com/201709/Frederick%20Brooks.png\" style=\"float:right;width:300px;height:185px;\" />\n    IBM大型机之父，Frederick Brooks.曾发表过一篇论文，指出了软件开发的难点在哪里。布鲁克斯把软件开发中的困难分为两类：\n<strong>essence</strong>，可以译为本质困难或者主要问题，指的是软件开发中不可规避的问题，就是软件本身在概念建构上存先天的困难，也就是如何从问题领域，发展出具体的解决方案。\n<strong>accident</strong>，可以译为次要因素或次要问题，指的是把解决方案实施到电脑上，所遇到的困难。\n\n    软件开发中无法规避的四个特征分别是<strong>复杂度</strong>、<strong>一致性</strong>、<strong>可变性</strong>、<strong>不可见性</strong>。其中，我认为布鲁克斯解释的最透彻的部分是软件开发复杂度，节选软件开发复杂度部分如下：\n\n    规模上，软件实体可能比任何由人类创造的其他实体要复杂，因为<strong>没有任何两个软件部分是相同的</strong>（至少是在语句的级别）。如果有相同的情况，我们会把它们合并成供调用的子函数。在这个方面，软件系统与计算机、建筑或者汽车大不相同，后者往往存在着大量重复的部分。\n\n    数字计算机本身就比人类建造的大多数东西复杂。计算机拥有大量的状态，这使得构思、描述和测试都非常困难。软件系统的状态又比计算机系统状态多若干个数量级。\n\n    同样，软件实体的扩展也不仅仅是相同元素重复添加，而必须是不同元素实体的添加。大多数情况下，这些元素以非线性递增的方式交互，因此整个软件的复杂度以更大的非线性级数增长。\n\n    <strong>软件的复杂度是必要属性，不是次要因素。</strong>因此，抽掉复杂度的软件实体描述常常也去掉了一些本质属性。数学和物理学在过去三个世纪取得了巨大的进步，数学家和物理学家们建立模型以简化复杂的现象，从模型中抽取出各种特性，并通过试验来验证这些特性。这些方法之所以可行——是因为模型中忽略的复杂度不是被研究现象的必要属性。当复杂度是本质特性时，这些方法就行不通了。\n\n    上述软件特有的复杂度问题造成了很多经典的软件产品开发问题。由于复杂度，团队成员之间的沟通非常困难，导致了产品瑕疵、成本超支和进度延迟；由于复杂度，列举和理解所有可能的状态十分困难，影响了产品的可靠性；由于函数的复杂度，函数调用变得困难，导致程序难以使用；由于结构性复杂度，程序难以在不产生副作用的情况下用新函数扩充；由于结构性复杂度，造成很多安全机制状态上的不可见性。\n\n    <strong>复杂度不仅仅导致技术上的困难，还引发了很多管理上的问题。</strong>它使全面理解问题变得困难，从而妨碍了概念上的完整性；它使所有离散出口难以寻找和控制；它引起了大量学习和理解上的负担，使开发慢慢演变成了一场灾难。', '2017-09-17 03:18:13', 'WuGN', ''),
(51, '显示日历', 'admin', NULL, '<img src=\"http://oourcagfr.bkt.clouddn.com/201709/printcalendar.png\" style=\"float:right;\" />\n    在大二学习java语言时，有一个作业是写一个打印日历的java程序。当时我的代码并不完善，因为要考虑到平年闰年、每月天数等问题。现在看来这是一个很简单的java编程问题，只要把其中的关系搞清楚，做成一个个函数调用。现修改代码如下，运行结果如图所示。代码内含注释，结构清晰，函数调用环环相扣，逻辑性强。\n<button class=\"flip btn btn-primary\" type=\"button\">PrintCalendar.java</button>\n<pre><code>//8.6显示日历;程序清单5-12\nimport java.util.Scanner;\npublic class PrintCalendar{\n	//主函数\n	public static void main(String[] args){\n		Scanner input = new Scanner(System.in);\n		System.out.print(\"Enter full year (e.g.,2001):\");\n		int year = input.nextInt();//输入并定义年份\n		\n		System.out.print(\"Enter month in number between 1 and 12:\");\n		int month = input.nextInt();//输入并定义月份\n		printMonth(year,month);\n		input.close();//打印日历并关闭输入函数\n	}\n	//打印函数，分为表头和内容部分\n	public static void printMonth(int year,int month){\n		printMonthTitle(year,month);\n		printMonthBody(year,month);\n	}\n	//打印表头函数\n	public static void printMonthTitle(int year, int month){\n		System.out.println(\"         \"+getMonthName(month)+\" \"+year);\n		System.out.println(\"---------------------------\" +\n				\"-------------------------\");\n		System.out.println(\"Sun\\tMon\\tTue\\tWed\\tThu\\tFri\\tSat\");\n	}\n	//转译函数，把数字月份转换成英文月份\n	public static String getMonthName(int month){\n		String monthName = \" \";\n		switch (month){\n		case 1: monthName = \"January\";break;\n		case 2: monthName = \"february\";break;\n		case 3: monthName = \"March\";break;\n		case 4: monthName = \"April\";break;\n		case 5: monthName = \"May\";break;\n		case 6: monthName = \"June\";break;\n		case 7: monthName = \"July\";break;\n		case 8: monthName = \"August\";break;\n		case 9: monthName = \"September\";break;\n		case 10: monthName = \"October\";break;\n		case 11: monthName = \"November\";break;\n		case 12: monthName = \"December\";\n		}\n		return monthName;\n	}\n	//打印日历内容函数\n	public static void printMonthBody(int year,int month){\n		int startDay = getStartDay(year, month);\n		int numberOfDaysInMonth = getNumberOfDaysInMonth(year,month);\n		int  i=0;\n		for(i=0;i&ltstartDay;i++)\n			System.out.print(\"\\t\");\n		for(i = 1;i &lt= numberOfDaysInMonth;i ++){\n			System.out.print(i + \"\\t\");\n			if((i+startDay)%7 == 0)\n				System.out.println();\n		}\n		System.out.println();\n	}\n	//设置起始日期1800/01/01为星期三\n	public static int getStartDay(int year,int month){\n		final int START_DAY_FOR_JAN_1_1800 = 3;\n		int totalNumberOfDays = getTotalNumberOfDays(year,month);\n		return(totalNumberOfDays + START_DAY_FOR_JAN_1_1800)%7;\n	}\n	//计算从1800/01/01至目标日期天数\n	public static int getTotalNumberOfDays(int year,int month){\n		int total = 0;\n		for(int i=1800;i&ltyear;i++)\n			if(isLeapYear(i))\n				total = total+366;\n			else\n				total = total +365;\n			for(int i = 1;i &lt month;i++)\n				total = total + getNumberOfDaysInMonth(year,i);\n			return total;\n		}\n	//定义每月天数\n	public static int getNumberOfDaysInMonth(int year,int month){\n		if(month == 1||month == 3||month == 5||month == 7||month == 8||month == 10||month == 12)\n			return 31;\n		if(month == 4||month == 6||month == 9||month == 11)\n			return 30;\n		if(month ==2)return isLeapYear(year)?29:28;\n		return 0;\n	}\n	//判断平年闰年\n	public static boolean isLeapYear(int year){\n		return year%400 == 0||(year%4 == 0 && year%100 != 0);\n	}\n}</code></pre>', '2017-09-18 13:39:56', 'WuGN', ''),
(52, 'Java基本数据类型', 'admin', NULL, '<style>.marked{background-color:#fff;border-radius:4px;font-weight:bold;}</style>	\n    变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。\n    内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。\n<img src=\"http://oourcagfr.bkt.clouddn.com/201709/java基本数据类型.jpg\">\n    因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。\n    Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 \n<strong>byte：</strong><ul><li>byte数据类型是8位、有符号的，以二进制补码表示的整数；</li><li>最小值是<span class=\"marked\">-128（-2^7）</span>；</li><li>最大值是<span class=\"marked\">127（2^7-1）</span>；</li><li>默认值是<span class=\"marked\">0</span>；</li><li>byte类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一；</li><li>例子：byte a=100，byte b=-50。</li></ul><strong>short：</strong><ul><li>short数据类型是16位、有符号的以二进制补码表示的整数</li><li>最小值是<span class=\"marked\">-32768（-2^15）</span>；</li><li>最大值是<span class=\"marked\">32767（2^15-1）</span>；</li><li>Short数据类型也可以像byte那样节省空间。一个short变量是int型变量所占空间的二分之一；</li><li>默认值是<span class=\"marked\">0</span>；</li><li>例子：short s=1000，short r=-20000。</li></ul><strong>int：</strong><ul><li>int数据类型是32位、有符号的以二进制补码表示的整数；</li><li>最小值是<span class=\"marked\">-2,147,483,648（-2^31）</span>；</li><li>最大值是<span class=\"marked\">2,147,483,647（2^31-1）</span>；</li><li>一般地整型变量默认为int类型；</li><li>默认值是<span class=\"marked\">0</span>；</li><li>例子：int a=100000,int b=-200000。</li></ul><strong>long：</strong><ul><li>long数据类型是64位、有符号的以二进制补码表示的整数；</li><li>最小值是<span class=\"marked\">-9,223,372,036,854,775,808（-2^63）</span>；</li><li>最大值是<span class=\"marked\">9,223,372,036,854,775,807（2^63-1）</span>；</li><li>这种类型主要使用在需要比较大整数的系统上；</li><li>默认值是<span class=\"marked\">0L</span>；</li><li>例子：long a=100000L，Long b=-200000L。<br>\"L\"理论上不分大小写，但是若写成\"l\"容易与数字\"1\"混淆，不容易分辩。所以最好大写。</li></ul><strong>float：</strong><ul><li>float数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li><li>float在储存大型浮点数组的时候可节省内存空间；</li><li>默认值是<span class=\"marked\">0.0f</span>；</li><li>浮点数不能用来表示精确的值，如货币；</li><li>例子：float f1=234.5f。</li></ul><strong>double：</strong><ul><li>double数据类型是双精度、64位、符合IEEE 754标准的浮点数；</li><li>浮点数的默认类型为double类型；</li><li>double类型同样不能表示精确的值，如货币；</li><li>默认值是<span class=\"marked\">0.0d</span>；</li><li>例子：double d1=123.4。</li></ul><strong>boolean：</strong><ul><li>boolean数据类型表示一位的信息；</li><li>只有两个取值：true和false；</li><li>这种类型只作为一种标志来记录true/false情况；</li><li>默认值是<span class=\"marked\">false</span>；</li><li>例子：boolean one=true。</li></ul><strong>char：</strong><ul><li>char类型是一个单一的16位Unicode字符；</li><li>最小值是<span class=\"marked\">\\u0000</span>（即为0）；</li><li>最大值是<span class=\"marked\">\\uffff</span>（即为65,535）；</li><li>char数据类型可以储存任何字符；</li><li>例子：char letter=\'A\';。</li></ul>', '2017-09-20 03:14:08', 'WuGN', ''),
(53, '关于自增', 'admin', NULL, '　　学习过一门计算机语言的人一定知道j=i++的运算结果，整个表达式的值为i，而i的值变为i+1;那么i=i++又是一个什么情况呢？下面分别用 Java 和 C++ 两种语言来做个测试：\n<pre><code>//wugn.java\nclass wugn{\n    public static void main(String[]args){\n        int i=0,j=0;\n        for(;j&lt5;j++){\n            i=i++;\n            System.out.println(\"i=\"+i);\n        }\n    } \n}</code></pre>\n<pre><code>//wugn.cpp\n#include&ltiostream&gt\nusing namespace std;\nint main(){\n    int i=0,j=0;\n    for(;j&lt5;j++){\n        i=i++;\n        cout&lt&lt\"i=\"&lt&lti&lt&ltendl;\n    }\n    system(\"pause\");\n}</code></pre>\n　　你也许会问，这么简单的程序会有什么问题呢？是的，如果不相信的话，你可以运行一下这两个程序，得到的结果非常让人震惊。(左为C++运行结果，右为java运行结果)\n<img src=\"http://oourcagfr.bkt.clouddn.com/201709/java01.png\" />\n　　同样都是i=i++，为什么得出的结果会有这么大的差异呢？原来是在编译器上出了问题，java的编译器在遇到i++和i- -的时候会重新为变量运算分配一块内存空间，以存放原始的值，而在完成了赋值运算之后，将这块内存释放掉，下面首先看一下如果是j=i++的情况：\n<img src=\"http://oourcagfr.bkt.clouddn.com/201709/java01.jpg\" />\n　　i的原始值存放在后开辟的内存中，最后这个值将赋值给j，这样j=i++后，j就会得到i的值，而i又将自加，所以，在释放内存之后，原来存放j和i的地方将得到值将是：j(此时的值等于初始i值)和i(i自加后的值)。\n　　明白了上面的问题，让我们接下来看看i=i++的情况：\n<img src=\"http://oourcagfr.bkt.clouddn.com/201709/java02.jpg\" />\n　　所以这样最后一次循环内的结果仍旧是i(即0)。\n　　而C语言中的i=i++就只是完成i++的内容，所以结论会不同。这种情况说明java和c的处理语法的机制不同，如果在程序中只输入i++就不会出现这个方面的问题，所以大家在以后的程序中如果使用到i=i++的时候要格外小心，一般只需要用i++就不会有问题了。\n', '2017-09-21 03:08:38', 'WuGN', ''),
(54, '纽约时间比加州时间早三个小时', 'admin', NULL, '纽约时间比加州时间早三个小时，\r\nNew York is 3 hours ahead of California,\r\n\r\n但加州时间并没有变慢。\r\nbut it does not make California slow.\r\n\r\n有人22岁就毕业了，\r\nSomeone graduated at the age of 22,\r\n\r\n但等了五年才找到好的工作！\r\nbut waited 5 years before securing a good job!\r\n\r\n有人25岁就当上CEO，\r\nSomeone became a CEO at 25,\r\n\r\n却在50岁去世。\r\nand died at 50.\r\n\r\n也有人迟到50岁才当上CEO，\r\nWhile another became a CEO at 50,\r\n\r\n然后活到90岁。\r\nand lived to 90 years.\r\n\r\n有人依然单身，\r\nSomeone is still single,\r\n\r\n同时也有人已婚。\r\nwhile someone else got married.\r\n\r\n奥巴马55岁就退休，\r\nObama retires at 55,\r\n\r\n川普70岁才开始当总统。\r\nbut Trump starts at 70.\r\n\r\n世上每个人本来就有自己的发展时区。\r\nAbsolutely everyone in this world works based on their Time Zone.\r\n\r\n身边有些人看似走在你前面，\r\nPeople around you might seem to go ahead of you,\r\n\r\n也有人看似走在你后面。\r\nsome might seem to be behind you.\r\n\r\n但其实每个人在自己的时区有自己的步程。\r\nBut everyone is running their own RACE, in their own TIME.\r\n\r\n不用嫉妒或嘲笑他们。\r\nDon’t envy them or mock them.\r\n\r\n他们都在自己的时区里，你也是！\r\nThey are in their TIME ZONE, and you are in yours!\r\n\r\n生命就是等待正确的行动时机。\r\nLife is about waiting for the right moment to act.\r\n\r\n所以，放轻松。\r\nSo, RELAX.\r\n\r\n你没有落后。\r\nYou’re not LATE.\r\n\r\n你没有领先。\r\nYou’re not EARLY.\r\n\r\n在命运为你安排的属于自己的时区里，一切都准时。\r\nYou are very much ON TIME, and in your TIME ZONE Destiny set up for you.', '2017-09-23 16:20:34', 'WuGN', ''),
(55, 'java位运算', 'admin', NULL, '    今天继续自学java，因为以前上过java课程，所以学习的进度很快，各种编程语言有很多想通的地方，就当是复习了。\n\n    今天遇到了一个知识点，java的位运算符。大二上java课时这部分我听得不仔细，也不求甚解。后来学习到了汇编语言，深入的了解了内存中比特位的相关细节。回过头来看java的位运算符便有了新的体验。\n\n    位运算符的操作对象是二进制的0和1，这是一种非常高效但可读性较低的运算方式。\n\n    这里用一段java代码举例来深入了解位运算符。\n<pre><code>class wugn{\n	public static void main(String[]args){\n		System.out.println(6 & 3);\n		System.out.println(6 | 3);\n		System.out.println(6 ^ 3);\n		System.out.println(6 ^ 3 ^ 3);\n		System.out.println(~ 6);\n		System.out.println(16 &gt&gt 3);\n		System.out.println(6 &lt&lt 3);\n		System.out.println(-16 &gt&gt&gt 3 );\n	}\n}</code></pre>\n这八种位运算的运算结果分别是：2, 7, 5, 6, -7, 2, 48, 536870910.\n\n内部运算过程：\n6 & 3 = 2 -&gt 0110 & 0011 -&gt 0010 -&gt 2\n6 | 3 = 7 -&gt 0110 | 0011 -&gt 0111 -&gt 7\n6 ^ 3 = 5 -&gt 0110 ^ 0011 -&gt 0101 -&gt 5\n异或同一数字两次，结果等于本身\n~ 6 = -7 -&gt (0110)6 -&gt (1001)~6 -&gt -(0111)7\n16 &gt&gt 3 -&gt 0001-0000 -&gt 0000-0010 -&gt 2\n6 &lt&lt 3 -&gt 0000-0110 -&gt 0011-0000 -&gt 48\n-16 &gt&gt&gt 3 -&gt (右移三位，高位补0)', '2017-09-24 03:21:47', 'WuGN', ''),
(56, 'Java9新功能', 'admin', NULL, '    在经历了一轮又一轮的跳票，一次又一次的延迟之后，万众期待的Java 9终于来了。JDK 9是自2014年3月之后第一次升级的Java标准版本，从最开始，程序员就对此抱有了极大的热情，如今千呼万唤始出来，我们就一起来看看Java 9有哪些新特性：\n\n<img src=\"http://oourcagfr.bkt.clouddn.com/201709/java9.png\" />\n\n　　<strong>Project Jigsaw — Module System</strong>\n　　Java 9的主要改变是Project Jigsaw的形式，这是一个全新的模块系统。作为Java 9的重要特征，Project Jigsaw在受到关注的同时也避免不了受到diss。这个功能会使JDK、run-time images以及Java 源代码等模块化，甚至开发者还可以创建自己的模块来简化代码。\n　　<strong>JShell</strong>\n　　Java 9中引入了JShell工具，它让很多程序员为之疯狂，为Java平台带来了读入-求值-打印-循环(Read-Eval-Print-Loop，REPL)功能。它的目的在于以即时结果和反馈的形式，简化原型的实现并帮助我们探索语言在编码时的可选项。\n　　<strong>轻量级JSON API</strong>\n　　Java 9中有一个轻量级的API，它支持JSON文档和数据流的生成和使用，在Java 9的主要特性中，这是最值得期待的，同时也是最有望带来性能改进的。\n　　<strong>Process API Changes</strong>\n　　Process API的改进使得Java 9对OS process拥有更好的控制和管理方式。\n　　<strong>Segmented Code Cache</strong>\n　　JDK 9中的代码段在Segmented Code Cache的作用下，可以被更加细分，而且每个代码段还可以包括特定类型的编译代码，这个功能同样也有望提升Java 9性能。\n　　<strong>Ahead of time compilation</strong>\n　　虽然还在实验阶段，但是AOT编译有望提高应用程序的启动时间。\n　　<strong>New HTTP 2 Client</strong>\n　　如果没有新的HTTP客户端来实现HTTP / 2和WebSocket，那么Java 9是不完善的。它将改进Web页面加载时间、提高性能和减少资源使用。\n　　<strong>Parser API for Nashorn</strong>\n　　JDK 9中附带了一个Nashorn的parser API，它的目标是Java在本地JVM中实现轻量级高性能 JS runtime。这个新特性可以保障Java 9更好的融合JavaScript和Java的两方之力。\n\n　　除此之外，Java 9还包含以下特性：\n　　Multi-release JARs\n　　Process API updates\n　　Garbage Collector improvements\n　　Better Javadoc\n　　Stream API improvements\n　　Private interface methods\n\n　　当然，这还只是冰山一角，Java 9的功能集实际要长得多，大家可以去以下地址查看Java 9的完整功能集：<a href=\"https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-9205ABFD-2024-40C8-B01E-A7328BBE4276\" target=\"_blank\">https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-9205ABFD-2024-40C8-B01E-A7328BBE4276</a>。', '2017-09-24 03:32:38', 'WuGN', ''),
(57, '两变量交换的方法(java)', 'admin', NULL, '    在 java 中，想要进行两个变量数值交换有三种方法。\n\n第一种也是最常用的方法是利用第三方变量，临时储存数值。\n<pre><code>class Test{\n    public static void main(String[]args){\n        int x = 5, y = 8;\n        int temp = x;\n        x = y;\n        y = temp;\n        System.out.println(\"x = \"+x+\", y = \"+y);\n    }\n}</code></pre>\n这种方式的好处是简单明了，代码功能一看就懂。\n\n第二种方法是两个数求和然后相减的方式进行数据交换。\n<pre><code>class Test{\n    public static void main(String[]args){\n        int x = 5, y = 8;\n        x = x + y;\n        y = x - y;\n        x = x - y;\n        System.out.println(\"x = \"+x+\", y = \"+y);\n    }\n}</code></pre>\n这种方法的弊端在于如果 x 和 y 的数值过大的话，超出 int 的值会损失精度。\n\n第三种方法是利用位运算符异或运算的方式进行数据的交换\n<pre><code>class Test{\n    public static void main(String[]args){\n        int x = 5, y = 8;\n        x = x ^ y;\n        y = x ^ y;\n        x = x ^ y;\n        System.out.println(\"x = \"+x+\", y = \"+y);\n    }\n}</code></pre>\n这种方法利用的思想原理是：一个数异或同一个数两次，结果还是那个数，而且不会超出 int 范围。\n\n    值得注意的是最后一种方法是直接对数值进行位运算，效率是最高的，但同时代码可读性较低。在实际运用中，还是常常采用第一种方法，低智商的人类还是决定选择牺牲机器的性能换来代码的高可读性。', '2017-09-24 15:47:12', 'WuGN', ''),
(58, 'CDN加速', 'admin', NULL, '　　CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。\n\n　　CDN加速简单的来说，就是把原服务器上数据复制到其他服务器上，用户访问时，那台服务器近访问到的就是那台服务器上的数据。CDN加速优点是成本低，速度快。可以用cdnbest的CDN进行加速，免费，可部署私有，公有cdn系统。可以实现宕机检测，自动切换ip,分线路，分组解析。也就是cdn加速的主要作用就是保证网站的正常访问，及加快网站访问速度和响应速度，防止网站因黑客攻击,DNS解析劫持故障等导致的网站服务器的宕机状况的出现。\n　　\n　　影响cdn加速效果的因素有那些：\n　　\n　　1.CDN主要是靠把网站内容缓存到各个节点服务器，不同地区的访问者可以就近访问，起到加速的效果。所以，理论上来讲：你网站里被缓存的内容越多，效果就越好。\n　　\n　　2.当用户访问一些不能缓存的内容时，CDN节点会临时去你源站获取，此时，如果到你源站的链路不好的话，就会导致这个过程很慢。所以，你源站链路状况也是比较重要的。\n　　\n　　3.还是跟CDN的服务质量有关。包括它的智能调度、CDN节点链路状况等。\n\n    以前，本网站上的font-awesome,bootstrap,jquery都是使用本地主机储存，私以为这样很安全，文件小，对主机影响也不大。现在使用了 bootcss 的CDN加速，直接其引用链接就可以了，也不用在自己的主机上存储相关内容，方便又快捷。曾经我的网站出现过font-awesome与主机兼容性问题，总是在console中报错，引用外链CDN之后，类似这样的问题也就一并避免了。更重要的是，当有人第一次访问网站的时候，如果其浏览器中，缓存过相同链接的信息，就不必再次下载，这样就又大大减少了页面打开时间。\n\n目前引用文件如下：\n<pre><code>&ltlink rel=\"stylesheet\" href=\"https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css\"&gt\n&ltlink href=\"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\" rel=\"stylesheet\"&gt\n&ltscript src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\"&gt&lt/script&gt\n&ltscript src=\"https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js\"&gt&lt/script&gt</code></pre>', '2017-09-26 06:52:50', 'WuGN', ''),
(59, '面向对象编程', 'admin', NULL, '    早期的计算机编程是基于面向过程的方法，通过设计一个算法就可以解决当时的问题。随着计算机技术的不断提高，计算机被用于解决越来越复杂的问题。一切事物皆对象，通过面向对象的方式，将现实世界的事物抽象成对象，现实世界中的关系抽象成类、继承，帮助人们实现对现实世界的抽象与数字建模。通过面向对象的方法，更利于用人理解的方式对复杂系统进行分析、设计与编程。同时，面向对象能有效提高编程的效率，通过封装技术，消息机制可以像搭积木的一样快速开发出一个全新的系统。面向对象是指一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的集合。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。\n\n    面向对象的分析根据抽象关键的问题域来分解系统。面向对象的设计是一种提供符号设计系统的面向对象的实现过程，它用非常接近实际领域术语的方法把系统构造成“现实世界”的对象。面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。\n\n ⑴ <strong>对象唯一性。</strong>\n每个对象都有自身唯一的标识，通过这种标识，可找到相应的对象。在对象的整个生命期中，它的标识都不改变，不同的对象不能有相同的标识。\n ⑵ <strong>抽象性。</strong>\n抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。\n ⑶ <strong>继承性。</strong>\n继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。\n继承性是面向对象程序设计语言不同于其它语言的最重要的特点，是其他语言所没有的。\n在类层次中，子类只继承一个父类的数据结构和方法，则称为单重继承。\n在类层次中，子类继承了多个父类的数据结构和方法，则称为多重继承。\n多重继承，JAVA、VB、NET、Objective-C均仅支持单继承，注意在C++多重继承时，需小心二义性。\n在软件开发中，类的继承性使所建立的软件具有开放性、可扩充性，这是信息组织与分类的行之有效的方法，它简化了对象、类的创建工作量，增加了代码的可重用性。\n采用继承性，提供了类的规范的等级结构。通过类的继承关系，使公共的特性能够共享，提高了软件的重用性。\n ⑷ <strong>多态性（多形性）</strong>\n多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。\n多态性允许每个对象以适合自身的方式去响应共同的消息。\n多态性增强了软件的灵活性和重用性。', '2017-10-02 15:13:55', 'WuGN', '');
INSERT INTO `wu_blog` (`id`, `post_title`, `post_author`, `post_type`, `post_content`, `post_date`, `post_from`, `post_link`) VALUES
(60, '离骚', '先秦·屈原', NULL, '<div class=\"text-center\">帝高阳之苗裔兮，朕皇考曰伯庸。\n摄提贞于孟陬兮，惟庚寅吾以降。\n皇览揆余初度兮，肇锡余以嘉名。\n名余曰正则兮，字余曰灵均。\n纷吾既有此内美兮，又重之以修能。\n扈江离与辟芷兮，纫秋兰以为佩。\n汨余若将不及兮，恐年岁之不吾与。\n朝搴阰之木兰兮，夕揽洲之宿莽。\n日月忽其不淹兮，春与秋其代序。\n唯草木之零落兮，恐美人之迟暮。\n不抚壮而弃秽兮，何不改乎此度？\n乘骐骥以驰骋兮，来吾道夫先路！\n昔三后之纯粹兮，固众芳之所在。\n杂申椒与菌桂兮，岂惟纫夫蕙茞！\n彼尧、舜之耿介兮，既遵道而得路。\n何桀纣之昌披兮，夫惟捷径以窘步。\n惟夫党人之偷乐兮，路幽昧以险隘。\n岂余身之殚殃兮，恐皇舆之败绩。\n忽奔走以先后兮，及前王之踵武。\n荃不查余之中情兮，反信谗而齌怒。\n余固知謇謇之为患兮，忍而不能舍也。\n指九天以为正兮，夫惟灵修之故也。\n曰黄昏以为期兮，羌中道而改路。\n初既与余成言兮，后悔遁而有他。\n余既不难夫离别兮，伤灵修之数化。\n余既滋兰之九畹兮，又树蕙之百亩。\n畦留夷与揭车兮，杂杜衡与芳芷。\n冀枝叶之峻茂兮，愿俟时乎吾将刈。\n虽萎绝其亦何伤兮，哀众芳之芜秽。\n众皆竞进以贪婪兮，凭不厌乎求索。\n羌内恕己以量人兮，各兴心而嫉妒。\n忽驰骛以追逐兮，非余心之所急。\n老冉冉其将至兮，恐修名之不立。\n朝饮木兰之坠露兮，夕餐秋菊之落英。\n苟余情其信姱以练要兮，长顑颔亦何伤。\n掔木根以结茝兮，贯薜荔之落蕊。\n矫菌桂以纫蕙兮，索胡绳之纚纚。\n謇吾法夫前修兮，非世俗之所服。\n虽不周于今之人兮，愿依彭咸之遗则。\n长太息以掩涕兮，哀民生之多艰。\n余虽好修姱以鞿羁兮，謇朝谇而夕替。\n既替余以蕙纕兮，又申之以揽茝。\n亦余心之所善兮，虽九死其犹未悔。\n怨灵修之浩荡兮，终不察夫民心。\n众女嫉余之蛾眉兮，谣诼谓余以善淫。\n固时俗之工巧兮，偭规矩而改错。\n背绳墨以追曲兮，竞周容以为度。\n忳郁邑余侘傺兮，吾独穷困乎此时也。\n宁溘死以流亡兮，余不忍为此态也。\n鸷鸟之不群兮，自前世而固然。\n何方圜之能周兮，夫孰异道而相安？\n屈心而抑志兮，忍尤而攘诟。\n伏清白以死直兮，固前圣之所厚。\n悔相道之不察兮，延伫乎吾将反。\n回朕车以复路兮，及行迷之未远。\n步余马于兰皋兮，驰椒丘且焉止息。\n进不入以离尤兮，退将复修吾初服。\n制芰荷以为衣兮，集芙蓉以为裳。\n不吾知其亦已兮，苟余情其信芳。\n高余冠之岌岌兮，长余佩之陆离。\n芳与泽其杂糅兮，唯昭质其犹未亏。\n忽反顾以游目兮，将往观乎四荒。\n佩缤纷其繁饰兮，芳菲菲其弥章。\n民生各有所乐兮，余独好修以为常。\n虽体解吾犹未变兮，岂余心之可惩。\n女嬃之婵媛兮，申申其詈予。\n曰：“鲧婞直以亡身兮，终然夭乎羽之野。\n汝何博謇而好修兮，纷独有此姱节。\n薋菉葹以盈室兮，判独离而不服。\n众不可户说兮，孰云察余之中情。\n世并举而好朋兮，夫何茕独而不予听？\n依前圣以节中兮，喟凭心而历兹。\n济沅、湘以南征兮，就重华而敶词：\n启《九辩》与《九歌》兮，夏康娱以自纵。\n不顾难以图后兮，五子用失乎家衖。\n羿淫游以佚畋兮，又好射夫封狐。\n固乱流其鲜终兮，浞又贪夫厥家。\n浇身被服强圉兮，纵欲而不忍。\n日康娱而自忘兮，厥首用夫颠陨。\n夏桀之常违兮，乃遂焉而逢殃。\n后辛之菹醢兮，殷宗用而不长。\n汤、禹俨而祗敬兮，周论道而莫差。\n举贤才而授能兮，循绳墨而不颇。\n皇天无私阿兮，览民德焉错辅。\n夫维圣哲以茂行兮，苟得用此下土。\n瞻前而顾后兮，相观民之计极。\n夫孰非义而可用兮？孰非善而可服？\n阽余身而危死兮，览余初其犹未悔。\n不量凿而正枘兮，固前修以菹醢。\n曾歔欷余郁邑兮，哀朕时之不当。\n揽茹蕙以掩涕兮，沾余襟之浪浪。\n跪敷衽以陈辞兮，耿吾既得此中正。\n驷玉虬以桀鹥兮，溘埃风余上征。\n朝发轫于苍梧兮，夕余至乎县圃。\n欲少留此灵琐兮，日忽忽其将暮。\n吾令羲和弭节兮，望崦嵫而勿迫。\n路漫漫其修远兮，吾将上下而求索。\n饮余马于咸池兮，总余辔乎扶桑。\n折若木以拂日兮，聊逍遥以相羊。\n前望舒使先驱兮，后飞廉使奔属。\n鸾皇为余先戒兮，雷师告余以未具。\n吾令凤鸟飞腾兮，继之以日夜。\n飘风屯其相离兮，帅云霓而来御。\n纷总总其离合兮，斑陆离其上下。\n吾令帝阍开关兮，倚阊阖而望予。\n时暧暧其将罢兮，结幽兰而延伫。\n世溷浊而不分兮，好蔽美而嫉妒。\n朝吾将济于白水兮，登阆风而绁马。\n忽反顾以流涕兮，哀高丘之无女。\n溘吾游此春宫兮，折琼枝以继佩。\n及荣华之未落兮，相下女之可诒。\n吾令丰隆乘云兮，求宓妃之所在。\n解佩纕以结言兮，吾令謇修以为理。\n纷总总其离合兮，忽纬繣其难迁。\n夕归次于穷石兮，朝濯发乎洧盘。\n保厥美以骄傲兮，日康娱以淫游。\n虽信美而无礼兮，来违弃而改求。\n览相观于四极兮，周流乎天余乃下。\n望瑶台之偃蹇兮，见有娀之佚女。\n吾令鸩为媒兮，鸩告余以不好。\n雄鸠之鸣逝兮，余犹恶其佻巧。\n心犹豫而狐疑兮，欲自适而不可。\n凤皇既受诒兮，恐高辛之先我。\n欲远集而无所止兮，聊浮游以逍遥。\n及少康之未家兮，留有虞之二姚。\n理弱而媒拙兮，恐导言之不固。\n世溷浊而嫉贤兮，好蔽美而称恶。\n闺中既以邃远兮，哲王又不寤。\n怀朕情而不发兮，余焉能忍而与此终古？\n索琼茅以筳篿兮，命灵氛为余占之。\n曰：“两美其必合兮，孰信修而慕之？\n思九州之博大兮，岂惟是其有女？”\n曰：“勉远逝而无狐疑兮，孰求美而释女？\n何所独无芳草兮，尔何怀乎故宇？”\n世幽昧以昡曜兮，孰云察余之善恶？\n民好恶其不同兮，惟此党人其独异！\n户服艾以盈要兮，谓幽兰其不可佩。\n览察草木其犹未得兮，岂珵美之能当？\n苏粪壤以充祎兮，谓申椒其不芳。\n欲从灵氛之吉占兮，心犹豫而狐疑。\n巫咸将夕降兮，怀椒糈而要之。\n百神翳其备降兮，九疑缤其并迎。\n皇剡剡其扬灵兮，告余以吉故。\n曰：“勉升降以上下兮，求矩矱之所同。\n汤、禹俨而求合兮，挚、咎繇而能调。\n苟中情其好修兮，又何必用夫行媒？\n说操筑于傅岩兮，武丁用而不疑。\n吕望之鼓刀兮，遭周文而得举。\n宁戚之讴歌兮，齐桓闻以该辅。\n及年岁之未晏兮，时亦犹其未央。\n恐鹈鴃之先鸣兮，使夫百草为之不芳。”\n何琼佩之偃蹇兮，众薆然而蔽之。\n惟此党人之不谅兮，恐嫉妒而折之。\n时缤纷其变易兮，又何可以淹留？\n兰芷变而不芳兮，荃蕙化而为茅。\n何昔日之芳草兮，今直为此萧艾也？\n岂其有他故兮，莫好修之害也！\n余以兰为可恃兮，羌无实而容长。\n委厥美以从俗兮，苟得列乎众芳。\n椒专佞以慢慆兮，樧又欲充夫佩帏。\n既干进而务入兮，又何芳之能祗？\n固时俗之流从兮，又孰能无变化？\n览椒兰其若兹兮，又况揭车与江离？\n惟兹佩之可贵兮，委厥美而历兹。\n芳菲菲而难亏兮，芬至今犹未沬。\n和调度以自娱兮，聊浮游而求女。\n及余饰之方壮兮，周流观乎上下。\n灵氛既告余以吉占兮，历吉日乎吾将行。\n折琼枝以为羞兮，精琼爢以为粻。\n为余驾飞龙兮，杂瑶象以为车。\n何离心之可同兮？吾将远逝以自疏。\n邅吾道夫昆仑兮，路修远以周流。\n扬云霓之晻蔼兮，鸣玉鸾之啾啾。\n朝发轫于天津兮，夕余至乎西极。\n凤皇翼其承旗兮，高翱翔之翼翼。\n忽吾行此流沙兮，遵赤水而容与。\n麾蛟龙使梁津兮，诏西皇使涉予。\n路修远以多艰兮，腾众车使径待。\n路不周以左转兮，指西海以为期。\n屯余车其千乘兮，齐玉轪而并驰。\n驾八龙之婉婉兮，载云旗之委蛇。\n抑志而弭节兮，神高驰之邈邈。\n奏《九歌》而舞《韶》兮，聊假日以偷乐。\n陟升皇之赫戏兮，忽临睨夫旧乡。\n仆夫悲余马怀兮，蜷局顾而不行。\n乱曰：已矣哉！\n国无人莫我知兮，又何怀乎故都！\n既莫足与为美政兮，吾将从彭咸之所居！</div>', '2017-10-02 15:20:50', 'WuGN', ''),
(61, '深入浅出JVM', 'admin', NULL, '    深入了解java的底层和运行机制对java的学习有非常大的帮助。\n    所有的程序都必须在内存中运行，JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method)\n    <strong>堆区:</strong> 1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令) \n    2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身\n    <strong>栈区:</strong>1.每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中\n    2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。\n    3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。\n    <strong>方法区:</strong>1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。\n    2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。\n    为了更清楚地搞明白发生在运行时数据区里的黑幕，我们来准备2个小道具（2个非常简单的小程序）。 \n<button class=\"flip btn btn-primary\" type=\"button\">AppMain.java</button>\n<pre><code>//AppMain.java\npublic class AppMain//运行时,jvm把appmain的信息都放入方法区\n{\n    public static void main(String[] args)//main方法本身放入方法区\n    {\n        Sample test1 = new Sample(\"测试1\");//test1是引用,所以放到栈区里,Sample是自定义对象应该放到堆里面\n        Sample test2 = new Sample(\" 测试2 \");\n        test1.printName();\n        test2.printName();\n    }\n}</code></pre>\n<button class=\"flip btn btn-primary\" type=\"button\">Sample.java</button>\n<pre><code>//Sample.java\npublic class Sample//运行时,jvm把appmain的信息都放入方法区\n{\n    /** 范例名称 */\n    private name;//new Sample实例后,name引用放入栈区里,name对象放入堆里\n    /** 构造方法 */\n    public Sample(String name) {\n        this.name = name;\n    }\n    /** 输出 */\n    public void printName()//print方法本身放入方法区里\n    {\n        System.out.println(name);\n    }\n}</code></pre>\n\n    OK，让我们开始行动吧，出发指令就是：\"java AppMain\"，包包里带好我们的行动向导图，Let\'s GO！\n<img src=\"http://oourcagfr.bkt.clouddn.com/201710/JVM运行时数据区.jpg\">\n    系统收到了我们发出的指令，启动了一个Java虚拟机进程，这个进程首先从classpath中找到AppMain.class文件，读取这个文件中的二进制数据，然后把Appmain类的类信息存放到运行时数据区的方法区中。这一过程称为AppMain类的加载过程。\n    接着，Java虚拟机定位到方法区中AppMain类的Main()方法的字节码，开始执行它的指令。这个main()方法的第一条语句就是：\n    Sample test1=new Sample(\"测试1\");\n    语句很简单啦，就是让java虚拟机创建一个Sample实例，并且呢，使引用变量test1引用这个实例。貌似小case一桩哦，就让我们来跟踪一下Java虚拟机，看看它究竟是怎么来执行这个任务的：\n    1、 Java虚拟机一看，不就是建立一个Sample实例吗，简单，于是就直奔方法区而去，先找到Sample类的类型信息再说。结果呢，嘿嘿，没找到@@，这会儿的方法区里还没有Sample类呢。可Java虚拟机也不是一根筋的笨蛋，于是，它发扬“自己动手，丰衣足食”的作风，立马加载了Sample类，把Sample类的类型信息存放在方法区里。\n    2、 好啦，资料找到了，下面就开始干活啦。Java虚拟机做的第一件事情就是在<span style=\"color: red\">堆区中为一个新的Sample实例分配内存, 这个Sample实例持有着指向方法区的Sample类的类型信息的引用。</span>这里所说的引用，<span style=\"color: darkred\">实际上指的是Sample类的类型信息在方法区中的内存地址</span>，其实，就是有点类似于C语言里的指针啦~~，而这个地址呢，就存放了在Sample实例的数据区里。\n    3、 在JAVA虚拟机进程中，每个线程都会拥有一个方法调用栈，用来跟踪线程运行中一系列的方法调用过程，栈中的每一个元素就被称为栈帧，每当线程调用一个方法的时候就会向方法栈压入一个新帧。这里的帧用来存储方法的参数、局部变量和运算过程中的临时数据。OK，原理讲完了，就让我们来继续我们的跟踪行动！位于“=”前的Test1是一个在main()方法中定义的变量，可见，它是一个局部变量，因此，它被会添加到了执行main()方法的主线程的JAVA方法调用栈中。而“=”将把这个test1变量指向堆区中的Sample实例，也就是说，它持有指向Sample实例的引用。\n    OK，到这里为止呢，JAVA虚拟机就完成了这个简单语句的执行任务。参考我们的行动向导图，我们终于初步摸清了JAVA虚拟机的一点点底细了，COOL！\n    接下来，JAVA虚拟机将继续执行后续指令，在堆区里继续创建另一个Sample实例，然后依次执行它们的printName()方法。当JAVA虚拟机执行test1.printName()方法时，JAVA虚拟机根据局部变量test1持有的引用，定位到堆区中的Sample实例，再根据Sample实例持有的引用，定位到方法去中Sample类的类型信息，从而获得printName()方法的字节码，接着执行printName()方法包含的指令。', '2017-10-03 08:37:04', 'WuGN', ''),
(62, 'Java多进程和多线程', 'admin', NULL, '<strong>多进程：</strong>\n	Java编写程序都运行在在Java虚拟机(JVM)中，在JVM的内部，程序的多任务是通过线程来实现的。每用java命令启动一个java应用程序，就会启动一个JVM进程。在同一个JVM进程中，有且只有一个进程，就是它自己。在这个JVM环境中，所有程序代码的运行都是以线程来运行。一个JVM进程对应一个JAVA程序。一个java的应用程序对应于一个JVM实例，当一个java程序运行的时候，一个jvm实例就诞生了，为了验证此说法，以下两个例子加以验证：\n<pre><code>//Test1.java\npublic class Test1 {\n    public static void main(String[] args) throws InterruptedException {\n        while (true) {\n            System.out.println(\"application 1\");\n            Thread.sleep(1000);\n        }\n    }\n}</code></pre><pre><code>//Test2.java\npublic class Test2 {\n    public static void main(String[] args) throws InterruptedException {\n        while (true) {\n            System.out.println(\"application 2\");\n            Thread.sleep(1000);\n        }\n    }\n}</code></pre>\n	我们同时执行两个程序，当两个程序都运行的时候，我们打开windows的任务管理器，我们在程序中可以看到有两个java程序的实例：\n<code>javaw.exe</code>\n<code>javaw.exe</code>\n	当我们结束一个java程序的时候，其中的一个javaw.exe停止消失，说明了，每一个java程序对应一个jvm实例，都有自己的程序执行空间，每一个都有一套jvm虚拟机机制。\n\n<strong>多线程：</strong>\n\n<ul><li>Java线程的实现<ul><li>Thread类和大部分的java API有显著的差别，它关键方法声明为native的，这意味着该方法没有或者无法使用平台无关的手段来实现！</li><li>上面的问题表明，java线程的实现是依赖于线程的实现（操作系统）；虚拟机只是将java的线程最终映射到操作系统的线程模型中，通过后者完成具体实现</li><li>操作系统支持什么样的线程模型很大程度上决定了Java虚拟机的线程是怎么映射的</li></ul></li>\n<li>线程的实现（操作系统）主要有3种方式：内核线程实现、用户线程实现、用户线程加轻量级进程实现</li>\n<li>内核线程(KLT)：(1:1)<ul><li>直接由操作系统内核支持的线程，内核通过操纵调度器将线程的任务映射到各个处理器上</li><li>程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（LWP），即平时所说的线程</li><li>轻量级进程和内核线程是一种一对一的线程模型</li><li>缺点：系统调用代价高，因为需要在用户态和内核态之间来回切换；轻量级进程数量有限，因为LWP和内核线程是一对一的关系</li></ul></li>\n<li>用户线程(UT)(N:1)<ul><li>将线程的各种问题全部交给用户来解决，而且有时候无法通过代码解决一些问题；该实现基本已经被淘汰了</li></ul></li>\n<li>用户线程and LWP(N:M)<ul><li>即上面的结合体；</li><li>具备了用户线程的：系统调度代价低，支持大规模用户线程并发的功能</li><li>有具备了内核线程：任务调用，解决线程间阻塞问题</li><li>评价：可以说是一种比较折衷的方法</li></ul></li></ul>\n<img src=\"http://oourcagfr.bkt.clouddn.com/201710/Uthread.jpg\">', '2017-10-07 13:49:28', 'WuGN', ''),
(63, 'Bootstrap响应式工具', 'admin', NULL, '	Bootstrap 提供了一些辅助类，以便更快地实现对移动设备友好的开发。这些可以通过媒体查询结合大型、小型和中型设备，实现内容对设备的显示和隐藏。\n	需要谨慎使用这些工具，避免在同一个站点创建完全不同的版本。<strong>响应式实用工具目前只适用于块和表切换。</strong>\n<div class=\"table-responsive\"><table class=\"table table-striped table-condensed table-hover\"><thead><tr><th></th><th>超小屏幕<br />手机(&lt;768px)</th><th>小屏幕<br />平板(≥768px)</th><th>中等屏幕<br />桌面(≥992px)</th><th>大屏幕<br />桌面(≥1200px)</th></tr></thead><tbody><tr><td>.visible-xs-*</td><td>可见</td><td>隐藏</td><td>隐藏</td><td>隐藏</td></tr><tr><td>.visible-sm-*</td><td>隐藏</td><td>可见</td><td>隐藏</td><td>隐藏</td></tr><tr><td>.visible-md-*</td><td>隐藏</td><td>隐藏</td><td>可见</td><td>隐藏</td></tr><tr><td>.visible-lg-*</td><td>隐藏</td><td>隐藏</td><td>隐藏</td><td>可见</td></tr></tbody><tbody><tr><td>.hidden-xs</td><td>隐藏</td><td>可见</td><td>可见</td><td>可见</td></tr><tr><td>.hidden-sm</td><td>可见</td><td>隐藏</td><td>可见</td><td>可见</td></tr><tr><td>.hidden-md</td><td>可见</td><td>可见</td><td>隐藏</td><td>可见</td></tr><tr><td>.hidden-lg</td><td>可见</td><td>可见</td><td>可见</td><td>隐藏</td></tr></tbody></table></div>	从 v3.2.0 版本起，形如 .visible-*-* 的类针对每种屏幕大小都有了三种变体，每个针对 CSS 中不同的 display 属性，列表如下：\n<div class=\"table-responsive\"><table class=\"table table-striped table-condensed table-hover\"><thead><tr><th>类组</th><th>CSS display</th></tr></thead><tbody><tr><td>.visible-*-block</td><td>display:block;</td></tr><tr><td>.visible-*-inline</td><td>display:inline;</td></tr><tr><td>.visible-*-inline-block</td><td>display:inline-block;</td></tr></tbody></table></div>	因此，以超小屏幕（xs）为例，可用的 .visible-*-* 类是：.visible-xs-block、.visible-xs-inline 和 .visible-xs-inline-block。\n	.visible-xs、.visible-sm、.visible-md 和 .visible-lg 类也同时存在。但是从 v3.2.0 版本开始不再建议使用。除了 &lt;table&gt; 相关的元素的特殊情况外，它们与 .visible-*-block 大体相同。\n<strong>打印类：</strong>\n	下表列出了打印类。使用这些切换打印内容。\n<div class=\"table-responsive\"><table class=\"table table-striped table-condensed table-hover\"><thead><tr><th>class</th><th>浏览器</th><th>打印机</th></tr></thead><tbody><tr><td>.visible-print-block<br />.visible-print-inline<br />.visible-print-inline-block</td><td class=\"is-hidden\">隐藏</td><td>可见</td></tr><tr><td>.hidden-print</td><td>可见</td><td class=\"is-hidden\">隐藏</td></tr></tbody></table></div><strong>实例：</strong>\n	下面的实例演示了上面所列举的帮助器类的用法。调整浏览器的窗口大小，或者在不同的设备上加载实例，测试响应式实用工具类。\n<pre><code>&lt;div class=\"container\" style=\"padding: 40px;\"&gt;\n    &lt;div class=\"row visible-on\"&gt;\n        &lt;div class=\"col-xs-6 col-sm-3\" style=\"background-color: #dedef8;\n        box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;\"&gt;\n            &lt;span class=\"hidden-xs\"&gt;特别小型&lt;/span&gt;\n            &lt;span class=\"visible-xs\"&gt;在特别小型设备上可见&lt;/span&gt;\n        &lt;/div&gt;\n        &lt;div class=\"col-xs-6 col-sm-3\" style=\"background-color: #dedef8;\n        box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;\"&gt;\n            &lt;span class=\"hidden-sm\"&gt;小型&lt;/span&gt;\n            &lt;span class=\"visible-sm\"&gt;在小型设备上可见&lt;/span&gt;\n        &lt;/div&gt;\n        &lt;div class=\"clearfix visible-xs\"&gt;&lt;/div&gt;\n        &lt;div class=\"col-xs-6 col-sm-3\" style=\"background-color: #dedef8;\n        box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;\"&gt;\n            &lt;span class=\"hidden-md\"&gt;中型&lt;/span&gt;\n            &lt;span class=\"visible-md\"&gt;在中型设备上可见&lt;/span&gt;\n        &lt;/div&gt;\n        &lt;div class=\"col-xs-6 col-sm-3\" style=\"background-color: #dedef8;\n        box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;\"&gt;\n            &lt;span class=\"hidden-lg\"&gt;大型&lt;/span&gt;\n            &lt;span class=\"visible-lg\"&gt;在大型设备上可见&lt;/span&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;</code></pre>\n<div class=\"container\"style=\"padding: 40px;\"><div class=\"row visible-on\"><div class=\"col-xs-6 col-sm-3\"style=\"background-color: #dedef8;box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;\"><span class=\"hidden-xs\">特别小型</span><span class=\"visible-xs\">在特别小型设备上可见</span></div><div class=\"col-xs-6 col-sm-3\"style=\"background-color: #dedef8;box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;\"><span class=\"hidden-sm\">小型</span><span class=\"visible-sm\">在小型设备上可见</span></div><div class=\"clearfix visible-xs\"></div><div class=\"col-xs-6 col-sm-3\"style=\"background-color: #dedef8;box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;\"><span class=\"hidden-md\">中型</span><span class=\"visible-md\">在中型设备上可见</span></div><div class=\"col-xs-6 col-sm-3\"style=\"background-color: #dedef8;box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;\"><span class=\"hidden-lg\">大型</span><span class=\"visible-lg\">在大型设备上可见</span></div></div></div>', '2017-10-10 02:25:34', 'WuGN', ''),
(64, 'How to use highlight.js', 'admin', NULL, '<h3>Getting Started</h3>\nThe bare minimum for using highlight.js on a web page is linking to the library along with one of the styles and calling <a href=\"http://highlightjs.readthedocs.io/en/latest/api.html#inithighlightingonload\"><code>initHighlightingOnLoad</code></a>:\n<pre><code class=\"html\">&lt;link rel=&quot;stylesheet&quot; href=&quot;/path/to/styles/default.css&quot;&gt;\n&lt;script src=&quot;/path/to/highlight.pack.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;</code></pre>This will find and highlight code inside of <code>&lt;pre&gt;&lt;code&gt;</code> tags; it tries to detect the language automatically. If automatic detection doesn’t work for you, you can specify the language in the <code>class</code> attribute:\n<pre><code class=\"html\">&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;...&lt;/code&gt;&lt;/pre&gt;</code></pre>The list of supported language classes is available in the <a href=\"http://highlightjs.readthedocs.io/en/latest/css-classes-reference.html\">class reference</a>.  Classes can also be prefixed with either <code>language-</code> or <code>lang-</code>. To disable highlighting altogether use the <code>nohighlight</code> class:\n<pre><code class=\"html\">&lt;pre&gt;&lt;code class=&quot;nohighlight&quot;&gt;...&lt;/code&gt;&lt;/pre&gt;</code></pre><h3>Custom Initialization</h3>\nWhen you need a bit more control over the initialization of highlight.js, you can use the <a href=\"http://highlightjs.readthedocs.io/en/latest/api.html#highlightblock-block\"><code>highlightBlock</code></a> and <a href=\"http://highlightjs.readthedocs.io/en/latest/api.html#configure-options\"><code>configure</code></a> functions. This allows you to control <em>what</em> to highlight and <em>when</em>. Here’s an equivalent way to calling <a href=\"http://highlightjs.readthedocs.io/en/latest/api.html#inithighlightingonload\"><code>initHighlightingOnLoad</code></a> using jQuery:<pre><code class=\"javascript\">$(document).ready(function() {\n    $(&#39;pre code&#39;).each(function(i, block) {\n        hljs.highlightBlock(block);\n    });\n});</code></pre>You can use any tags instead of <code>&lt;pre&gt;&lt;code&gt;</code> to mark up your code. If you don\'t use a container that preserve line breaks you will need to configure highlight.js to use the <code>&lt;br&gt;</code> tag:\n<pre><code class=\"javascript\">hljs.configure({useBR: true});\n$(&#39;div.code&#39;).each(function(i, block) {\n    hljs.highlightBlock(block);\n});</code></pre>For other options refer to the documentation for <a href=\"http://highlightjs.readthedocs.io/en/latest/api.html#configure-options\"><code>configure</code></a>.\n<h3>Web Workers</h3>\nYou can run highlighting inside a web worker to avoid freezing the browser window while dealing with very big chunks of code. In your main script:\n<pre><code class=\"javascript\">addEventListener(&#39;load&#39;, function() {\n    var code = document.querySelector(&#39;#code&#39;);\n    var worker = new Worker(&#39;worker.js&#39;);\n    worker.onmessage = function(event) { code.innerHTML = event.data; }\n    worker.postMessage(code.textContent);\n})</code></pre>In worker.js:\n<pre><code class=\"javascript\">onmessage = function(event) {\n    importScripts(&#39;&lt;path&gt;/highlight.pack.js&#39;);\n    var result = self.hljs.highlightAuto(event.data);\n    postMessage(result.value);\n}</code></pre><h3>Getting the Library</h3>\nYou can get highlight.js as a hosted, or custom-build, browser script or as a server module. Right out of the box the browser script supports both AMD and CommonJS, so if you wish you can use RequireJS or Browserify without having to build from source. The server module also works perfectly fine with Browserify, but there is the option to use a build specific to browsers rather than something meant for a server. Head over to the <a href=\"https://highlightjs.org/download/\">download page</a> for all the options. <strong>Don\'t link to GitHub directly.</strong> The library is not supposed to work straight from the source, it requires building. If none of the pre-packaged options work for you refer to the <a href=\"http://highlightjs.readthedocs.io/en/latest/building-testing.html\">building documentation</a>. <strong>The CDN-hosted package doesn\'t have all the languages.</strong> Otherwise it\'d be too big. If you don\'t see the language you need in the <a href=\"https://highlightjs.org/download/\">\"Common\" section</a>, it can be added manually:\n<pre><code class=\"html\">&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/go.min.js&quot;&gt;&lt;/script&gt;</code></pre><strong>On Almond.</strong> You need to use the optimizer to give the module a name. For example:\n<code>r.js -o name=hljs paths.hljs=/path/to/highlight out=highlight.js</code>\n<h3>License</h3>\nHighlight.js is released under the BSD License. See <a href=\"https://github.com/isagalaev/highlight.js/blob/master/LICENSE\">LICENSE</a> file for details.\n<h3>Links</h3>\nThe official site for the library is at <a href=\"https://highlightjs.org/\">https://highlightjs.org/</a>. Further in-depth documentation for the API and other topics is at <a href=\"http://highlightjs.readthedocs.io/\">http://highlightjs.readthedocs.io/</a>. Authors and contributors are listed in the <a href=\"https://github.com/isagalaev/highlight.js/blob/master/AUTHORS.en.txt\">AUTHORS.en.txt</a> file.', '2017-10-11 05:39:11', 'WuGN', ''),
(65, 'canvas入门:1', 'admin', NULL, '<pre><code>&lt;canvas id=\"myCanvas\" width=\"150\" height=\"150\"&gt;&lt;/canvas&gt;</code></pre>\n	HTML5<code>&lt;canvas&gt;</code>元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成.<code>&lt;canvas&gt;</code>标签只是图形容器，必须使用脚本来绘制图形。可以通过多种方法使用Canva绘制路径,盒、圆、字符以及添加图像。\n\n	<code>&lt;canvas&gt;</code>看起来<code>&lt;img&gt;</code>元素很相像，唯一的不同就是它并没有 src 和 alt 属性。实际上，<code>&lt;canvas&gt;</code>标签只有两个属性——<code>width</code>和<code>height</code>。这些都是可选的，并且同样利用 DOM <code>properties</code>来设置。当没有设置宽度和高度的时候，canvas会初始化宽度为300像素和高度为150像素。该元素可以使用CSS来定义大小，但在绘制时图像会伸缩以适应它的框架尺寸：如果CSS的尺寸与初始画布的比例不一致，它会出现扭曲。\n<canvas id=\"myCanvas1\" width=\"250\" height=\"150\" style=\"border:1px solid #ddd\">您的浏览器不支持 HTML5 canvas 标签。</canvas>\n<button class=\"flip\" type=\"button\">myCanvas1</button>\n<pre><code>&lt;canvas id=\"myCanvas1\" width=\"250\" height=\"150\" style=\"border:1px solid #ddd\"&gt;您的浏览器不支持 HTML5 canvas 标签。&lt;/canvas&gt;\n\n&lt;script&gt;\nvar ctx=document.getElementById(\"myCanvas1\").getContext(\"2d\");\n\n//方块\nctx.fillStyle=\"#f00\";\nctx.fillRect(10,10,50,60);\n\n//直线\nctx.moveTo(80,5);\nctx.lineTo(150,50);\nctx.stroke();\n\n//圆\nctx.beginPath();\nctx.arc(200,40,30,0,1.5*Math.PI,false);\nctx.stroke();\n\n//文字\nctx.font=\"30px Arial\";\nctx.fillStyle=\"#0f0\";\nctx.strokeText(\"Hello\",10,50);\nctx.fillText(\"World\",80,50);\n\n//渐变\nvar grd=ctx.createLinearGradient(0,50,100,200);\ngrd.addColorStop(0.2,\"#00f\");\ngrd.addColorStop(1,\"#fff\");\nctx.fillStyle=grd;\nctx.fillRect(10,80,80,60);\n\n//渐变圆\nvar grd=ctx.createRadialGradient(140,100,3,180,100,80);\ngrd.addColorStop(0,\"#000\");\ngrd.addColorStop(1,\"#ff0\");\nctx.fillStyle=grd;\nctx.fillRect(120,80,80,60);\n&lt;/script&gt;</code></pre>\n<canvas id=\"myCanvas2\" width=\"200\" height=\"100\" style=\"border:1px solid #ddd\">您的浏览器不支持 HTML5 canvas 标签。</canvas>\n<button class=\"flip\" type=\"button\">myCanvas2</button>\n<pre><code>&lt;canvas id=\"myCanvas2\" width=\"200\" height=\"100\" style=\"border:1px solid #ddd\"&gt;您的浏览器不支持 HTML5 canvas 标签。&lt;/canvas&gt;\n\n&lt;script&gt;\nvar ctx = document.getElementById(\"myCanvas2\").getContext(\"2d\");\n\n//透明\nctx.fillStyle=\"rgba(200,0,0,0.8)\";\nctx.fillRect(10,10,50,50);\nctx.fillStyle=\"rgba(0,0,200,0.5)\";\nctx.fillRect(40,40,50,50);\n\n//清除\nctx.fillStyle=\"#000\";\nctx.clearRect(55,20,40,40);//清除\nctx.strokeRect(60,25,30,30);//边框\n\n//三角\nctx.fillStyle=\"#0f0\";\nctx.beginPath();\nctx.moveTo(100,50);\nctx.lineTo(140,50);\nctx.lineTo(110,80);\nctx.lineTo(120,30);\nctx.lineTo(130,80);\nctx.fill();\nctx.stroke();\n\n//笑脸\nctx.fillStyle=\"#000\";\nctx.beginPath();\nctx.arc(170,50,30,0,Math.PI*2);//绘制\nctx.moveTo(155,60);\nctx.arc(170,50,20,0.5,Math.PI*0.8,false);//口(顺时针)\nctx.moveTo(155,45);\nctx.arc(155,45,5,0,Math.PI*2);//左眼\nctx.moveTo(185,45);\nctx.arc(185,45,5,0,Math.PI*2);//右眼\nctx.stroke();\n&lt;/script&gt;</code></pre><script>\nvar ctx=document.getElementById(\"myCanvas1\").getContext(\"2d\");\n\n//方块\nctx.fillStyle=\"#f00\";\nctx.fillRect(10,10,50,60);\n\n//直线\nctx.moveTo(80,5);\nctx.lineTo(150,50);\nctx.stroke();\n\n//圆\nctx.beginPath();\nctx.arc(200,40,30,0,1.5*Math.PI,false);\nctx.stroke();\n\n//文字\nctx.font=\"30px Arial\";\nctx.fillStyle=\"#0f0\";\nctx.strokeText(\"Hello\",10,50);\nctx.fillText(\"World\",80,50);\n\n//渐变\nvar grd=ctx.createLinearGradient(0,50,100,200);\ngrd.addColorStop(0.2,\"#00f\");\ngrd.addColorStop(1,\"#fff\");\nctx.fillStyle=grd;\nctx.fillRect(10,80,80,60);\n\n//渐变圆\nvar grd=ctx.createRadialGradient(140,100,3,180,100,80);\ngrd.addColorStop(0,\"#000\");\ngrd.addColorStop(1,\"#ff0\");\nctx.fillStyle=grd;\nctx.fillRect(120,80,80,60);\n</script>\n<script>\nvar ctx = document.getElementById(\"myCanvas2\").getContext(\"2d\");\n\n//透明\nctx.fillStyle=\"rgba(200,0,0,0.8)\";\nctx.fillRect(10,10,50,50);\nctx.fillStyle=\"rgba(0,0,200,0.5)\";\nctx.fillRect(40,40,50,50);\n\n//清除\nctx.fillStyle=\"#000\";\nctx.clearRect(55,20,40,40);//清除\nctx.strokeRect(60,25,30,30);//边框\n\n//三角\nctx.fillStyle=\"#0f0\";\nctx.beginPath();\nctx.moveTo(100,50);\nctx.lineTo(140,50);\nctx.lineTo(110,80);\nctx.lineTo(120,30);\nctx.lineTo(130,80);\nctx.fill();\nctx.stroke();\n\n//笑脸\nctx.fillStyle=\"#000\";\nctx.beginPath();\nctx.arc(170,50,30,0,Math.PI*2);//绘制\nctx.moveTo(155,60);\nctx.arc(170,50,20,0.5,Math.PI*0.8,false);//口(顺时针)\nctx.moveTo(155,45);\nctx.arc(155,45,5,0,Math.PI*2);//左眼\nctx.moveTo(185,45);\nctx.arc(185,45,5,0,Math.PI*2);//右眼\nctx.stroke();\n</script>', '2017-10-14 02:17:06', 'WuGN', ''),
(66, 'Table cloths', 'githubphagocyte', NULL, '&emsp;&emsp;用三段 140 字符以内的代码生成一张 1024×1024 的图片。\n\n&emsp;&emsp;Kyle McCormick 在 StackExchange 上发起了一个叫做 Tweetable Mathematical Art 的比赛，参赛者需要用三条推这么长的代码来生成一张图片。具体地说，参赛者需要用 C++ 语言编写 RD 、 GR 、 BL 三个函数，每个函数都不能超过 140 个字符。每个函数都会接到 i 和 j 两个整型参数（0 ≤ i, j ≤ 1023），然后需要返回一个 0 到 255 之间的整数，表示位于 (i, j) 的像素点的颜色值。举个例子，如果 RD(0, 0) 和 GR(0, 0) 返回的都是 0 ，但 BL(0, 0) 返回的是 255 ，那么图像的最左上角那个像素就是蓝色。参赛者编写的代码会被插进下面这段程序当中，最终会生成一个大小为 1024×1024 的图片。\n<pre><code>// NOTE: compile with g++ filename.cpp -std=c++11\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdlib&gt;\n#define DIM 1024\n#define DM1 (DIM-1)\n#define _sq(x) ((x)*(x)) // square\n#define _cb(x) abs((x)*(x)*(x)) // absolute value of cube\n#define _cr(x) (unsigned char)(pow((x),1.0/3.0)) // cube root\n\nunsigned char GR(int,int);\nunsigned char BL(int,int);\n\nunsigned char RD(int i,int j){\n    // YOUR CODE HERE\n}\nunsigned char GR(int i,int j){\n    // YOUR CODE HERE\n}\nunsigned char BL(int i,int j){\n    // YOUR CODE HERE\n}\n\nvoid pixel_write(int,int);\nFILE *fp;\nint main(){\n    fp = fopen(\"MathPic.ppm\",\"wb\");\n    fprintf(fp, \"P6\\n%d %d\\n255\\n\", DIM, DIM);\n    for(int j=0;j&lt;DIM;j++)\n    for(int i=0;i&lt;DIM;i++)\n    pixel_write(i,j);\n    fclose(fp);\n    return 0;\n}\nvoid pixel_write(int i, int j){\n    static unsigned char color[3];\n    color[0] = RD(i,j);\n    color[1] = GR(i,j);\n    color[2] = BL(i,j);\n    fwrite(color, 1, 3, fp);\n}</code></pre><h3>Flat</h3>I started out putting a plaid/gingham pattern into perspective like a boundless table cloth:\n<pre><code>unsigned char RD(int i,int j){\n    float s=3./(j+99);\n    return (int((i+DIM)*s+j*s)%2+int((DIM*2-i)*s+j*s)%2)*127;\n}\nunsigned char GR(int i,int j){\n    float s=3./(j+99);\n    return (int((i+DIM)*s+j*s)%2+int((DIM*2-i)*s+j*s)%2)*127;\n}\nunsigned char BL(int i,int j){\n    float s=3./(j+99);\n    return (int((i+DIM)*s+j*s)%2+int((DIM*2-i)*s+j*s)%2)*127;\n}\n</code></pre><img src=\"http://oourcagfr.bkt.clouddn.com/201711/TableCloths1.png\" alt=\"flat table cloth\" title=\"flat table cloth\">\n<h3>Ripple</h3>Then I introduced a ripple (not strictly correct perspective, but still in 140 characters):\n<pre><code>unsigned char RD(int i,int j){\n    float s=3./(j+99);\n    float y=(j+sin((i*i+_sq(j-700)*5)/100./DIM)*35)*s;\n    return (int((i+DIM)*s+y)%2+int((DIM*2-i)*s+y)%2)*127;\n}\nunsigned char GR(int i,int j){\n    float s=3./(j+99);\n    float y=(j+sin((i*i+_sq(j-700)*5)/100./DIM)*35)*s;\n    return (int((i+DIM)*s+y)%2+int((DIM*2-i)*s+y)%2)*127;\n}\nunsigned char BL(int i,int j){\n    float s=3./(j+99);\n    float y=(j+sin((i*i+_sq(j-700)*5)/100./DIM)*35)*s;\n    return (int((i+DIM)*s+y)%2+int((DIM*2-i)*s+y)%2)*127;\n}\n</code></pre><img src=\"http://oourcagfr.bkt.clouddn.com/201711/TableCloths2.png\" alt=\"rippled table cloth\" title=\"rippled table cloth\">\n<h3>Colour</h3>Then I made some of the colours more fine grained to give detail on a wider range of scales, and to make the picture more colourful...\n<pre><code>unsigned char RD(int i,int j){\n    float s=3./(j+99);\n    float y=(j+sin((i*i+_sq(j-700)*5)/100./DIM)*35)*s;\n    return (int((i+DIM)*s+y)%2+int((DIM*2-i)*s+y)%2)*127;\n}\nunsigned char GR(int i,int j){\n    float s=3./(j+99);\n    float y=(j+sin((i*i+_sq(j-700)*5)/100./DIM)*35)*s;\n    return (int(5*((i+DIM)*s+y))%2+int(5*((DIM*2-i)*s+y))%2)*127;\n}\nunsigned char BL(int i,int j){\n    float s=3./(j+99);\n    float y=(j+sin((i*i+_sq(j-700)*5)/100./DIM)*35)*s;\n    return (int(29*((i+DIM)*s+y))%2+int(29*((DIM*2-i)*s+y))%2)*127;\n}\n</code></pre><img src=\"http://oourcagfr.bkt.clouddn.com/201711/TableCloths3.png\" alt=\"coloured table cloth\" title=\"coloured table cloth\">\n<h3>In motion</h3>Reducing the code just slightly more allows for defining a wave phase P with 2 decimal places, which is just enough for frames close enough for smooth animation. I\'ve reduced the amplitude at this stage to avoid inducing sea sickness, and shifted the whole image up a further 151 pixels (at the cost of 1 extra character) to push the aliasing off the top of the image. Animated aliasing is mesmerising.\n<pre><code>unsigned char RD(int i,int j){\n#define P 6.03\nfloat s=3./(j+250),y=(j+sin((i*i+_sq(j-700)*5)/100./DIM+P)*15)*s;return (int((i+DIM)*s+y)%2+int((DIM*2-i)*s+y)%2)*127;}\n\nunsigned char GR(int i,int j){\nfloat s=3./(j+250);\nfloat y=(j+sin((i*i+_sq(j-700)*5)/100./DIM+P)*15)*s;\nreturn (int(5*((i+DIM)*s+y))%2+int(5*((DIM*2-i)*s+y))%2)*127;}\n\nunsigned char BL(int i,int j){\nfloat s=3./(j+250);\nfloat y=(j+sin((i*i+_sq(j-700)*5)/100./DIM+P)*15)*s;\nreturn (int(29*((i+DIM)*s+y))%2+int(29*((DIM*2-i)*s+y))%2)*127;}\n</code></pre><img src=\"http://oourcagfr.bkt.clouddn.com/201711/TableCloths4.gif\" alt=\"animated table cloth\" title=\"animated table cloth\">', '2017-11-06 06:39:41', 'WuGN', ''),
(67, 'Initialization', 'admin', 'SQL', 'CREATE TABLE `think_wgndb` (\n  `id` bigint(20) UNSIGNED PRIMARY KEY NOT NULL,\n  `post_title` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \'文章标题\',\n  `post_author` varchar(64) NOT NULL DEFAULT \'佚名\' COMMENT \'文章作者\',\n  `post_type` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci COMMENT \'文章分类\',\n  `post_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT \'文章内容\',\n  `post_date` datetime NOT NULL DEFAULT \'0000-00-00 00:00:00\' COMMENT \'发布日期\',\n  `post_from` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT \'\' COMMENT \'文章来源\',\n  `post_link` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT \'\' COMMENT \'原链接\'\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=\'来自浏览历史\';\n', '2018-01-01 23:27:00', 'initialization', 'http://127.0.0.1:88/2/ThinkPHP_3.1.3_full/Wuguangnuo/1'),
(68, '如何理解汉诺塔的递归？', '酱紫君', 'Math', '我做了个动画三个盘子的汉诺塔你总会吧:\n<img src=\"https://pic1.zhimg.com/50/v2-64e912ac46acca5b5114052d2e7aaf2e_hd.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"460\" data-rawheight=\"120\" data-thumbnail=\"https://pic1.zhimg.com/50/v2-64e912ac46acca5b5114052d2e7aaf2e_hd.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"460\" data-original=\"https://pic1.zhimg.com/v2-64e912ac46acca5b5114052d2e7aaf2e_r.jpg\">\n然后你移完发现左边柱子下面又蹦出来一个盘子\n<img src=\"https://pic4.zhimg.com/50/v2-ec71f2250c4c1f432e7e5c801f8eb0bf_hd.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"460\" data-rawheight=\"120\" class=\"origin_image zh-lightbox-thumb\" width=\"460\" data-original=\"https://pic4.zhimg.com/v2-ec71f2250c4c1f432e7e5c801f8eb0bf_r.jpg\">\n好吧, 那就把中间的柱子看成目标柱\n<img src=\"https://pic2.zhimg.com/50/v2-77f7888545bc94292253725fd5033bad_hd.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"460\" data-rawheight=\"120\" data-thumbnail=\"https://pic2.zhimg.com/50/v2-77f7888545bc94292253725fd5033bad_hd.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"460\" data-original=\"https://pic2.zhimg.com/v2-77f7888545bc94292253725fd5033bad_r.jpg\">\n然后把最大的移到右边, 然后就和搬三个一模一样了更多的话也是一样的...所以 所以说一共就三步把 n-1 号盘子移动到缓冲区把1号从起点移到终点然后把缓冲区的n-1号盘子也移到终点所以写成py代码就是<pre><code>def move(n,from,buffer,to):\n    if n==1:\n        print(\'Move\',n,\'from\',from,\'to\',to)\n    else:\n        move(n-1,from,to,buffer)\n        move(1,from,buffer,to)\n        move(n-1,buffer,from,to)</code></pre><ol><li>要从a到b 那c就是缓冲 move(n-1,from,to,buffer)</li><li>要从a到c 那b就是缓冲 move(1,from,buffer,to)</li><li>要从b到c 那a就是缓冲 move(n-1,buffer,from,to)</li></ol>毫无理解难度啊...C++那不一样的吗<pre><code>using namespace std;\n#include <iostream>\n#include <cstdio>\n\nvoid move (int n, char from, char buffer, char to){\n    if (n == 1) {\n        cout << \"Move\" << n << \" from \" << from << \" to \" << to << endl;\n    }\n    else {\n        move (n-1, from, to, buffer);\n        move (1, from, buffer, to);\n        move (n-1, buffer, from, to);\n    }\n}\n\n//别打我, 我习惯不换行了, 反正现在有格式化工具......\n//main()你自己写吧</code></pre>Mathematica的话...我会直接Fold一个迭代器迭代器会自己去找合适的缓冲区...这就是 Frame - Stewart 算法\n<img src=\"https://pic3.zhimg.com/50/v2-b23cdde1fc9583580e79ceedb82bd0ad_hd.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"199\" class=\"origin_image zh-lightbox-thumb\" width=\"567\" data-original=\"https://pic3.zhimg.com/v2-b23cdde1fc9583580e79ceedb82bd0ad_r.jpg\">\n不过讲道理这么写挺欠揍的...谁?给我 pull 这种代码我直接打上去了2333\n<img src=\"https://pic1.zhimg.com/50/v2-a113eef84d237baf8dbbc481830098fe_hd.gif\" data-size=\"normal\" data-rawwidth=\"460\" data-rawheight=\"120\" data-thumbnail=\"https://pic1.zhimg.com/50/v2-a113eef84d237baf8dbbc481830098fe_hd.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"460\" data-original=\"https://pic1.zhimg.com/v2-a113eef84d237baf8dbbc481830098fe_r.jpg\">\n话说这个可视化我画了4个小时...<pre><code>Get[\"https://raw.githubusercontent.com/GalAster/Deus/master/Packages/_\\\n_Raw/HanoiTower.wl\", CharacterEncoding -> \"UTF8\"]\nHanoiShow@HanoiMove[10, Pillar -> 5] // ListAnimate</code></pre>', '2018-02-21 21:18:00', '知乎', 'https://www.zhihu.com/question/24385418'),
(69, 'JavaScript算法实现之汉诺塔（Hanoi）', 'Groove明阳', 'JS', '目前前端新手，看到的不喜勿喷，还望大神指教。\n\n随着Node.js，Angular.js,JQuery的流行，点燃了我学习JavaScript的热情！以后打算每天早上跟晚上抽2小时左右时间将经典的算法都用JS来实现，加快学习JS的步伐（用这个办法方便跟自己以前学过的C++语言作对比，找出不同），希望自己能够坚持下去！！！\n\n首先来个汉诺塔的。\n<pre><code>\n<script>\n      function hanoi(n,a,b,c){\n          if(n==1){\n              document.write(\"Move \"+n+\" from \"+a+\" to \"+c+\"</br>\");\n          }\n          else{\n              hanoi(n-1,a,c,b);\n              document.write(\"Move \"+n+\" from \"+a+\" to \"+c+\"</br>\")\n              hanoi(n-1,b,a,c);\n          }\n      }\n      hanoi(3,\"A\",\"B\",\"C\");\n</script>\n</code></pre>\n\n菜鸟说明：\n\n采用递归（递归就是有限的重用一个的函数，此函数变量可改变，有条件判断让函数能过自行结束）的办法实现，将上面代码直接贴到html页面，打开Html产生下图所示证明你成功了。\n\n<img src=\"https://images0.cnblogs.com/blog/701486/201412/111103190257565.png\">\n\n与C语言的区别（不敢分优缺点）：\n\n1.不需要调用外部文件，只要是支持JS的浏览器就能解析。\n\n2.变量不需要申明，但要明确是整型还是字符串（字符的话要加双引号！）。\n\n3.JS是逐句解析，不需要主函数，创建一个对象之后可以直接在后面调用使用。\n\n普及常识： 汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。<img src=\"https://images0.cnblogs.com/blog/701486/201412/111214593848247.jpg\">', '2018-02-21 21:18:00', '博客园', 'https://www.cnblogs.com/lee-my/p/Hanoi.html'),
(70, '费米问题', '猪头010', 'baike', '费米问题是在科学研究中用来做量纲分析、估算和清晰地验证一个假设的估算问题。命名来自美国科学家恩利克·费米。这类问题通常包括关于给定限定信息的有可能计算的数量的猜想的验证。\r\n费米问题的特点为初次听到这种问题的提问时，会觉得已知条件太少，离答案差距甚远。但当变通改变分析对象之后，所有这类问题都会迎刃而解，不需要求助专家书本，就可以出乎意料地接近确切的答案。\r\n来源\r\n1945年7月16日上午，世界上第一颗原子弹在美国新墨西哥州沙漠地区爆炸。\r\n意大利裔美国物理学家恩利克·费米把笔记本里的一页纸撕碎了，一感到震波，他即把举过头顶的抓着小纸片的手松开。碎纸飘扬而下，在费米身后2.5m处落地，心算之后费米宣布，原子弹能量相当于10000tTNT当量。一些尖端的仪器设备花了数星期时间来分析波速、波压，结果证明费米的瞬时估算是准确的。\r\n费米喜欢通过非常直接的，而不是缜密理性的途径去解决问题，他善于把难题转化为容易处理的简单问题，这是一种人人都可应用到实际生活中去的才能。\r\n为了在学生中间推广这种思想，费米会经常提出一种特殊类型问题，即众所周知的费米问题。\r\n示例\r\n示例一\r\n地球的周长是多少？\r\n解答方法之一：\r\n已知纽约到洛杉矶3000英里，时差3小时，而一天即地球自转一周的时间为24小时，即3小时的8倍。所以，地球的周长就是3000乘以8，等于24000英里。与精确值的24902.45英里相比，误差不到4%。\r\n示例二\r\n芝加哥有多少钢琴调音师？\r\n解答方法之一：\r\n如果芝加哥居民300万，平均每户4人，拥有钢琴的家庭占1/3，则全市有250000架钢琴。如果一架钢琴每5年调音一次，则全市每年有50000架钢琴要调音。如果一个调音师一天调4架钢琴，一年工作250天，那么，芝加哥市大约有50个调音师。', '2018-02-23 00:04:00', '百度百科', 'https://baike.baidu.com/item/%E8%B4%B9%E7%B1%B3%E9%97%AE%E9%A2%98/5100727'),
(71, '移动硬盘的内部构造', '免费办理信用卡', 'baike', '这一篇就和大家讲讲移动硬盘内部的结构构造，也就是移动硬盘的内脏部分了，它的工作全在这里面进行了。先给大家展示一张图片简单了解一下。\r\n<img src=\"http://s4.sinaimg.cn/middle/a76c8912gc5f40c7bf453&690\" alt=\"移动硬盘的内部构造\">\r\n\r\n   通过图片，我相信大家都会看的一目了然，这要也是有这几部分组成的，\r\n\r\n    盘片：就是存储数据的地方，从图中可以看出，盘片已经被灰色的线条分割成很多小的区域，每一个区域就代表一个扇区。\r\n\r\n    主轴：主轴是由轴承和马达构成的，主要是带动盘片的高速运转，根据马达的不同，可以分为低速盘区和高速盘区。\r\n\r\n     磁头：它是读取、写入、存储、以及清除数据的，是整个盘的核心部位。\r\n\r\n     音圈马达：这个其实是一个定位马达，它可以带动磁头沿着Z移动到各个磁道上去。\r\n\r\n     这就是它的内部构造，原理其实也很简单的，就是音圈马达带动磁头在磁道上的高速运转，这个过程是一个动态的过程，在前面的几篇文章里我也介绍过为什么移动硬盘在工作的时候不要随便的移动或是碰撞，就是这个原理的。到后面我再跟大家分享另外的一点内容，就是如何根据这一原理去判断移动硬盘的真伪，，就到这里了，下次继续.....\r\n', '2018-02-23 10:56:00', '新浪博客', 'http://blog.sina.com.cn/s/blog_a76c891201016xzz.html'),
(72, 'Apache shutdown unexpectedly解决方法', '码农小张', 'Apache', '问题描述\r\n最近在搞点web，装了XAMPP，在启动apache的时候就郁闷了， \r\n18:22:07 [Apache] Error: Apache shutdown unexpectedly. \r\n18:22:07 [Apache] This may be due to a blocked port, missing dependencies, \r\n18:22:07 [Apache] improper privileges, a crash, or a shutdown by another method. \r\n18:22:07 [Apache] Press the Logs button to view error logs and check \r\n18:22:07 [Apache] the Windows Event Viewer for more clues \r\n18:22:07 [Apache] If you need more help, copy and post this \r\n18:22:07 [Apache] entire log window on the forums\r\n\r\n解决办法\r\n经过一番研究，原来是MainPort和SSLPort的问题，建议先在cmd中执行(安装路径)\\xampp\\apache\\bin\\httpd.exe,然后根据cmd中的提示，来解决。\r\n<ol>\r\n<li><p>第一种解决办法</p>\r\n\r\n<ul><li>cmd 通过运行\\xampp\\apache\\bin\\httpd.exe，打印如下：     通常每个套接字地址(协议/网络地址/端口)只允许使用一次。 : make_sock: could not bind to address 0.0.0.0:80  或[ : : ]:80 <br>\r\n在/xampp/apache/conf/extra/httpd.conf  把Listen 80 修改为 88 （可自定义）</li>\r\n<li>满怀信心，再执行\\xampp\\apache\\bin\\httpd.exe，打印如下：    通常每个套接字地址(协议/网络地址/端口)只允许使用一次。 : make_sock: could not bind to address <br>\r\n0.0.0.0:443  在/xampp/apache/conf/extra/httpd-ssl.conf  把Listen 443 修改为 444（可自定义）</li></ul></li>\r\n<li><p>最直接的方法是关闭占用80、443端口的进程：  <br>\r\n 1.通过cmd中netstat -ano 看看本机80、443端口被占用没这里可能会被其他程序占用如iis、虚拟机等 <br>\r\n 2.通过cmd中打印tasklist，查找占用80、443端口的进程名称。  <br>\r\n 3.taskkill /pid 端口号 杀掉此进程名称，XAMPP重启apache即可。</p></li>\r\n</ol>\r\n\r\n推荐第一种办法。 \r\n补充：还有一种情况我没遇到，参考网上说的。如果配置了vhosts的话请把httpd-vhosts.conf 中端口改为88（同上端口号）', '2018-02-25 19:26:00', 'CSDN', 'https://blog.csdn.net/luomoshusheng/article/details/44653615'),
(73, '怎么修改Xampp中Apache服务器的端口号', '喜爱兰兰', 'Apache,XAMPP', '下载安装好Xampp直接start apache服务，可能发现443端口被其他服务所占有，这时候我有必要修改一下apache服务器的端口号:\r\n\r\n步骤很简单:点击Config按钮，可以看到有两个配置文件httpd.conf和httpd-ssl.conf；现在要根据端口号错误来更改apache的端口号，如果是port 443错误，更改http-ssl.conf文件中的Listen监听端口，如果是80错误，更改httpd.conf文件中Listen\r\n\r\n<img src=\"https://img-blog.csdn.net/20151031232828239?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\">\r\n\r\n打开httpd.conf文件,找到设置端口的配置信息如下:\r\n\r\n#\r\n# Listen: Allows you to bind Apache to specific IP addresses and/or\r\n# ports, instead of the default. See also the <VirtualHost>\r\n# directive.\r\n#\r\n# Change this to Listen on specific IP addresses as shown below to \r\n# prevent Apache from glomming onto all bound IP addresses.\r\n#\r\n#Listen 12.34.56.78:80\r\n\r\n\r\n\r\n打开httpd-ssl.conf文件,找到设置端口的配置信息如下:\r\n\r\n#\r\n# When we also provide SSL we have to listen to the \r\n# standard HTTP port (see above) and to the HTTPS port\r\n#\r\n# Note: Configurations that use IPv6 but not IPv4-mapped addresses need two\r\n#       Listen directives: \"Listen [::]:443\" and \"Listen 0.0.0.0:443\"\r\n#\r\nListen 443\r\n\r\n\r\n\r\nps:配置文件比较长，眼睛不好找，按Ctrl+F查找关键字就快多了，比如直接找80或者443就行了，马上跳到该段的配置信息了。\r\n\r\n直接更改下Listen的端口号就可以。', '2018-02-25 19:44:00', 'CSDN', 'https://blog.csdn.net/qq_20916555/article/details/49538667'),
(74, 'Jetty', 'ykjcqq', 'baike', 'Jetty 是一个开源的servlet容器，它为基于Java的web容器，例如JSP和servlet提供运行环境。Jetty是使用Java语言编写的，它的API以一组JAR包的形式发布。开发人员可以将Jetty容器实例化成一个对象，可以迅速为一些独立运行（stand-alone）的Java应用提供网络和web连接。\n<img src=\"https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=cc8fab21ce11728b24208470a995a8ab/908fa0ec08fa513d3b18486e3e6d55fbb3fbd9cb.jpg\">\n特性\n易用性\n易用性是 Jetty 设计的基本原则，易用性主要体现在以下几个方面：\n通过 XML 或者 API 来对Jetty进行配置；默认配置可以满足大部分的需求；将 Jetty 嵌入到应用程序当中只需要非常少的代码；\n可扩展性\n在使用了 Ajax 的 Web 2.0 的应用程序中，每个连接需要保持更长的时间，这样线程和内存的消耗量会急剧的增加。这就使得我们担心整个程序会因为单个组件陷入瓶颈而影响整个程序的性能。但是有了 Jetty：\n即使在有大量服务请求的情况下，系统的性能也能保持在一个可以接受的状态。利用 Continuation 机制来处理大量的用户请求以及时间比较长的连接。 另外 Jetty 设计了非常良好的接口，因此在 Jetty 的某种实现无法满足用户的需要时，用户可以非常方便地对 Jetty 的某些实现进行修改，使得 Jetty 适用于特殊的应用程序的需求。\n易嵌入性\nJetty 设计之初就是作为一个优秀的组件来设计的，这也就意味着 Jetty 可以非常容易的嵌入到应用程序当中而不需要程序为了使用 Jetty 做修改。从某种程度上，你也可以把 Jetty 理解为一个嵌入式的Web服务器。\nJetty 可以作为嵌入式服务器使用，Jetty的运行速度较快，而且是轻量级的，可以在Java中可以从test case中控制其运行。从而可以使自动化测试不再依赖外部环境，顺利实现自动化测试。\n和Tomcat比较编辑\n原文地址:Jetty和Tomcat的选择：按场景而定\n1）Jetty更轻量级。这是相对Tomcat而言的。\n由于Tomcat除了遵循Java Servlet规范之外，自身还扩展了大量JEE特性以满足企业级应用的需求，所以Tomcat是较重量级的，而且配置较Jetty亦复杂许多。但对于大量普通互联网应用而言，并不需要用到Tomcat其他高级特性，所以在这种情况下，使用Tomcat是很浪费资源的。这种劣势放在分布式环境下，更是明显。换成Jetty，每个应用服务器省下那几兆内存，对于大的分布式环境则是节省大量资源。而且，Jetty的轻量级也使其在处理高并发细粒度请求的场景下显得更快速高效。\n2）Jetty更灵活，体现在其可插拔性和可扩展性，更易于开发者对Jetty本身进行二次开发，定制一个适合自身需求的Web Server。\n相比之下，重量级的Tomcat原本便支持过多特性，要对其瘦身的成本远大于丰富Jetty的成本。用自己的理解，即增肥容易减肥难。\n3）然而，当支持大规模企业级应用时，Jetty也许便需要扩展，在这场景下Tomcat便是更优的。\n总结：Jetty更满足公有云的分布式环境的需求，而Tomcat更符合企业级环境。\n代码实例编辑\n作为嵌入式服务器使用代码实例\nJava代码\n<pre><code>\n//代码：以嵌入模式启动Jetty\nimport org.mortbay.http.HttpContext;\nimport org.mortbay.http.HttpServer;\nimport org.mortbay.http.SocketListener;\nimport org.mortbay.http.handler.ResourceHandler;\n \npublic class JettySample{\npublic static void main(String[]args)throws Exception{\n//创建JettyHttpServer对象 \nHttpServer server=new HttpServer();\n//在端口8080上给HttpServer对象绑上一个listener，使之能够接收HTTP请求\nSocketListener listener=new SocketListener();\nlistener.setPort(8080);\nserver.addListener(listener);\n//创建一个HttpContext，处理HTTP请求。\nHttpContext context=new HttpContext();\n//用setContextPath把Context映射到（/web）URL上。\ncontext.setContextPath(\"/web\");\n//setResourceBase方法设置文档目录以提供资源\ncontext.setResourceBase(\"C:\\\\j2sdk1.4.1_05\");\n//添加资源处理器到HttpContext，使之能够提供文件系统中的文件\ncontext.addHandler(new ResourceHandler());\nserver.addContext(context);\n//启动服务器\nserver.start();\n}\n}</code></pre>\n需要的jar包：\ncommons-logging.jar\njavax.servlet.jar\norg.mortbay.jetty.jar\norg.mortbay.jmx.jar\njetty还有对应maven插件\nmaven pom文件的设置:\n<pre><code>\n&lt;?xmlversion=&quot;1.0&quot;encoding=&quot;utf-8&quot;?&gt;\n \n&lt;plugin&gt;\n&lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;\n&lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;\n&lt;version&gt;6.1.10&lt;/version&gt;\n&lt;configuration&gt;\n&lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;\n&lt;stopKey&gt;foo&lt;/stopKey&gt;\n&lt;stopPort&gt;9999&lt;/stopPort&gt;\n&lt;/configuration&gt;\n&lt;executions&gt;\n&lt;execution&gt;\n&lt;id&gt;start-jetty&lt;/id&gt;\n&lt;phase&gt;pre-integration-test&lt;/phase&gt;\n&lt;goals&gt;\n&lt;goal&gt;run&lt;/goal&gt;\n&lt;/goals&gt;\n&lt;configuration&gt;\n&lt;scanIntervalSeconds&gt;0&lt;/scanIntervalSeconds&gt;\n&lt;daemon&gt;true&lt;/daemon&gt;\n&lt;/configuration&gt;\n&lt;/execution&gt;\n&lt;execution&gt;\n&lt;id&gt;stop-jetty&lt;/id&gt;\n&lt;phase&gt;post-integration-test&lt;/phase&gt;\n&lt;goals&gt;\n&lt;goal&gt;stop&lt;/goal&gt;\n&lt;/goals&gt;\n&lt;/execution&gt;\n&lt;/executions&gt;\n&lt;/plugin&gt;</code></pre>\n然后直接通过mvn jetty:run命令就能直接启动\n-----------------------------------------------------------------------------------------\n注：\n在maven中，用plugin的方式使用jetty，需要改动maven的setting.xml文件，才可以使用命令mvn jetty:run.\nsetting.xml中找到标签<pluginGroups>，增加：\n<code><pluginGroup>org.mortbay.jetty</pluginGroup></code>即可。', '2018-03-06 15:13:00', '百度百科', 'https://baike.baidu.com/item/jetty/370234'),
(75, '移动硬盘容易坏吗？', '少数派', 'baike', '机械硬盘的保护，其实很简单。但要想真正的保护硬盘，首先得先从硬盘的原理说起。硬盘的原理其实就是内部的磁头在一片或数片圆形的磁盘上通过电磁流将信息读取或写入。磁盘在硬盘通电后快速旋转，磁头在磁盘上滑动传入主板以达到访问数据。其中硬盘最为精贵就是磁头与磁盘。<img src=\"https://pic3.zhimg.com/80/v2-82da3aa48c68afb715b8597cd37f132c_hd.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"283\" class=\"content_image\" width=\"400\"><img src=\"data:image/svg+xml;utf8,&lt;svg%20xmlns=\'http://www.w3.org/2000/svg\'%20width=\'400\'%20height=\'283\'&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"283\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic3.zhimg.com/80/v2-82da3aa48c68afb715b8597cd37f132c_hd.jpg\"><h2>1. 避免突然断电</h2>硬盘在工作时，磁盘一般都处于高速旋转状态。如果这时突然断电，磁头有可能会划伤碟片，损坏其中数据的完整性。目前一些硬盘里安装了一块极小的「电池」，在外部电源断电的瞬间，机械硬盘会利用这块电池的电量优先将磁头挪动到安全区域，避免划伤碟片。虽然有这样的保护，但在使用过程中，还是应当避免突然断电。在专业领域，如：监控、服务器等，这些数据要比个人硬盘中的数据更为宝贵。在这些存放数据的硬盘或硬盘组旁，一般都配有 UPS（即不间断电源），在遇到不可抗力的突然断电时，UPS 中配备的蓄电池会代替主电源继续工作，直到电力恢复或蓄电池没电。<h2>2. 防止大量灰尘</h2>如今的硬盘大部分都是密封机身，一般只有一个过滤的气孔，用来平衡工作时产生的热量导致的气压差。但在灰尘严重的环境下，气孔很容易吸入空气中的灰尘，灰尘长期积累在硬盘的内部，会影响电子元器件的散热，使得电路板等元器件的温度上升，产生漏电而烧坏元件，造成一些莫名其妙的问题。所以灰尘体积虽小，但对硬盘的危害是不可低估的。因此必须保持环境卫生，减少空气中的湿度和含尘量。这里要注意的是：一般用户不能自行拆开硬盘盖，否则空气中的灰尘进入硬盘内，尝试物理修复请到专业机构，避免在磁头进行读、写操作时划伤盘片或磁头。<h2>3. 减少外力磕碰</h2>硬盘是一种精密的设备，在工作中磁头与磁盘的互动距离会达到几微米。在受到外力冲击时，磁头会在磁盘上留下损伤。在高温度、高磁场、静电的情况，对硬盘也是损伤很大，从部分数据损坏到整个硬盘报废，都有可能。所以在携带、移动、使用的过程中，一定要多加小心。<h2>4. 经常备份</h2>对于数据更重要的人来说，硬盘坏了不是大事，数据丢了才是大难临头。在这种情况下，经常做数据的备份，固定时间执行一遍，能够有效防止数据的意外丢失。或组建 RAID1 阵列，可以有效避免硬盘的各种问题导致的数据损坏或丢失。<h2>如何修复硬盘</h2>在修复前：如果硬盘第一次通电时发出了咔嗒声，那么之后再通电都会损坏硬盘上的磁层，从而导致数据丢失。在这种情况下，如果数据很重要，那就不要使用了。因为可能会彻底将硬盘报废，让你原本还没坏掉的数据彻底荡然无存。<b>目前大部分的硬盘修复方式只能恢复扇区可用，不能恢复数据。</b>硬盘的性能和可靠性是相互的，硬盘的性能会随着寿命下降，而降到一定程度就会开始不可避免地发生越来越多的数据损坏。「扇区」损坏是硬盘中常见的数据丢失的问题。是硬盘的内部圆形金属盘片被磁道划分成若干个扇形区域，这就是「扇区」。若干个扇区就组成整个盘片，硬盘的读写以扇区为基本单位。这种以「簇」为最小分配单位的机制，使硬盘对数据的管理变得相对容易。<img src=\"https://pic3.zhimg.com/80/v2-1faef7312f5d9df9bf4a00dab69aa6db_hd.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"431\" class=\"content_image\" width=\"400\"><img src=\"data:image/svg+xml;utf8,&lt;svg%20xmlns=\'http://www.w3.org/2000/svg\'%20width=\'400\'%20height=\'431\'&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"431\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic3.zhimg.com/80/v2-1faef7312f5d9df9bf4a00dab69aa6db_hd.jpg\">硬盘的恢复主要为两种：物理恢复 / 软件恢复（修复硬盘 / 恢复数据）。<br><ul><li><b>修复硬盘：</b>是指将硬盘在物理层面的的维修，修复的是「硬盘」这个本身。在某些情况下，「硬盘」在宏观物理上完好无损，数据也有可能遭到损坏或「硬盘」在物理层面维修好，数据也有可能无法恢复。<br></li><li><b>恢复数据：</b>将「硬盘中」的数据恢复成正常状态，在某种层面上，「硬盘」如果是物理的损坏，那么数据一定是有损坏的（不一定会体现出来）。<br></li></ul><br><h2>物理恢复数据</h2>对敢于冒险的人来说，「DIY 方式」是最受欢迎的，现在有很多公司专门为这些 DIY 爱好者提供零件。这种方式的理念是更换烧毁的电路板，就可以修复硬盘。但这也代表着如果 DIY 修复失败，那么再去找专业修复公司来恢复数据是基本不可能的。* 请自行在购物平台搜索「硬盘零件」。「专业数据恢复」是在专业的无尘室修复，有时会通过更换零部件，如：磁头、主板，将其重新组合为新盘，调试固件后访问数据。有时会通过更为复杂的克隆整盘，将其中的磁盘通过磁场的克隆，完整的信息会克隆到新的磁盘中，这是数据恢复中耗时最长的，根据碟片的受损程度不同，需要几小时到一个月不等。<img src=\"https://pic3.zhimg.com/80/v2-39e7492f01f8cd0a1e8f49a9022fefe6_hd.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"430\" class=\"origin_image zh-lightbox-thumb\" width=\"650\" data-original=\"https://pic3.zhimg.com/v2-39e7492f01f8cd0a1e8f49a9022fefe6_r.jpg\"><img src=\"data:image/svg+xml;utf8,&lt;svg%20xmlns=\'http://www.w3.org/2000/svg\'%20width=\'650\'%20height=\'430\'&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"430\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"650\" data-original=\"https://pic3.zhimg.com/v2-39e7492f01f8cd0a1e8f49a9022fefe6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/80/v2-39e7492f01f8cd0a1e8f49a9022fefe6_hd.jpg\">这里的数据恢复公司仅供参考：<a href=\"https://link.zhihu.com/?target=http%3A//www.chinadrs.cn/index/index.asp\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">国家信息中心</a>、<a href=\"https://link.zhihu.com/?target=http%3A//www.fixhdd.cn/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">华军数据</a>、<a href=\"https://link.zhihu.com/?target=http%3A//www.helpdata.cn/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">一盘数据</a>。两种修复方式各有利弊。DIY 虽然便宜，但是面临着风险也非常大，可能会造成不可挽回的后果。专业修复有一定的保障，但价格不菲，有时可能会高达购买硬盘价格的几倍。因此，你需要在维修成本和硬盘数据价值之间做出权衡。<h2>软件恢复数据</h2>通常是硬盘有大量坏扇区，数据损坏。修复扇区一般的方法是「低格」（低级格式化），是硬盘逻辑层面的格式化。通常对这些数据「低格」的话，扇区就可以正常使用了。这样的修复方法可以让任何物理上没有损坏的硬盘起死回生。坏扇区修复软件的方法是重新写入校验码、标志信息等可以修复一部分扇区，如果不行，就添加到「新增损坏扇区表」中，这样在读取时会跳过该扇区。当保留空间用完的时候，硬盘上的新坏道就无法再用添加到「新增损坏扇区表」中来继续屏蔽。如果到了这种情况，我个人不建议用软件来尝试恢复数据，建议直接寻找专业数据恢复公司来修复硬盘。这里的恢复软件仅供参考：<a href=\"https://link.zhihu.com/?target=http%3A//www.diskgenius.cn/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">DiskGenius</a>、<a href=\"https://link.zhihu.com/?target=https%3A//www.cleverfiles.com/cn/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Disk Drill</a>、<a href=\"https://link.zhihu.com/?target=http%3A//dl.pconline.com.cn/download/370273.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">pc3000</a>。<h2>结语</h2><b>不管是物理恢复还是软件恢复，都是一种亡羊补牢的做法，只能尽量恢复其中的数据。</b>正确的使用和保护硬盘，才是避免硬盘数据丢失的正确做法。在正确的使用上，再定期保养和备份，这样你的数据才能够安然自若。如果仅靠事后修复来弥补之前的不当操作，那只能看自己的命了。', '2018-03-08 09:40:00', '知乎', 'https://www.zhihu.com/question/20414560'),
(76, 'php实现excel表格下载', 'php_fighting', 'PHP', '本人做的这个比较简单，不需要用到PHPExcel类\r\n\r\n<pre><code>\r\n//此为从数据库中读取的数据  在这我就不连接数据库啦  直接写个二维数组  \r\n  $list = array(array(\'id\'=>1,\'username\'=>\'YQJ\',\'sex\'=>\'男\',\'age\'=>24),array(\'id\'=>2,\'username\'=>\'张三\',\'sex\'=>\'女\',\'age\'=>22));  \r\n  //下载的文件的名称  \r\n  $filename=\"ce\";  \r\n  \r\n  header(\"Content-type:application/vnd.ms-excel\");  \r\n  header(\"Content-Disposition:filename=\".$filename.\".xls\");  \r\n  \r\n  $strexport=\"编号\\t姓名\\t性别\\t年龄\\r\";  \r\n  foreach ($list as $row){  \r\n  \r\n      $strexport.=$row[\'id\'].\"\\t\";  \r\n      $strexport.=$row[\'username\'].\"\\t\";  \r\n      $strexport.=$row[\'sex\'].\"\\t\";  \r\n      $strexport.=$row[\'age\'].\"\\r\";  \r\n  \r\n  }  \r\n  $strexport=iconv(\'UTF-8\',\"GB2312//IGNORE\",$strexport);  \r\n  exit($strexport);  \r\n</code></pre>\r\n执行后便提示下载一个ce.xls的excel表格', '2018-03-09 09:17:00', 'CSDN', 'https://blog.csdn.net/zhangweiguangsunjiao/article/details/72832499');
INSERT INTO `wu_blog` (`id`, `post_title`, `post_author`, `post_type`, `post_content`, `post_date`, `post_from`, `post_link`) VALUES
(77, '了解Service Unavailable的原因以及解决方法', '佚名', 'Windows', '<blockquote>由于2003的操作系统在提示IIS过多时并非像2000系统提示“链接人数过多”，而是提示\"ServiceUnavailable\",出现这种情况是由于网站超过了系统资源限制造成的，主要是程序占用资源太多。</blockquote>\r\n一、如果出现“Service Unavailable”的提示，刷新几下又可以访问。\r\n出现这种情况是由于您的网站超过了iis限制造成的\r\n由于2003的操作系统在提示IIS过多时并非像2000系统提示“链接人数过多”，而是提示\"ServiceUnavailable\",出现这种情况是由于网站超过了系统资源限制造成的，主要是程序占用资源太多。\r\n比如同样是100人在线的论坛，雷傲论坛所占的资源就是PW论坛所占资源的10倍以上；另外，一些死循环程序，或者不优化的程序都会占用太多的系统资源，而系统资源明显是有限的。不过WINDOWS2003的操作系统，各网站之间是以独立进程运行的，不会相互影响。\r\n如果一个网站的程序占资源太多或者发生太多的错误，系统日志就会提示：“应用程序池\'xxx\'被自动禁用，原因是为此应用程序池提供服务的进程中出现一系列错误，或者提示：应用程序池\'xxx\'超过了其作业限制设置。这时，访问这个网站就会提示：ServiceUnavailable。一般系统会在30秒左右恢复正常，多刷新几次就能正常访问了。\r\n另外，如果你的网站当前访问人数过多，超过了系统的iis连接数限制，也会出现ServiceUnavailable的提示(win2k主机下出现连接过多就会提示：连接过多，请稍后再试；而win2003的主机刚直接提示：ServiceUnavailable）\r\n二、没有限制IIS连接，还是遭遇Service Unavailable\r\n多见于使用ACCESS数据库的网站\r\n一般使用windows2003IIS6的用户可能这个问题一直正常的系统，突然有一个网站打不开了\r\n提示：ServiceUnavailable但这个网站并没有限制IIS连接数。然后马上影响到了别的网站，不到一会，其他的网站也全变成了ServiceUnavailable\r\n这是什么原因呢？//本文来自www.jb51.net\r\n我们分析后可以知道，还是MS的老问题。ACCESS引擎当了。用服务器医生的文件医生修复，查看修复结果时会发现一些文件引起ACCESS引擎“灾难性故障”及“未将对象引用设置到对象的实例”的错误。通过文件医生修复后，系统才会恢复正常。\r\n三、浏览一个WindowsSharePointServicesWeb站点时，提示：ServiceUnavailable\r\n1.MicrosoftInternet信息服务(IIS)6.0中没有正确地配置用于虚拟服务器的应用程序池，就可能会发生此问题。\r\n解决方案\r\n要解决此问题，按照下列步骤操作：1.验证是否已为虚拟服务器配置了应用程序池。默认的应用程序池是MSSharePointPortalAppPool。\r\n请按照下列步骤来确定虚拟服务器正在使用的应用程序池。\r\na.单击“开始”，指向“管理工具”，然后单击“Internet信息服务(IIS)管理器”。\r\nb.展开“ServerName”，展开“Web站点”，右键单击虚拟服务器，然后单击“属性”。\r\nc.单击“主目录”选项卡。为虚拟服务器配置的应用程序池列在“应用程序池”框中。\r\nd.单击“确定”。\r\n2.验证应用程序池帐户使用的密码是否正确。IIS不会自动轮询ActiveDirectory目录服务中的密码更改。如果应用程序池帐户是一个域帐户，其密码已过期，则在为此帐户重新指定一个新密码后，您可能会收到本文“症状”部分所描述的错误信息。\r\n3.验证应用程序池帐户是服务器上的IIS_WPG组和STS_WPG组的成员。\r\n4.重新启动IIS以回收应用程序池\r\nServiceUnavailable”出现的原因\r\nServiceUnavailable的出现一般是资源不足，如IIS、CPU或内存等。\r\n我们的所有虚拟主机均不限制IIS，因此可以排除IIS不足。\r\n我司所有服务器操作系统均为windows2003，有个很关键的东西就是“应用程序池”\r\n一般情况下为30-50个站共用一个程序池，这个程序池可以简单理解为资源库，即这30-50个站共用这块资源。我们限定一个程序池的CPU占用为60%，内存使用为200M。\r\n如果这个资源被其中一个站用完，则程序池就会停止，所有使用这个程序池的站就会出现“ServiceUnavailable”资源不足的提示，直到该程序池被重新启动。\r\n大多数情况下，60%的CPU和200M内存完全足够使用；如果出现垃圾程序或遇到攻击，则可能出现CPU急速上升或内存大量使用，这个是大部分“ServiceUnavailable”出现的原因。从目前我们监测的情况看，大部分是CPU占用在90%-100%之间出现的。\r\n1、出现“ServiceUnavailable”怎么办？\r\n我们自主开发了一套专门监视并修复IIS的程序，每隔10分钟自动检查一次IIS，如果发现程序池停止，就会重新启动。因此一旦出现“ServiceUnavailable”，最多不超过10分钟，就会自动修复，大多数情况下只需要2-5分钟。其他大部分公司都没有监控程序，则只能手工修复，一般持续时间为2-6小时才能发现并启动。\r\n2、频繁出现“ServiceUnavailable”怎么办？\r\n如果频繁出现了这个提示，则表明其中一个和您共用资源的站出了问题，请联系我们的技术员进行排查。\r\n3、出现“ServiceUnavailable”是服务器问题吗？\r\n很多人都认为是服务器不稳定的问题，其实不然。如果是服务器问题，不会出现“ServiceUnavailable”的提示，而是直接瘫痪掉，连FTP也上不去。\r\n出现这个是因为有站消耗了大量资源，服务器的资源始终是有限的，如果长期超过设置的值，则服务器会自动停止这个程序池，防止影响其他程序池的用户。', '2018-03-13 10:31:00', '脚本之家', 'http://www.jb51.net/os/windows/win2008/39862.html'),
(78, '解决 There are no resources that can be added or removed from the server', 'rogear', 'Eclipse', '网上下载了一个项目，在eclipse中部署时，加载项目到tomcat中项目名称无法显示，报出There are no resources that can be added or removed from the server\r\n\r\n这个是因为下载下来的项目没有eclipse的相关配置文件，eclipse不知道这是一个什么项目。\r\n\r\n解决方法：\r\n\r\n1、进入configure Build Path\r\n<img src=\"https://images2017.cnblogs.com/blog/922636/201707/922636-20170726232817812-617996480.png\">\r\n1、进入Project Facets 选中Dynamic Web Module和java\r\n<img src=\"https://images2017.cnblogs.com/blog/922636/201707/922636-20170726232936125-784597789.png\">\r\n然后就可以正常部署项目了', '2018-03-13 13:36:00', '博客园', 'https://www.cnblogs.com/rogear/p/7242586.html'),
(79, '【java开发系列】—— Tomcat编译报错', 'xingoo', 'JAVA,Tomcat', '由于之前Eclipse里面有一个可移植性的web工程，但是在我很久没用后，再次登录这个IDE的时候就发现了问题。\r\n\r\n首先，我的电脑里面有两个版本的JDK，1.6和1.7。两个版本的Tomcat6和7以及两个版本的Eclipse IDE 3.5和4.0+。\r\n\r\n \r\n\r\n当我启动开发环境后，想要向server中添加应用，发现报错：\r\n\r\nThere are no resources that can be added or removed from the server.\r\n\r\n<img src=\"https://images0.cnblogs.com/blog/449064/201411/231146317815052.jpg\">\r\n\r\n我之前好用的应用怎么回不好使呢。于是删除server再次添加，当我添加tomcat6时，发现如下报错：\r\n\r\nTomcat version 6.0 only supports j2ee 1.2 1.3 1.4 and java ee 5 web modules.\r\n\r\n<img src=\"https://images0.cnblogs.com/blog/449064/201411/231147484212137.jpg\">\r\n\r\n当我添加7时，发现如下报错:\r\n\r\nProject facet java version 1.7 is not supported\r\n\r\n<img src=\"https://images0.cnblogs.com/blog/449064/201411/231148119212091.jpg\">\r\n\r\n看到上面的报错，不用想了！肯定是版本的问题了！\r\n\r\n <img src=\"https://images0.cnblogs.com/blog/449064/201411/231149028431567.jpg\">\r\n\r\n这就奇怪了，怎么6和7都不好使了呢。上网搜索一下资料，原来工程有个文件：org.eclipse.wst.common.project.facet.core.xml\r\n\r\n<img src=\"https://images0.cnblogs.com/blog/449064/201411/231149028431567.jpg\">\r\n\r\n<pre><code>\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\r\n&lt;faceted-project&gt;\r\n  &lt;fixed facet=&quot;wst.jsdt.web&quot;/&gt;\r\n  &lt;fixed facet=&quot;jst.web&quot;/&gt;\r\n  &lt;fixed facet=&quot;java&quot;/&gt;\r\n  &lt;installed facet=&quot;java&quot; version=&quot;1.7&quot;/&gt;\r\n  &lt;installed facet=&quot;jst.web&quot; version=&quot;3.0&quot;/&gt;\r\n  &lt;installed facet=&quot;wst.jsdt.web&quot; version=&quot;1.0&quot;/&gt;\r\n&lt;/faceted-project&gt;\r\n</code></pre>\r\n\r\n这个文件中配置了工程的编译使用的jdk，以及jst.web的版本，可以发现了，我上面配置文件中使用的1.7但是我本机的JDK是1.6.\r\n\r\n因此把这个换成1.6测试，相应的jst.web换成2.5,就成功了。具体这个配置文件的作用，还需要研究下tomcat。查看资料也没找到这个配置文件的说明。发个博问问问吧。\r\n\r\n<img src=\"https://images0.cnblogs.com/blog/449064/201411/231154430621729.jpg\">', '2018-03-13 13:50:00', '博客园', 'https://www.cnblogs.com/xing901022/p/4116298.html'),
(80, '框架学习（1）——service层，dao层和service实现类进行数据库操作', 'Rylynn_', 'JAVA', '\n<ul>\n<li>访问数据库的传统方法 <br>\n传统访问数据库的方法非常面向过程，分为以下几步 <br>\n– 实例化connection <br>\n– 实例化statement <br>\n– 通过statement的参数sql语句访问数据库，返回数据进行处理</li>\n</ul>\n<pre><code>\n代码：\nimport java.sql.Statement;\nimport java.util.Properties;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic class DBAccess {\n\n    public static void main(String[] args) throws SQLException, FileNotFoundException, IOException\n    {\n        DBAccess access = new DBAccess();\n        access.test();\n    }\n\n    private void test() throws SQLException, FileNotFoundException, IOException\n    {\n        String url = &quot;jdbc:postgresql://localhost:5432/rylynn&quot;; \n\n        Properties p = new Properties();\n        p.load(new FileInputStream(&quot;reg.txt&quot;));\n\n        Connection connection = DriverManager.getConnection(url,p);       //建立connection\n        Statement statement = connection.createStatement();       //建立satatement\n        statement.execute(&quot;insert into abo values((001),&#x27;hnb&#x27;)&quot;);       //执行sql语句\n\n        ResultSet resultSet = statement.executeQuery(&quot;select number from abo where number &lt; 2&quot;);\n        while(resultSet.next())\n        {\n            int id = resultSet.getInt(1);\n    //      String name = resultSet.getString(1);\n            System.out.println(&quot;ID:&quot; + id);\n        }\n        statement.close();\n        connection.close();\n    }\n}   </code></pre>\n\n传统数据库访问模式缺点显而易见： <br>\n一就是各个模块间的耦合太紧，statement要依赖connection，connection还依赖于数据库的种类。 <br>\n二就是如果我改变的数据库的种类，或者要提供不同的数据库服务，那么我就要提供大量的重复代码。\n\n<h2 id=\"面向抽象的编程思想告诉我们要面向接口编程这种编程模式的好处就是各个模块之间分工明确而且互不干扰首先介绍一下各个层次之间分工\">面向抽象的编程思想告诉我们要面向接口编程，这种编程模式的好处就是，各个模块之间分工明确，而且互不干扰，首先介绍一下各个层次之间分工。</h2>\n\n<ul>\n<li>dao层：dao层叫数据访问层，全称为data access object，属于一种比较底层，比较基础的操作，具体到对于某个表、某个实体的增删改查</li>\n<li>service层：service层叫服务层，被称为服务，肯定是相比之下比较高层次的一层结构，相当于将几种操作封装起来，至于为什么service层要使用接口来定义有以下几点好处： <br>\n<ul><li>在java中接口是多继承的，而类是单继承的，如果你需要一个类实现多个service，你用接口可以实现，用类定义service就没那么灵活</li>\n<li>要提供不同的数据库的服务时，我们只需要面对接口用不同的类实现即可，而不用重复地定义类</li>\n<li>编程规范问题，接口化的编程为的就是将实现封装起来，然调用者只关心接口不关心实现，也就是“高内聚，低耦合”的思想。</li></ul></li>\n<li>service实现类：也顾名思义，service实现类实现了service接口，进行具体的业务操作。 </li>\n</ul>\n\n这里用C0de8ug公开在github上面的项目的代码来说明\n\ndao层、service层以及service实现类的结构：\n\n<img src=\"https://img-blog.csdn.net/20170405203745886?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzQ4MjU5MjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\">\n\n项目中使用了mybatis框架进行数据库的操作 <br>\n以对于user的操作为例进行说明： <br>\nuserdao：\n\n<pre><code>public interface UserDao {\n\n    public List&lt;User&gt; findAll();\n\n    public User findById(String id);\n\n    public void update(User user);\n\n    public void add(User user);\n\n    public void delete(String id);\n\n    public User findByIdAndPassword(@Param(&quot;id&quot;) String username, @Param(&quot;password&quot;) String password);\n\n    public void updatePassword(@Param(&quot;userId&quot;) String id, @Param(&quot;password&quot;) String password);\n\n    User findByUsername(String username);\n}\n</code></pre>\n\n在接口中对方法进行了定义，在UserDao.xml中给出了sql语句实现 <br>\n在UserDao中，就对user这个实体的增删补查各类基本的操作进行了声明，并用mybatis框架进行实现。\n\n下面给出部分UserDao.xml的代码\n\n<pre><code>&lt;select id=&quot;findAll&quot; resultMap=&quot;user_map&quot;&gt;\n        SELECT * FROM user WHERE user_id != &#x27;admin&#x27;\n    &lt;/select&gt;\n\n    &lt;select id=&quot;findById&quot; parameterType=&quot;String&quot; resultMap=&quot;user_map&quot;&gt;\n        SELECT * FROM user WHERE user_id = #{value}\n    &lt;/select&gt;\n\n    &lt;update id=&quot;update&quot; parameterType=&quot;User&quot;&gt;\n        UPDATE user SET password = #{password} ,authority = #{authority} WHERE user_id = #{userId}\n    &lt;/update&gt;\n\n    &lt;update id=&quot;updatePassword&quot; parameterType=&quot;map&quot;&gt;\n        UPDATE user SET password = #{password} WHERE user_id = #{userId}\n    &lt;/update&gt;\n\n    &lt;insert id=&quot;add&quot; parameterType=&quot;User&quot;&gt;\n        INSERT INTO user(user_id,password,salt,role_ids,locked) VALUES(#{userId},#{password},#{salt},#{roleIdsStr},#{locked})\n    &lt;/insert&gt;\n\n    &lt;select id=&quot;findByIdAndPassword&quot; parameterType=&quot;map&quot; resultMap=&quot;user_map&quot;&gt;\n        SELECT * FROM user WHERE user_id = #{id} AND password = #{password}\n    &lt;/select&gt;</code></pre>\n\n下面来看看service层的代码\n\n<pre><code>import com.giit.www.entity.User;\nimport com.giit.www.entity.custom.UserVo;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Created by c0de8ug on 16-2-9.\n */\npublic interface UserBiz {\n    public List&lt;UserVo&gt; findAll() throws InvocationTargetException, IllegalAccessException;\n\n    public User findById(String id);\n\n    public void update(User user);\n\n    public void add(User user);\n\n    public void delete(String id);\n\n    public void changePassword(String userId, String newPassword);\n\n\n    public User findByUsername(String username);\n\n    public Set&lt;String&gt; findRoles(String username);\n\n    public Set&lt;String&gt; findPermissions(String username);\n}</code></pre>\n\n显然，service层里面的方法相较于dao层中的方法进行了一层包装，例如通过id查找用户，通过用户名查找用户，是在基础的操作上又增加了一层包装的，实现的是相对高级的操作。最后将这些操作在serviceimpl类中实现，代码比较多，这里还是只给出了部分代码，\n\n<pre><code>import com.giit.www.college.dao.StaffDao;\nimport com.giit.www.entity.Role;\nimport com.giit.www.entity.Staff;\nimport com.giit.www.entity.User;\nimport com.giit.www.entity.custom.UserVo;\nimport com.giit.www.system.dao.RoleDao;\nimport com.giit.www.system.dao.UserDao;\nimport com.giit.www.system.service.RoleBiz;\nimport com.giit.www.system.service.UserBiz;\nimport com.giit.www.util.PasswordHelper;\nimport org.apache.commons.beanutils.BeanUtils;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport javax.annotation.Resource;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\n\n/**\n * Created by c0de8ug on 16-2-9.\n */\n\n@Service\npublic class UserBizImpl implements UserBiz {\n\n    @Resource\n    UserDao userDao;\n\n    @Resource\n    RoleDao roleDao;\n\n    @Resource\n    StaffDao staffDao;\n\n    @Resource\n    private PasswordHelper passwordHelper;\n    @Resource(name = &quot;roleBizImpl&quot;)\n    private RoleBiz roleBiz;\n\n    @Override\n    public List&lt;UserVo&gt; findAll() throws InvocationTargetException, IllegalAccessException {\n        List&lt;UserVo&gt; userVoList = new ArrayList&lt;&gt;();\n        List userList = userDao.findAll();\n\n\n        Iterator iterator = userList.iterator();\n\n        while (iterator.hasNext()) {\n            StringBuilder s = new StringBuilder();\n            User user = (User) iterator.next();\n            List&lt;Long&gt; roleIds = user.getRoleIds();\n\n            UserVo userVo = new UserVo();\n            BeanUtils.copyProperties(userVo, user);\n\n            if (roleIds != null) {\n                int i = 0;\n                int size = roleIds.size();\n                for (; i &lt; size - 1; i++) {\n                    Role role = roleDao.findOne(roleIds.get(i));\n\n                    s.append(role.getDescription());\n                    s.append(&quot;,&quot;);\n                }\n                Role role = roleDao.findOne(roleIds.get(i));\n                s.append(role.getDescription());\n                userVo.setRoleIdsStr(s.toString());\n            }\n\n\n            userVoList.add(userVo);\n\n        }\n\n        return userVoList;\n    }</code></pre>\n\n由此看到，这样进行分层，访问数据库和进行service之间的分工明确，如果我需要对service的需求修改，无需改变dao层的代码，只要在实现上改变即可，如果我有访问数据库的新需求，那我也只要在dao层的代码中增添即可。', '2018-03-13 13:50:00', 'CSDN', 'https://blog.csdn.net/qq_34825926/article/details/69346084'),
(81, 'JAVA中Action层, Service层 ，modle层 和 Dao层的功能区分', '著一', 'JAVA', '首先这是现在最基本的分层方式，结合了SSH架构。modle层就是对应的数据库表的实体类。Dao层是使用了Hibernate连接数据库、操作数据库（增删改查）。Service层：引用对应的Dao数据库操作，在这里可以编写自己需要的代码（比如简单的判断）。Action层：引用对应的Service层，在这里结合Struts的配置文件，跳转到指定的页面，当然也能接受页面传递的请求数据，也可以做些计算处理。以上的Hibernate，Struts，都需要注入到Spring的配置文件中，Spring把这些联系起来，成为一个整体。\n\n一般java都是三层架构 数据访问层（dao） 业务逻辑层（biz 或者services） 界面层（ui） action 是业务层的一部分，是一个管理器 （总开关）（作用是取掉转）（取出前台界面的数据，调用biz方法，转发到下一个action或者页面）  模型成（model）一般是实体对象(把现实的的事物变成java中的对象)作用是一暂时存储数据方便持久化（存入数据库或者写入文件）而是 作为一个包裹封装一些数据来在不同的层以及各种java对象中使用  dao是数据访问层 就是用来访问数据库实现数据的持久化（把内存中的数据永久保存到硬盘中）\n\nDao主要做数据库的交互工作 Modle 是模型 存放你的实体类 Service 做相应的业务逻辑处理 Action是一个控制器\n\n首先解释面上意思，service是业务层，dao是数据访问层。\n呵呵，这个问题我曾经也有过，记得以前刚学编程的时候，都是在service里直接调用dao，service里面就new一个dao类对象，调用，其他有意义的事没做，也不明白有这个有什么用，参加工作久了以后就会知道，业务才是工作中的重中之重。\n我们都知道，标准主流现在的编程方式都是采用MVC综合设计模式，MVC本身不属于设计模式的一种，它描述的是一种结构，最终目的达到解耦，解耦说的意思是你更改某一层代码，不会影响我其他层代码，如果你会像spring这样的框架，你会了解面向接口编程，表示层调用控制层，控制层调用业务层，业务层调用数据访问层。初期也许都是new对象去调用下一层，比如你在业务层new一个DAO类的对象，调用DAO类方法访问数据库，这样写是不对的，因为在业务层中是不应该含有具体对象，最多只能有引用，如果有具体对象存在，就耦合了。当那个对象不存在，我还要修改业务的代码，这不符合逻辑。好比主板上内存坏了，我换内存，没必要连主板一起换。我不用知道内存是哪家生产，不用知道多大容量，只要是内存都可以插上这个接口使用。这就是MVC的意义。\n接下来说你感觉service的意义，其实因为你现在做东西分层次不是那么严格，在一个你们做东西业务本身也少，举个最简单的例子，你做一个分页的功能，数据1000条，你20条在一个页，你可以把这个功能写成工具类封装起来，然后在业务层里调用这个封装的方法，这才是业务里真正干得事，只要没访问数据库的，都要在业务里写。 \n再有不明白的追问，这是经验问题，呵呵，其实以后你就会懂。只是刚开始写的代码都是有个请求，我就去数据库取，业务几乎没有。\n怎么说呢，我不是理论帝。所以我讲讲自己的理解\n比说你现在用的是SSH框架，做一个用户模块：\n  1、假设现在你做这个功能会用到user表和权限表，那么你前台的页面访问action，action再去调用用户模块service，用户模块service判断你是操作user表还是权限表，如果你操作的是user表则service的实现类就去调用userDAO。如果是操作的是权限表则调用权限的DAO\n  2、也就是说DAO一定是和数据库的每张表一一对应，而service则不是。明白的没？其实你一个项目一个service和一个DAO其实也一样可以操作数据库，只不过那要是表非常多，出问题了，那找起来多麻烦，而且太乱了\n 3、好处就是你的整个项目非常系统化，和数据库的表能一致，而且功能模块化，这样以后维护或者改错比较容易，性能也高一些\n\n简单的说DAO层是跟数据库打交道的，service层是处理一些业务流程的，\n\n至于你说的为什么要用service层封装，我认为：一般来说，某一个程序的有些业务流程需要连接数据库，有些不需要与数据库打交道而直接是一些业务处理，这样就需要我们整合起来到service中去，这样可以起到一个更好的开发与维护的作用，同时也是MVC设计模式中model层功能的体现\n最基本的分层方式，结合了SSH架构。modle层就是对应的数据库表的实体类(如User类)。Dao层，一般可以再分为***Dao接口和***DaoImpl实现类，如userDao接口和userDaoImpl实现类,接口负责定义数据库curd的操作方法，实现类负责具体的实现，即实现Dao接口定义的方法。Service层，引用对应的Dao层数据库操作，在这里可以编写自己需要的代码（比如简单的判断），也可以再细分为Service接口和ServiceImpl实现类。Action层：引用对应的Service层实现业务逻辑，在这里结合Struts的配置文件，跳转到指定的页面，当然也能接受页面传递的请求数据，也可以做些计算处理、前端输入合法性检验(前端可修改网页绕过前端合法性检验，需在后台加一层)。\n     Action像是服务员，顾客点什么菜，菜上给几号桌，都是ta的职责；Service是厨师，action送来的菜单上的菜全是ta做的；Dao是厨房的小工，和原材料(通过hibernate操作数据库)打交道的事情全是ta管。\n\n     对象的调用流程：JSP—Action—Service—DAO—Hibernate—数据库。', '2018-03-14 09:50:00', 'CSDN', 'https://blog.csdn.net/limuzi13/article/details/44968819'),
(82, 'eclipse tomcat 无法加载导入的web项目，There are no resources that can be added or removed from the server. .', 'liouwei4083', 'Eclipse', '解决方法：\r\n1，找相同类型的工程(tomcat能引用的）<br />2，把新建项目里面的.project文件和.settings文件夹复制到导入的那个项目里面。\r\n或者\r\n1，新建一个&ldquo;Dynamic Web Project&rdquo;&nbsp;<br />2，把新建项目里面的.project文件和.settings文件夹复制到导入的那个项目里面。&nbsp;\r\n&nbsp;\r\n---------------------------------------------------------------------------------------------------------\r\neclipse创建出来的项目会有一些和项目有关的配置文件如下。\r\nclasspath文件：描述了项目依赖的所有文件，源码，jar包之类的。\r\n<ol>\r\n<li>源文件的具体位置（kind=\"src\"）</li>\r\n<li>运行的系统环境（kind=\"con\"）</li>\r\n<li>工程的library的具体位置信息(kind=\"lib\")</li>\r\n<li>在每个lib的xml子节点中，有关于它的其它配置信息（例如我配置的那个\"javadoc_location\"）</li>\r\n<li>项目的输出目录(kind=\"output\")</li>\r\n</ol>\r\nproject文件：描述了项目的基本架构信息，项目名称，构建命令，依赖列表等\r\n<ol>\r\n<li>工程名&lt;name&gt;&lt;/name&gt;</li>\r\n<li>工程注释描述&lt;comment&gt;&lt;/comment&gt;</li>\r\n<li>运行时需要的额外Eclipse插件&lt;natures&gt;&lt;/natures&gt;，及其具体加载方式信息&lt;buildSpec&gt;&lt;/buildSpec&gt;</li>\r\n</ol>\r\nsettings 文件夹下的文件：\r\njsdtscope--定义了web项目中的源码路径，也就意味着只有web project才会有这个配置。这些源码Eclipse会进行validate（如果validate没有禁用）。\r\norg.eclipse.core.resources.prefs--规定项目内的文件的编码。\r\norg.eclipse.jdt.core.prefs---指定了一些Java编译的特性，比如Java版本之类的，看文件每一行的key能猜出具体的用处。\r\norg.eclipse.m2e.core.prefs---一些maven相关的配置。\r\norg.eclipse.wst.common.component---规定了项目怎么组装成一个webapp，这里可以玩很多种组装方式。\r\n这些文件里的配置，一般上都可以通过项目右键属性里面进行配置修改，也可以直接修改这些文件。\r\n&nbsp;\r\n参考：\r\n<span style=\"line-height: 1.5;\">https://yq.aliyun.com/articles/2597?spm=5176.8091938.0.0.6At0bH</span>\r\nhttp://www.xuebuyuan.com/1361351.html', '2018-03-14 09:54:00', 'CSDN', 'https://www.cnblogs.com/liouwei4083/p/5810895.html'),
(83, 'eclipse从svn中导出web项目时不能添加到jboss中原因分析', '周二也被占用', 'Eclipse', '从svn中导出所有的svn项目时需要注意导出项目的分支，直接选择项目时，将会把svn中该项目的所有分支导出，因此选择完项目后需要进一步选择分支。选择branch，而不是tag下的项目\r\n\r\n拿到项目后，点击server添加项目时，系统提示There are no resources that can be added or removed from the server. .\r\n\r\n原因是：\r\n\r\n从svn中导入的项目默认为java项目，jboss服务器自然不能添加java项目\r\n\r\n需要点击项目的properties，找到Project Facets，勾选Dynamic web project，这样项目的目录结构就变成dynamic web project形式。\r\n\r\n另外如果项目是maven项目，也需要点击项目选择configure，再选择convert to maven project。\r\n\r\n补充1：\r\n\r\n这个问题的本质是tomcat或者jboss服务器是不会识别java项目的，必须将java项目转化为web项目。（这个补充是错误的，详见补充2）\r\n\r\n补充2：\r\n\r\n还有一个问题就是maven依赖关系，从svn下载完项目后，需要maven install，这样其他项目才能使用这个项目生成的构建。\r\n\r\n从svn下载的项目，应该选择branch，不应有选择tag和trunk。后两者都不是开发，一个是版本一个是最终形式，如果修改trunk就相当于修改了整个项目。\r\n\r\nmaven在使用时最好不用eclipse自带的，自己重新搭建一个maven仓库，需要配置maven的环境变量，另外需要使用公司局域网内的仓库下载jar。', '2018-03-14 10:09:00', 'CSDN', 'https://blog.csdn.net/u011350541/article/details/51910766'),
(84, '为什么要使用href=”javascript:void(0);”', '随风而至', 'JS', '为什么要使用href=”javascript:void(0);”\nhref=”javascript:void(0);”这个的含义是，让超链接去执行一个js函数，而不是去跳转到一个地址，\n而void(0)表示一个空的方法，也就是不执行js函数。\n为什么要使用href=”javascript:void(0);”\njavascript:是伪协议，表示url的内容通过javascript执行。void(0)表示不作任何操作，这样会防止链接跳转到其他页面。这么做往往是为了保留链接的样式，但不让链接执行实际操作，\n\n&lt;a href=&quot;javascript：void(0)&quot; onClick=&quot;window.open()&quot;&gt; 点击链接后，页面不动，只打开链接\n\n&lt;a href=&quot;#&quot; onclick=&quot;javascript:return false;&quot;&gt; 作用一样，但不同浏览器会有差异。\n\n \n\nhref=”javascript:void(0);”与href=”#&quot;的区别\n\n&lt;a href=&quot;javascript:void(0)&quot;&gt;点击&lt;/a&gt;点击链接后不会回到网页顶部 &lt;a href=&quot;#&quot;&gt;点击&lt;/a&gt; 点击后会回到网面顶部\n\n&quot;＃&quot;其实是包含了位置信息，例如默认的锚点是＃top 也就是网页的上端\n而javascript:void(0) 仅仅表示一个死链接这就是为什么有的时候页面很长浏览链接明明是＃可是跳动到了页首\n而javascript:void(0) 则不是如此所以调用脚本的时候最好用void(0)\n \n使用javascript的方法\n&lt;a href=&quot;#&quot; onclick=&quot;javascript:方法;return false;&quot;&gt;文字&lt;/a&gt;\n&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;javascript:方法;return false;&quot;&gt;文字&lt;/a&gt;\n \n补充 &lt;a href=&quot;javascript:hanshu();&quot;这样点击a标签就可以执行hanshu()函数了。', '2018-03-14 10:15:00', '博客园', 'https://www.cnblogs.com/cyjy/p/6182587.html'),
(85, 'js中 javascript:void(0) 用法详解', 'opper', 'JS', '<blockquote>void(0)用于执行某些处理，但是不整体刷新页面的情况下，下面小编就给大家详细介绍js中 javascript:void(0)的含义 ，需要的朋友可以参考下</blockquote>\njavascript:void(0)表示不做任何动作。如：\n\n<pre><code>\n&lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;alert(&#x27;ok&#x27;);&quot;&gt;&lt;/a&gt;\n</code></pre>\n这里表示这个链接不做跳转动作，执行onClick事件。\n\n我想使用过ajax的都常见这样的代码：\n<pre><code>\n&lt;a href=&quot;javascript:doTest2();void(0);&quot;&gt;here&lt;/a&gt;\n</code></pre>\n但这儿的void(0)究竟是何含义呢？\n\nJavascript中void是一个操作符，该操作符指定要计算一个表达式但是不返回值。\n\nvoid 操作符用法格式如下：\n1. javascript:void (expression)\n2. javascript:void expression\n\nexpression 是一个要计算的 Javascript 标准的表达式。表达式外侧的圆括号是选的，但是写上去是一个好习惯。 (实现版本   Navigator 3.0   )\n\n你以使用 void 操作符指定超级链接。表达式会被计算但是不会当前文档处装入任何内容。\n\n下面的代码创建了一个超级链接，当用户以后不会发生任何事。当用户链接时，void(0) 计算为 0，但 Javascript 上没有任何效果。\n\n<pre><code>\n&lt;A HREF=&quot;javascript:void(0)&quot;&gt;单此处什么也不会发生&lt;/A&gt;\n</code></pre>\n下面的代码创建了一个超级链接，用户单时会提交表单。\n<pre><code>\n&lt;A HREF=&quot;javascript:void(document.form.submit())&quot;&gt;\n单此处提交表单</A>\n</code></pre>\n\na href=#与 a href=javascript:void(0) 的区别 链接的几种办法\n\n#包含了一个位置信息\n\n默认的锚是#top 也就是网页的上端\n\n而javascript:void(0)   仅仅表示一个死链接\n\n这就是为什么有的时候页面很长浏览链接明明是#是\n\n跳动到了页首\n\n而javascript:void(0) 则不是如此\n\n所以调用脚本的时候最好用void(0)\n\n或者&lt;input onclick&gt;，&lt;div onclick&gt;等\n\n链接的几种办法\n1.window.open(\'\'url\'\')\n\n2.用自定义函数\n<pre><code>\n&lt;script&gt;\n   function openWin(tag,obj)\n   {\n    obj.target=&quot;_blank&quot;;\n    obj.href = &quot;Web/Substation/Substation.aspx?stationno=&quot;+tag;\n    obj.click();\n   }\n  &lt;/script&gt;\n\n&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;openWin(3,this)&quot;&gt;徐州&lt;/a&gt;\n\nwindow.location.href=&quot;&quot;\n</code></pre>\n总结：\n\n1 void(0)用于执行某些处理，但是不整体刷新页面的情况下,但是在需要对页面进行refresh的情况下，那就要仔细了。\n\n2 其实我们可以这样用&lt;a href=”javascript:void(document.form.submit())”&gt;，这句话会进行一次submit操作。那什么情 况下用void(0)比较多呢，无刷新，当然是Ajax了，看一下Ajax的web页面的话，一般都会看到有很多的void(0)，：） ，所以在使用void(0)之前,最好先想一想,这个页面是否需要整体刷新\n\n3 说白了，href=\"#\"这种形式会整体刷新页面，而 href=\"javascript:void(0)\" 则不会\n\n以上内容介绍了js中 javascript:void(0) 的含义，希望对大家有所帮助。', '2018-03-14 13:29:00', '脚本之家', 'http://www.jb51.net/article/70916.htm'),
(86, 'TrueType字体', 'flyingship', 'baike', 'TrueType字体，中文名称全真字体，是由Apple公司和Microsoft公司联合提出的一种采用新型数学字形描述技术的计算机字体。它用数学函数描述字体轮廓外形，含有字形构造、颜色填充、数字描述函数、流程条件控制、栅格处理控制、附加提示控制等指令。TrueType字体与PostScript字体、OpenType字体是主要的三种计算机矢量字体（又称轮廓字体、描边字体）。\r\n中文名 全真字体 外文名 Truetype 提出公司 Apple公司和Microsoft公司 性    质 计算机字体\r\n优势\r\nTrueType字体，中文名称全真字体。它具有如下优势：\r\n①真正的所见即所得字体。由于TrueType字体支持几乎所有输出设备，因而无论在屏幕、激光打印机、激光照排机上，还是在彩色喷墨打印机上，均能以设备的分辨率输出，因而输出很光滑。\r\n②支持字体嵌入技术。存盘时可将文件中使用的所有TrueType字体采用嵌入方式一并存入文件之中，使整个文件中所有字体可方便地传递到其它计算机中使用。嵌入技术可保证未安装相应字体的计算机能以原格式使用原字体打印。\r\n③操作系统的兼容性。MAC和PC机均支持TrueType字体，都可以在同名软件中直接打开应用文件而不需要替换字体。\r\n应用\r\n当程序开始使用特定大小的TrueType字体时，Windows「点阵化」字体。这就是说Windows使用TrueType字体档案中包括的「提示」对每个字元的连结直线和曲线的坐标进行缩放。这些提示可以补偿误差，避免合成的字元变得很难看（例如，在某些字体中，大写H的两竖应该一样宽，但盲目地缩放字体可能会导致其中一竖的图素比另一竖宽。有了提示就可以避免这些现象发生）。然後，每个字元的合成轮廓用于建立字元的点阵图，这些点阵图储存在记忆体以备将来使用。\r\n示例\r\n最初，Windows使用了13种TrueType字体，它们的字体名称如下：\r\nCourier New\r\nCourier New Bold\r\nCourier New Italic\r\nCourier New Bold Italic\r\nTimes New Roman\r\nTimes New Roman Bold\r\nTimes New Roman Italic\r\nTimes New Roman Bold Italic\r\nArial\r\nArial Bold\r\nArial Italic\r\nArial Bold Italic\r\nSymbol\r\n在新的Windows版本中有更多的TrueType字体。现在Windows Vista简体版的默认字体是微软雅黑体，Windows XP也可改装。\r\n辨析\r\n三个主要字体系列与点阵字体相似。Courier New是定宽字体，它看起来就像是打字机输出的字体。Times New Roman是Times字体的复制品，该字体最初为《Times of London》设计，并用在许多印刷材料上，它具有很好的可读性。Arial是Helvetica字体的复制品，是一种sans serif字体。Symbol字体包含了手写符号集。', '2018-03-14 17:13:00', '百度百科', 'https://baike.baidu.com/item/TrueType字体/6042683'),
(87, 'httppost 200、300、400、500 错误分析，HttpPost、HttpGet关于URL重定向区别', 'zhangxj_jack', 'http', '做一个HttpPost请求的时候，返回状态302，最终判断是因为HttpPost和HttpGet重定向是有区别的。\r\n构造PostMethod之前的步骤都相同，与GetMethod一样，构造PostMethod也需要一个URI参数。\r\n网站在做登录的时候，在创建了PostMethod的实例之后，需要给method实例填充表单 的值，在BBS的登录表单中需要有两个域，第一个是用户名（域名叫username），第二个是密码（域名叫password）。表单中的域用类 NameValuePair来表示，该类的构造函数第一个参数是域名，第二参数是该域的值；将表单所有的值设置到PostMethod中用方法 setRequestBody。另外由于BBS登录成功后会转向另外一个页面，但是HttpClient对于要求接受后继服务的请求，比如POST和 PUT，不支持自动转发，因此需要自己对页面转向做处理。\r\n错误代码行表现为：\r\n<code>\r\nint statusCode = httpClient.executeMethod(postMethod);\r\nHttpClient对于要求接受后继服务的请求，象POST和PUT等不能自动处理转发，会返回301或者302 \r\n</code>\r\n总结：\r\nHttpGet ge t =null;\r\nHttpParams conParams = httpClient.getParams();\r\nHttpConnectionParams.setConnectionTimeout(conParams, timeout);\r\nHttpConnectionParams.setSoTimeout(conParams, 600000);\r\nHttpResponse response=null;\r\ntry {\r\n    get=new HttpGet(url);\r\n    response = httpClient.execute(get);\r\n    response.getStatusLine().getStatusCode()\r\n} catch (Exception e) {\r\n    e.printStackTrace();\r\n}\r\nHttpGet可以支持获取重定向的内容，重定向成功\r\nresponse.getStatusLine().getStatusCode()返回200\r\n如果换成了HttpPost\r\nresponse.getStatusLine().getStatusCode()返回302\r\n======================================================================\r\n下面附上HTTP 1.1协议的详解\r\n======================================================================\r\n完整的 HTTP 1.1规范说明书来自于RFC 2616，你可以在http://www.rfc-editor.org/在线查阅。HTTP 1.1的状态码被标记为新特性，因为许多浏览器只支持 HTTP 1.0。你应只把状态码发送给支持 HTTP 1.1的客户端，支持协议版本可以通过调用request.getRequestProtocol来检查。\r\n本部分余下的内容会详细地介绍 HTTP 1.1中的状态码。这些状态码被分为五大类：\r\n<strong>100-199 用于指定客户端应相应的某些动作。\r\n200-299 用于表示请求成功。\r\n300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。\r\n400-499 用于指出客户端的错误。\r\n500-599 用于支持服务器错误。</strong>\r\n\r\nHttpServletResponse中的常量代表关联不同标准消息的状态码。在servlet程序中，你会更多地用到这些常量的标识来使用状态码。例如：你一般会使用response.setStatus(response.SC_NO_CONTENT)而不是 response.setStatus(204)，因为后者不易理解而且容易导致错误。但是，你应当注意到服务器允许对消息轻微的改变，而客户端只注意状态码的数字值。所以服务器可能只返回 HTTP/1.1 200 而不是 HTTP/1.1 200 OK。\r\n100 (Continue/继续)\r\n如果服务器收到头信息中带有100-continue的请求，这是指客户端询问是否可以在后续的请求中发送附件。在这种情况下，服务器用100(SC_CONTINUE)允许客户端继续或用417 (Expectation Failed)告诉客户端不同意接受附件。这个状态码是 HTTP 1.1中新加入的。\r\n101 (Switching Protocols/转换协议)\r\n101 (SC_SWITCHING_PROTOCOLS)状态码是指服务器将按照其上的头信息变为一个不同的协议。这是 HTTP 1.1中新加入的。\r\n200 (OK/正常)\r\n200 (SC_OK)的意思是一切正常。一般用于相应GET和POST请求。这个状态码对servlet是缺省的；如果没有调用setStatus方法的话，就会得到200。\r\n201 (Created/已创建)\r\n201 (SC_CREATED)表示服务器在请求的响应中建立了新文档；应在定位头信息中给出它的URL。\r\n202 (Accepted/接受)\r\n202 (SC_ACCEPTED)告诉客户端请求正在被执行，但还没有处理完。\r\n203 (Non-Authoritative Information/非官方信息)\r\n状态码203 (SC_NON_AUTHORITATIVE_INFORMATION)是表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确。这是 HTTP 1.1中新加入的。\r\n204 (No Content/无内容)\r\n在并没有新文档的情况下，204 (SC_NO_CONTENT)确保浏览器继续显示先前的文档。这各状态码对于用户周期性的重载某一页非常有用，并且你可以确定先前的页面是否已经更新。例如，某个servlet可能作如下操作：\r\nint pageVersion =Integer.parseInt(request.getParameter(\"pageVersion\"));\r\nif (pageVersion &gt;;= currentVersion) {\r\n   response.setStatus(response.SC_NO_CONTENT);\r\n} else {\r\n       // Create regular page\r\n}\r\n但是，这种方法对通过刷新响应头信息或等价的HTML标记自动重载的页面起作用，因为它会返回一个204状态码停止以后的重载。但基于JavaScript脚本的自动重载在这种情况下仍然需要能够起作用。可以阅读本书7.2 ( HTTP 1.1 Response Headers and Their Meaning/HTTP 1.1响应头信息以及他们的意义)部分的详细讨论。\r\n205 (Reset Content/重置内容)\r\n重置内容205 (SC_RESET_CONTENT)的意思是虽然没有新文档但浏览器要重置文档显示。这个状态码用于强迫浏览器清除表单域。这是 HTTP 1.1中新加入的。\r\n206 (Partial Content/局部内容)\r\n206 (SC_PARTIAL_CONTENT)是在服务器完成了一个包含Range头信息的局部请求时被发送的。这是 HTTP 1.1中新加入的。\r\n300 (Multiple Choices/多重选择)\r\n300 (SC_MULTIPLE_CHOICES)表示被请求的文档可以在多个地方找到，并将在返回的文档中列出来。如果服务器有首选设置，首选项将会被列于定位响应头信息中。\r\n301 (Moved Permanently)\r\n301 (SC_MOVED_PERMANENTLY)状态是指所请求的文档在别的地方；文档新的URL会在定位响应头信息中给出。浏览器会自动连接到新的URL。\r\n302 (Found/找到)\r\n与301有些类似，只是定位头信息中所给的URL应被理解为临时交换地址而不是永久的。注意：在 HTTP 1.0中，消息是临时移动(Moved Temporarily)的而不是被找到，因此HttpServletResponse中的常量是SC_MOVED_TEMPORARILY不是我们以为的SC_FOUND。\r\n注意\r\n代表状态码302的常量是SC_MOVED_TEMPORARILY而不是SC_FOUND。\r\n状态码302是非常有用的因为浏览器自动连接在定为响应头信息中给出的新URL。这非常有用，而且为此有一个专门的方法——sendRedirect。使用response.sendRedirect(url)比调用response.setStatus(response.SC_MOVED_TEMPORARILY)和response.setHeader(\"Location\", url)多几个好处。首先，response.sendRedirect(url)方法明显要简单和容易。第二，servlet自动建立一页保存这一连接以提供给那些不能自动转向的浏览器显示。最后，在servlet\r\n 2.2版本（J2EE中的版本）中，sendRedirect能够处理相对路径，自动转换为绝对路径。但是你只能在2.1版本中使用绝对路径。\r\n如果你将用户转向到站点的另一页中，你要用 HttpServletResponse 中的 encodeURL 方法传送URL。这么做可预防不断使用基于URL重写的会话跟踪的情况。URL重写是一种在你的网站跟踪不使用 cookies 的用户的方法。这是通过在每一个URL尾部附加路径信息实现的，但是 servlet 会话跟踪API会自动的注意这些细节。会话跟踪在第九章讨论，并且养成使用 encodeURL 的习惯会使以后添加会话跟踪的功能更容易很多。\r\n核心技巧\r\n如果你将用户转向到你的站点的其他页面，用 response.sendRedirect(response.encodeURL(url)) 的方式事先计划好会话跟踪(session tracking)要比只是调用 response.sendRedirect(url) 好的多。\r\n这个状态码有时可以与301交换使用。例如，如果你错误的访问了http://host/~user（路径信息不完整），有些服务器就会回复301状态码而有些则回复302。从技术上说，如果最初的请求是GET浏览器只是被假定自动转向。如果想了解更多细节，请看状态码307的讨论。\r\n303 (See Other/参见其他信息)\r\n这个状态码和 301、302 相似，只是如果最初的请求是 POST，那么新文档（在定位头信息中给出）药用 GET 找回。这个状态码是新加入 HTTP 1.1中的。\r\n304 (Not Modified/为修正)\r\n当客户端有一个缓存的文档，通过提供一个 If-Modified-Since 头信息可指出客户端只希望文档在指定日期之后有所修改时才会重载此文档，用这种方式可以进行有条件的请求。304 (SC_NOT_MODIFIED)是指缓冲的版本已经被更新并且客户端应刷新文档。另外，服务器将返回请求的文档及状态码 200。servlet一般情况下不会直接设置这个状态码。它们会实现getLastModified方法并根据修正日期让默认服务方法处理有条件的请求。这个方法的例程已在2.8部分(An Example Using Servlet\r\n Initialization and Page Modification Dates/一个使用servlet初始化和页面修正日期的例子)给出。\r\n305 (Use Proxy/使用代理)\r\n305 (SC_USE_PROXY)表示所请求的文档要通过定位头信息中的代理服务器获得。这个状态码是新加入 HTTP 1.1中的。\r\n307 (Temporary Redirect/临时重定向)\r\n浏览器处理307状态的规则与302相同。307状态被加入到 HTTP 1.1中是由于许多浏览器在收到302响应时即使是原始消息为POST的情况下仍然执行了错误的转向。只有在收到303响应时才假定浏览器会在POST请求时重定向。添加这个新的状态码的目的很明确：在响应为303时按照GET和POST请求转向；而在307响应时则按照GET请求转向而不是POST请求。注意：由于某些原因在HttpServletResponse中还没有与这个状态对应的常量。该状态码是新加入HTTP 1.1中的。\r\n注意\r\n在 HttpServletResponse 中没有 SC_TEMPORARY_REDIRECT 常量，所以你只能显示的使用307状态码。\r\n400 (Bad Request/错误请求)\r\n400 (SC_BAD_REQUEST)指出客户端请求中的语法错误。\r\n401 (Unauthorized/未授权)\r\n401 (SC_UNAUTHORIZED)表示客户端在授权头信息中没有有效的身份信息时访问受到密码保护的页面。这个响应必须包含一个WWW-Authenticate的授权信息头。例如，在本书4.5部分中的“Restricting Access to Web Pages./限制访问Web页。”\r\n403 (Forbidden/禁止)\r\n403 (SC_FORBIDDEN)的意思是除非拥有授权否则服务器拒绝提供所请求的资源。这个状态经常会由于服务器上的损坏文件或目录许可而引起。\r\n404 (Not Found/未找到)\r\n404 (SC_NOT_FOUND)状态每个网络程序员可能都遇到过，他告诉客户端所给的地址无法找到任何资源。它是表示“没有所访问页面”的标准方式。这个状态码是常用的响应并且在HttpServletResponse类中有专门的方法实现它：sendError(\"message\")。相对于setStatus使用sendError得好处是：服务器会自动生成一个错误页来显示错误信息。但是，Internet Explorer 5浏览器却默认忽略你发挥的错误页面并显示其自定义的错误提示页面，虽然微软这么做违反了 HTTP\r\n 规范。要关闭此功能，在工具菜单里，选择Internet选项，进入高级标签页，并确认“显示友好的 HTTP 错误信息”选项（在我的浏览器中是倒数第8各选项）没有被选。但是很少有用户知道此选项，因此这个特性被IE5隐藏了起来使用户无法看到你所返回给用户的信息。而其他主流浏览器及IE4都完全的显示服务器生成的错误提示页面。可以参考图6-3及6-4中的例子。\r\n核心警告\r\n默认情况下，IE5忽略服务端生成的错误提示页面。\r\n405 (Method Not Allowed/方法未允许)\r\n405 (SC_METHOD_NOT_ALLOWED)指出请求方法(GET, POST, HEAD, PUT, DELETE, 等)对某些特定的资源不允许使用。该状态码是新加入 HTTP 1.1中的。\r\n406 (Not Acceptable/无法访问)\r\n406 (SC_NOT_ACCEPTABLE)表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。见本书7.2部分中的表7.1(HTTP 1.1 Response Headers and Their Meaning/HTTP 1.1响应头信息以及他们的意义)中对MIME类型的介绍。406是新加入 HTTP 1.1中的。\r\n407 (Proxy Authentication Required/代理服务器认证要求)\r\n407 (SC_PROXY_AUTHENTICATION_REQUIRED)与401状态有些相似，只是这个状态用于代理服务器。该状态指出客户端必须通过代理服务器的认证。代理服务器返回一个Proxy-Authenticate响应头信息给客户端，这会引起客户端使用带有Proxy-Authorization请求的头信息重新连接。该状态码是新加入 HTTP 1.1中的。\r\n408 (Request Timeout/请求超时)\r\n408 (SC_REQUEST_TIMEOUT)是指服务端等待客户端发送请求的时间过长。该状态码是新加入 HTTP 1.1中的。\r\n409 (Conflict/冲突)\r\n该状态通常与PUT请求一同使用，409 (SC_CONFLICT)状态常被用于试图上传版本不正确的文件时。该状态码是新加入 HTTP 1.1中的。\r\n410 (Gone/已经不存在)\r\n410 (SC_GONE)告诉客户端所请求的文档已经不存在并且没有更新的地址。410状态不同于404，410是在指导文档已被移走的情况下使用，而404则用于未知原因的无法访问。该状态码是新加入 HTTP 1.1中的。\r\n411 (Length Required/需要数据长度)\r\n411 (SC_LENGTH_REQUIRED)表示服务器不能处理请求（假设为带有附件的POST请求），除非客户端发送Content-Length头信息指出发送给服务器的数据的大小。该状态是新加入 HTTP 1.1的。\r\n412 (Precondition Failed/先决条件错误)\r\n412 (SC_PRECONDITION_FAILED)状态指出请求头信息中的某些先决条件是错误的。该状态是新加入 HTTP 1.1的。\r\n413 (Request Entity Too Large/请求实体过大)\r\n413 (SC_REQUEST_ENTITY_TOO_LARGE)告诉客户端现在所请求的文档比服务器现在想要处理的要大。如果服务器认为能够过一段时间处理，则会包含一个Retry-After的响应头信息。该状态是新加入 HTTP 1.1的。\r\n414 (Request URI Too Long/请求URI过长)\r\n414 (SC_REQUEST_URI_TOO_LONG)状态用于在URI过长的情况时。这里所指的“URI”是指URL中主机、域名及端口号之后的内容。例如：在URL--http://www.y2k-disaster.com:8080/we/look/silly/now/中URI是指/we/look/silly/now/。该状态是新加入 HTTP 1.1的。\r\n415 (Unsupported Media Type/不支持的媒体格式)\r\n415 (SC_UNSUPPORTED_MEDIA_TYPE)意味着请求所带的附件的格式类型服务器不知道如何处理。该状态是新加入 HTTP 1.1的。\r\n416 (Requested Range Not Satisfiable/请求范围无法满足)\r\n416表示客户端包含了一个服务器无法满足的Range头信息的请求。该状态是新加入 HTTP 1.1的。奇怪的是，在servlet 2.1版本API的HttpServletResponse中并没有相应的常量代表该状态。\r\n注意\r\n在servlet 2.1的规范中，类HttpServletResponse并没有SC_REQUESTED_RANGE_NOT_SATISFIABLE 这样的常量，所以你只能直接使用416。在servlet 2.2版本之后都包含了此常量。\r\n417 (Expectation Failed/期望失败)\r\n如果服务器得到一个带有100-continue值的Expect请求头信息，这是指客户端正在询问是否可以在后面的请求中发送附件。在这种情况下，服务器也会用该状态(417)告诉浏览器服务器不接收该附件或用100 (SC_CONTINUE)状态告诉客户端可以继续发送附件。该状态是新加入 HTTP 1.1的。\r\n500 (Internal Server Error/内部服务器错误)\r\n500 (SC_INTERNAL_SERVER_ERROR) 是常用的“服务器错误”状态。该状态经常由CGI程序引起也可能（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。\r\n501 (Not Implemented/未实现)\r\n501 (SC_NOT_IMPLEMENTED)状态告诉客户端服务器不支持请求中要求的功能。例如，客户端执行了如PUT这样的服务器并不支持的命令。\r\n502 (Bad Gateway/错误的网关)\r\n502 (SC_BAD_GATEWAY)被用于充当代理或网关的服务器；该状态指出接收服务器接收到远端服务器的错误响应。\r\n503 (Service Unavailable/服务无法获得)\r\n状态码503 (SC_SERVICE_UNAVAILABLE)表示服务器由于在维护或已经超载而无法响应。例如，如果某些线程或数据库连接池已经没有空闲则servlet会返回这个头信息。服务器可提供一个Retry-After头信息告诉客户端什么时候可以在试一次。\r\n504 (Gateway Timeout/网关超时)\r\n该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。该状态是新加入 HTTP 1.1的。\r\n505 (HTTP Version Not Supported/不支持的 HTTP 版本)\r\n505 (SC_HTTP_VERSION_NOT_SUPPORTED)状态码是说服务器并不支持在请求中所标明 HTTP 版本。该状态是新加入 HTTP 1.1的。', '2018-03-15 11:19:00', 'CSDN', 'https://blog.csdn.net/ahzxj2012/article/details/52510491'),
(88, '二叉树的四种遍历方法笔记', 'flymey', 'math', '<ul><li>二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种<strong>次序</strong>依次<strong>访问</strong>二叉树中所有的结点，使得每个结点被访问依次且仅被访问一次。</li>\r\n</ul>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>前序</th>\r\n<th>中</th>\r\n<th>左</th>\r\n<th>右</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>中序</td>\r\n<td>左</td>\r\n<td>中</td>\r\n<td>右</td>\r\n</tr>\r\n<tr>\r\n<td>后序</td>\r\n<td>左</td>\r\n<td>右</td>\r\n<td>中</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<pre><code>st=&gt;start: 开始\r\ne=&gt;end: 结束\r\nop=&gt;operation: 根结点\r\nop2=&gt;operation: 左子树\r\n\r\nio=&gt;inputoutput: 右子树\r\ncond=&gt;condition: 二叉树是否为空？\r\n\r\nst-&gt;cond\r\ncond(yes)-&gt;e\r\ncond(no)-&gt;e\r\nop-&gt;op2-&gt;io-&gt;e\r\n</code></pre>\r\n<ul><li>前序遍历</li></ul>\r\n若树为空，则空操作返回。否则，先访问根节点，然后前序遍历左子树，再前序遍历右子树。（<em>W</em>）型 （中 左 右）\r\n<img src=\"https://images2017.cnblogs.com/blog/1258519/201711/1258519-20171101104826138-904063732.jpg\" alt=\"\">￼  \r\n<ul><li>中序遍历</li></ul>\r\n若树为空，则空操作返回。否则，从根节点开始（注意并不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历根节点的右子树。（<em>M</em>）型，（左 中 右）\r\n<img src=\"https://images2017.cnblogs.com/blog/1258519/201711/1258519-20171101104826998-2133273743.jpg\" alt=\"\">￼\r\n<ul><li>后续遍历</li></ul>\r\n若树为空，则空操作返回。否则，从左到右先叶子后节点的方式遍历访问左右子树，最后访问根节点。（左右中）逆时针型 （左 右 中）\r\n<img src=\"https://images2017.cnblogs.com/blog/1258519/201711/1258519-20171101104826138-358742940.jpg\" alt=\"\">￼\r\n<ul><li>层序遍历</li></ul>\r\n若树为空，则空操作返回。否则，从树的第一层，也就是根节点开始访问，从上到下逐层遍历，在同一层中，按从左到右的顺序结点逐个访问。\r\n<img src=\"https://images2017.cnblogs.com/blog/1258519/201711/1258519-20171101104826170-942797910.jpg\" alt=\"\">', '2018-03-15 13:50:00', '博客园', 'https://www.cnblogs.com/fly-me/p/wei-ti-jiaoer-cha-shu-de-si-zhong-bian-li-fang-fa.html'),
(89, 'EJB到底是什么？', 'Strugglion', 'JAVA', '1.&nbsp;我们不禁要问，什么是\"服务集群\"？什么是\"企业级开发\"？&nbsp;\n既然说了EJB 是为了\"服务集群\"和\"企业级开发\"，那么，总得说说什么是所谓的\"服务集群\"和\"企业级开发\"吧！这个问题其实挺关键的，因为J2EE 中并没有说明白，也没有具体的指标或者事例告诉广大程序员什么时候用EJB 什么时候不用。于是大家都产生一些联想，认为EJB\"分布式运算\"指得是\"负载均衡\"提高系统的运行效率。然而，估计很多人都搞错了，这个\"服务群集\"和\"分布式运算\"并没有根本解决运行负载的问题，尤其是针对<a title=\"MySQL知识库\" href=\"http://lib.csdn.net/base/mysql\" target=\"_blank\">数据库</a>的应用系统。为什么？\n我们先把EJB 打回原形给大家来慢慢分析。\n2.&nbsp;把EJB 掰开了揉碎了&nbsp;\n我们把EJB 的概念好好的分析一下，看看能发现些什么蛛丝马迹。\n3.1&nbsp;EJB 概念的剖析\n我们先看一下，EJB 的官方解释：商务软件的核心部分是它的业务逻辑。业务逻辑抽象了整个商务过程的流程，并使用计算机语言将他们实现。……J2EE 对于这个问题的处理方法是将业务逻辑从客户端软件中抽取出来，封装在一个组件中。这个组件运行在一个独立的服务器上，客户端软件通过网络调用组件提供的服务以实现业务逻辑，而客户端软件的功能单纯到只负责发送调用请求和显示处理结果。在J2EE 中，这个运行在一个独立的服务器上，并封装了业务逻辑的组件就是EJB（Enterprise&nbsp;<a title=\"Java EE知识库\" href=\"http://lib.csdn.net/base/javaee\" target=\"_blank\">Java</a>Bean）组件。这其中我们主要关注这么几点，我们来逐条剖析：\n剖析1：所谓：\"业务逻辑\"&nbsp;我们注意到在EJB 的概念中主要提到的就是\"业务逻辑\"的封装，而这个业务逻辑到底是什么？说的那么悬乎，其实这个所谓的\"业务逻辑\"我们完全可以理解成执行特定任务的\"类\"。\n剖析2：所谓：\"将业务逻辑从客户端软件中抽取出来，封装在组件中……运行在一个服务器上\"既然我们知道了\"业务逻辑\"的概念就是执行特定任务的\"类\"，那么，什么叫\"从客户端软件中抽取出来\"？其实，这个就是把原来放到客户端的\"类\"，拿出来不放到客户端了，放到一个组件中，并将这个组件放到一个服务器上去运行。\n3.2 把EJB 这个概念变成大白话&nbsp;\n变成大白话就是，\"把你编写的软件中那些需要执行制定的任务的类，不放到客户端软件上了，而是给他打成包放到一个服务器上了\"。\n3.3 发现问题了&nbsp;\n不管是用\"八股文\"说，还是用大白话说这个EJB 概念都提到了一个词--\"客户端软件\"。\"客户端软件\"？难道EJB 的概念中说的是C/S 软件？是的，没错！EJB 就是将那些\"类\"放到一个服务器上，用C/S 形式的软件客户端对服务器上的\"类\"进行调用。快崩溃了吧！EJB 和JSP 有什么关系？EJB 和JSP 有关系，但是关系还真不怎么大，至多是在JSP 的服务器端调用远端服务上的EJB 类，仅此而已。\n4&nbsp;.1 EJB 的最底层究竟是什么&nbsp;\n我们揭开了EJB\"八股\"概念的真谛，那么，再来分析EJB 的底层实现技术，通过底层实现技术来分析EJB 的工作方式。\n4.2 EJB 的实现技术\nEJB 是运行在独立服务器上的组件，客户端是通过网络对EJB 对象进行调用的。在Java中，能够实现远程对象调用的技术是RMI，而EJB 技术基础正是RMI。通过RMI 技术，J2EE将EJB 组件创建为远程对象，客户端就可以通过网络调用EJB 对象了。\n4.3 看看RMI 是什么东东\n在说RMI 之前，需要理解两个名词：对象的序列化分布式计算与RPC\n名词1：对象的序列化\n对象的序列化概念：对象的序列化过程就是将对象状态转换成字节流和从字节流恢复对象。将对象状态转换成字节流之后，可以用java.io 包中的各种字节流类将其保存到文件中，或者通过网络连接将对象数据发送到另一个主机。上面的说法有点\"八股\"，我们不妨再用白话解释一下：对象的序列化就是将你程序中实例化的某个类的对象，比如，你自定一个类MyClass，或者任何一个类的对象，将它转换成字节数组，也就是说可以放到一个byte 数组中，这时候，你既然已经把一个对象放到了byte数组中，那么你当然就可以随便处置了它了，用得最多的就是把他发送到网络上远程的计算机上了。如图2 11所示。\n<img src=\"http://new.51cto.com/files/uploadimg/20090415/104306946.jpg\" alt=\"\">&nbsp;\n名词2：分布式计算与RPC&nbsp;RPC 并不是一个纯粹的Java 概念，因为在Java 诞生之前就已经有了RPC 的这个概念，RPC是\"Remote Procedure Call\"的缩写，也就是\"远程过程调用\"。在Java 之前的大多数编程语言，如，Fortran、C、COBOL 等等，都是过程性的语言，而不是面向对象的。所以，这些编程语言很自然地用过程表示工作，如，函数或子程序，让其在网络上另一台机器上执行。说白了，就是本地计算机调用远程计算机上的一个函数。如图2 12所示。\n<img src=\"http://new.51cto.com/files/uploadimg/20090415/104653662.jpg\" alt=\"\">&nbsp;\n名词3：二者结合就是RMI&nbsp;RMI 英文全称是\"Remote Method Invocation\"，它的中文名称是\"远程方法调用\"，它就是利用Java 对象序列化的机制实现分布式计算，实现远程类对象的实例化以及调用的方法。说的更清楚些，就是利用对象序列化来实现远程调用，也就是上面两个概念的结合体，利用这个方法来调用远程的类的时候，就不需要编写Socket 程序了，也不需要把对象进行序列化操作，直接调用就行了非常方便。远程方法调用是一种计算机之间对象互相调用对方函数，启动对方进程的一种机制，使用这种机制，某一台计算机上的对象在调用另外一台计算机上的方法时，使用的程序语法规则和在本地机上对象间的方法调用的语法规则一样。如图2 13所示。<img src=\"http://new.51cto.com/files/uploadimg/20090415/104733136.jpg\" alt=\"\">\n4.4 优点\n这种机制给分布计算的系统设计、编程都带来了极大的方便。只要按照RMI 规则设计程序，可以不必再过问在RMI 之下的网络细节了，如：TCP 和Socket 等等。任意两台计算机之间的通讯完全由RMI 负责。调用远程计算机上的对象就像本地对象一样方便。RMI 可将完整的对象作为参数和返回值进行传递，而不仅仅是预定义的数据类型。也就是说，可以将类似Java 哈西表这样的复杂类型作为一个参数进行传递。\n4.5 缺点&nbsp;\n如果是较为简单的方法调用，其执行效率也许会比本地执行慢很多，即使和远程Socket机制的简单数据返回的应用相比，也会慢一些，原因是，其在网络间需要传递的信息不仅仅包含该函数的返回值信息，还会包含该对象序列化后的字节内容。\n4.6 EJB 是以RMI 为基础的\n&nbsp;\n通过RMI 技术，J2EE 将EJB 组件创建为远程对象，EJB 虽然用了RMI 技术，但是却只需要定义远程接口而无需生成他们的实现类，这样就将RMI 技术中的一些细节问题屏蔽了。但不管怎么说，EJB 的基础仍然是RMI，所以，如果你想了解EJB 的原理，只要把RMI的原理搞清楚就行了。你也就弄清楚了什么时候用EJB 什么时候不需要用EJB 了。\n5.&nbsp;EJB 中所谓的\"服务群集\"&nbsp;\n既然已经知道了，RMI 是将各种任务与功能的类放到不同的服务器上，然后通过各个服务器间建立的调用规则实现分布式的运算，也就明白EJB 所谓的\"服务群集\"的概念。就是将原来在一个计算机上运算的几个类，分别放到其他计算机上去运行，以便分担运行这几个类所需要占用的CPU 和内存资源。同时，也可以将不同的软件功能模块放到不同的服务器上，当需要修改某些功能的时候直接修改这些服务器上的类就行了，修改以后所有客户端的软件都被修改了。如图2 14所示。<img src=\"http://new.51cto.com/files/uploadimg/20090415/104900535.jpg\" alt=\"\">\n6.&nbsp;这种部署难道是无懈可击&nbsp;\n图2 14所示的这个\"服务群集\"看似\"无懈可击\"，其实是它这个图没有画完整，我们来把这个图画完整，再来看看有什么问题没有。\n6.1 瓶颈在数据库端&nbsp;\n仔细观察之后，发现这种配置是有瓶颈的，如图2 15所示。\n<img src=\"http://new.51cto.com/files/uploadimg/20090415/105042542.jpg\" alt=\"\">&nbsp;\n我们看看图2 15的结构图，现在如果想实现各个服务器针对同一个数据库的查询，那么，不管你部署多少个功能服务器，都需要针对一个数据库服务器进行查询操作。也就是说，不管你的\"计算\"有多么\"分布\"也同样需要从一台服务器中取得数据。虽然，看起来将各个功能模块分布在不同的服务器上从而分担了各个主计算机的CPU 资源，然而，真正的瓶颈并不在这里，而是，数据库服务器那里。数据库服务器都会非常忙的应付各个服务器的查询及操作请求。因此，通过这个结构图使我们了解到了EJB 根本不能完全解决负载的问题，因为，瓶颈并不在功能模块的所在位置，而是在数据库服务器这里。\n6.2 假如分开数据库，数据共享怎么办&nbsp;\n有的读者一定会想到下面的这个应用结构，如图2 16所示。\n<img src=\"http://new.51cto.com/files/uploadimg/20090415/105114909.jpg\" alt=\"\">&nbsp;\n就是把每一个功能服务器后面都部署一个数据库，这样不就解决了上节所说的问题了吗？是的解决了数据库查询负载的问题，然而又出现了新的问题，就是\"数据共享\"的问题就又不容易解决了。\n6.3 网络面临较大压力，让你的应用慢如老牛\n&nbsp;\n我们再向前翻看看如图2 15所示的这种<a title=\"大型网站架构知识库\" href=\"http://lib.csdn.net/base/architecture\" target=\"_blank\">架构</a>中存在两个网络，一个是\"A 网\"一个是\"B网\"，这两个网络是不同的。\"B 网\"往往是局域网，一般带宽是10M/100M，速度较快，因此到还好说，然而，\"A 网\"往往是互联网或者是利用电信网络互联VPN 网或称广域网。\"A 网\"的特点是带宽一般较窄，如ADSL 的网络仅仅有512K-2M 的带宽，由于广域网互联的成本较高，所以一般不会有较高的带宽。而在这个网络上恰恰跑的是功能模块和客户端软件之间交换的数据，而这部分数据恰恰优势非常占用带宽的。因此，这个应用架构其运行速度可以想见是多么的慢了。说句不夸张的话，有点想老牛拉破车一样的慢。一个如老牛的系统：目前在中国互联网做运营商网络管理系统的一个大公司，它的一个早期的网管软件就是采用了这种架构来做的C/S 结构的应用系统。有一次，我作为评估者来对其应用系统进行评估，将其部署到一个非运营商大型的网络中的时候，便出现了我们上述描述的情况，速度已经到了难以忍受的地步，打开一个流量图，有时候需要用15分钟的时间才能呈现完整。然而，该系统在开发阶段并没有发现这个问题，为什么呢？因为，他们没有考虑到应用的实际用户连接网络的复杂性，从而给该公司造成较大损失，以至于，这个开发架构被最终遗弃。\n&nbsp;\n7.&nbsp;EJB 活学活用，J2EE 不是必须使用EJB&nbsp;\n通过上面小节的讲解似乎好像EJB 和开发Web 应用的B/S 结构的系统关系并不大，其实倒也不然。我们如果把\"客户端程序\"理解成某一台服务器，这样也是可以被应用的，而且，如果是服务器互相之间做EJB 的调用的话，也就不存在广域网带宽限制的问题了。但是，如下情况尽量就不要使用EJB 了：1、较为简单的纯Web 应用开发，不需要用EJB。2、需要与其他服务程序配合使用的应用，但调用或返回的自定义的网络协议可以解决的应用程序,不需要使用EJB。3、较多人并发访问的C/S 结构的应用程序，尽量不要使用EJB。\n<strong>总结：</strong>\na.EJB实现原理：&nbsp;就是把原来放到客户端实现的代码放到服务器端，并依靠RMI进行通信。\nb.RMI实现原理&nbsp;：就是通过Java对象可序列化机制实现分布计算。\nc.服务器集群：&nbsp;就是通过RMI的通信，连接不同功能模块的服务器，以实现一个完整的功能。', '2018-03-15 16:36:00', '博客园', 'https://www.cnblogs.com/strugglion/p/6027318.html'),
(90, '水塘抽样(Reservoir Sampling)问题', 'Strugglion', 'Math', '水塘抽样是一系列的随机算法，其目的在于从包含n个项目的集合S中选取k个样本，其中n为一很大或未知的数量，尤其适用于不能把所有n个项目都存放到主内存的情况。\n在高德纳的计算机程序设计艺术中，有如下问题：<strong>可否在一未知大小的集合中，随机取出一元素？</strong>。或者是Google面试题： I have a linked list of numbers of length N. N is very large and I don’t know in advance the exact value of N. How can I most efficiently write a function that will return k completely random numbers from the list（中文简化的意思就是：<strong>在不知道文件总行数的情况下，如何从文件中随机的抽取一行？</strong>）。两题的核心意思都是在总数不知道的情况下如何等概率地从中抽取一行？即是说如果最后发现文字档共有N行，则每一行被抽取的概率均为1/N？\n我们可以：定义取出的行号为choice，第一次直接以第一行作为取出行 choice ，而后第二次以二分之一概率决定是否用第二行替换 choice ，第三次以三分之一的概率决定是否以第三行替换 choice ……，以此类推。由上面的分析我们可以得出结论，<strong>在取第n个数据的时候，我们生成一个0到1的随机数p，如果p小于1/n，保留第n个数。大于1/n，继续保留前面的数。直到数据流结束，返回此数，算法结束。</strong>\n<h2><strong>问题一</strong></h2>\n首先考虑k为1的情况，即：给定一个长度很大或者长度未知数据流，限定对每个元素只能访问一次，写出一个随机选择算法，使得所有元素被选中的概率相等。\n设当前读取的是第n个元素，采用归纳法分析如下：\n<ol>\n<li>n = 1 时，只有一个元素，直接返回即可，概率为1。</li>\n<li>n = 2 时，需要等概率返回前两个元素，显然概率为1/2。可以生成一个0～1之间的随机数p，p &lt; 0.5 时返回第一个，否则返回第二个。</li>\n<li>n = 3 时，要求每个元素返回的概率为1/3。注意此时前两个元素留下来的概率均为1/2。做法是：生成一个0～1之间的随机数，若&lt;1/3，则返回第三个，否则返回上一步留下的那个。元素1和2留下的概率均为：1/2 * (1 - 1/3) = 1/3，即上一步留下的概率乘以这一步留下（即元素3不留下）的概率。</li>\n<li>假设 n = m 时，前n个元素留下的概率均为：1/n = 1/m；</li>\n<li>那么 n = m+1 时，生成0～1之间的随机数并判断是否&lt;1/(m+1)，若是则留下元素m+1，否则留下上一步留下的元素。这样一来，元素m+1留下的概率为1/(m+1)，前m个元素留下来的概率均为：1/m * (1 - 1/(m+1)) = 1/(m+1)，也就是1/n。</li>\n<li>综上可知，算法成立。</li>\n</ol>\n&nbsp;\n<h2>问题二</h2>\n将问题一中的条件变为，k为任意整数的情况，即要求最终返回的元素有k个，这就是水塘抽样（Reservoir Sampling）问题。要求是：取到第n个元素时，前n个元素被留下的几率相等，即k/n。\n算法同上面思路类似，将1/n换乘k/n即可。在取第n个数据的时候，我们生成一个0到1的随机数p，如果p小于k/n，替换池中任意一个为第n个数。大于k/n，继续保留前面的数。直到数据流结束，返回此k个数。但是<strong>为了保证计算机计算分数额准确性，一般是生成一个0到n的随机数，跟k相比，道理是一样的</strong>。\n同样采用归纳法来分析：\n<ol>\n<li>初始情况 n &lt;= k：此时每个元素留下的概率均为1。</li>\n<li>当 n = k+1 时，第k+1个元素留下的概率为k/(k+1)，前k个元素留下的概率均为：k/k * (1 - k/(k+1) * 1/k) = k/(k+1)，即上一步留下的概率乘以这一步留下的概率。</li>\n<li>假设 n = m 时，每个元素留下的概率均为 k/n = k/m。</li>\n<li>那么，当 n = m+1 时，第m+1个元素留下的概率为1/(m+1)，前m个元素留下的概率均为：k/m * (1 - k/(m+1) * 1/k) = k/(m+1)，其中：k/m为上一步留下来的概率，k/(m+1) * 1/k 为这一步不能留下来的概率（第m+1个留下来，同时池中一个元素被踢出的概率）。</li>\n<li>综上可知，算法成立。</li>\n</ol>\n&nbsp;\n伪代码如下：\n<pre><code>//stream代表数据流\n//reservoir代表返回长度为k的池塘\n\n//从stream中取前k个放入reservoir；\nfor ( int i = 1; i < k; i++)\n    reservoir[i] = stream[i];\nfor (i = k; stream != null; i++) {\n    p = random(0, i);\n    if (p < k) reservoir[p] = stream[i];\nreturn reservoir;</code></pre>', '2018-03-15 17:00:00', '博客园', 'http://www.cnblogs.com/strugglion/p/6424874.html'),
(91, '程序猿的日常——恒生TA接口分享', '盛世阳光', 'baike', '<img src=\"https://img3.doubanio.com/view/note/large/public/p38882652.jpg\" alt=\"\"/>\r\n由于美国体育用品生产商Nike（耐克）公司的口号“JustdoIT”，使大批的有志青年误入了互联网行业，走上了程序猿这条不归路。\r\n<img src=\"https://img1.doubanio.com/view/note/large/public/p38882748.jpg\" alt=\"\"/>\r\n对于网站的服务与建设来说，程序猿是必不可少得一环。基于多年的工作经验，和小编一起工作的程序猿接触过不少金融公司的网站，这些金融网站有一个共同特点，页面中都会有产品数据、信息披露等金融特色信息的体现。然而金融数据具有及时性和精准性，这就需要用到恒生TA数据。接下来，小编就给大家分享一下我们对接恒生TA的经验。（有木有很兴奋！！）\r\n<img src=\"https://img3.doubanio.com/view/note/large/public/p38882841.jpg\" alt=\"\"/><\r\n1、恒生的临时库<br>2、恒生API<br>3、恒生CRM系统（基于恒生数据中心）\r\n以下是对三个方法的一些介绍。<br>\r\n方法一，恒生临时库：\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恒生会提供临时库，可以定时更新。从临时库中获取数据。\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为是临时数据库，真正的数据还在恒生的数据中心，所以，只限于读取。如果网站的需求就是读取信息，这个方法还是很好用的。\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于可以直接调用，直接执行sql查询语句。技术门槛比较低，开发速度还是很快的。\r\n方法二，恒生的API：\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恒生提供一个开发手册，有详细的说明，接口返回 JSON。用起来同样很方便。\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面就引用一段开发手册中的实例，可以更直观的了解这个接口：\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过下面的请求地址：<br>&nbsp;<br><a rel=\"nofollow\" href=\"http://localhost:7001/openapi/trustbusrestful/query/queryonlinesellproduct?partner_id=1234\" target=\"_blank\">http://localhost:7001/openapi/trustbusrestful/query/queryonlinesellproduct?partner_id=1234</a>\r\n返回下段Json格式的报文，至于报文的含义，请参照接口文档。\r\n{&quot;code&quot;:&quot;ETS-5BP0000&quot;,&quot;message&quot;:null,&quot;details&quot;:null,&quot;extra&quot;:{},&quot;results&quot;:[{&quot;bank_no&quot;:&quot;920&quot;,&quot;bank_name&quot;:&quot;平安银行<br>&quot;,&quot;capital_mode&quot;:&quot;M&quot;,&quot;detail_fund_way&quot;:&quot;01&quot;,&quot;limit_per_payment&quot;:&quot;50&quot;,&quot;limit_per_day&quot;:&quot;100&quot;,&quot;limit_per_month&quot;:&quot;500&quot;,&quot;is_support_fast_mode&quot;:&quot;1&quot;},{&quot;bank_no&quot;:&quot;009&quot;,&quot;bank_name&quot;:&quot;光大银行<br>&quot;,&quot;capital_mode&quot;:&quot;M&quot;,&quot;detail_fund_way&quot;:&quot;01&quot;,&quot;limit_per_payment&quot;:&quot;50&quot;,&quot;limit_pe\r\n由于直接调用数据中心的API，信息更及时，更准确。需要详细阅读接口文档，如果遇到了代码问题，届时还需要恒生方面的技术支持。\r\n方法三，恒生CRM：\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于恒生接口开发的CRM。\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在恒生的API上开发的CRM，很多功能都是整合开发的，更符合用户的一些需求，还有一些定制服务。\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时，恒生CRM还提供webservice接口，可以直接调用恒生CRM处理过的数据，很多功能需求还可能是定制开发的，需要比较紧密的与恒生的开发人员进行沟通。\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接口注意事项：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>以上这3个方法的接口服务器，都要与应用服务器在同一个内网。\r\n\r\n<img src=\"https://img3.doubanio.com/view/note/large/public/p38882944.jpg\" alt=\"\"/>', '2018-03-16 09:45:00', '豆瓣', 'https://www.douban.com/note/593426869/'),
(92, 'ondragstart 事件', 'ssisse', 'JS', '<strong>定义和用法</strong>\r\nondragstart 事件在用户开始拖动元素或选择的文本时触发。\r\n拖放是 HTML5 中非常常见的功能。 更多信息可以查看我们 HTML 教程中的 HTML5 拖放。\r\n注意： 为了让元素可拖动，需要使用 HTML5 draggable 属性。\r\n提示： 链接和图片默认是可拖动的，不需要 draggable 属性。\r\n在拖放的过程中会触发以下事件：\r\n<ul>\r\n<li>在拖动目标上触发事件 (源元素):</li>\r\n<li>ondragstart - 用户开始拖动元素时触发</li>\r\n<li>ondrag - 元素正在拖动时触发</li>\r\n<li>ondragend - 用户完成元素拖动后触发</li>\r\n</ul>\r\n释放目标时触发的事件:\r\n<ul>\r\n<li>ondragenter - 当被鼠标拖动的对象进入其容器范围内时触发此事件</li>\r\n<li>ondragover - 当某被拖动的对象在另一对象容器范围内拖动时触发此事件</li>\r\n<li>ondragleave - 当被鼠标拖动的对象离开其容器范围内时触发此事件</li>\r\n<li>ondrop - 在一个拖动过程中，释放鼠标键时触发此事件</li>\r\n</ul>\r\n语法\r\nHTML 中：\r\n<code>&lt;element ondragstart=\"myScript\"&gt;</code>\r\nJavaScript 中：\r\n<code>object.ondragstart=function(){myScript};</code>\r\nJavaScript 中, 使用 addEventListener() 方法:\r\n<code>object.addEventListener(\"dragstart\", myScript);</code>\r\n实例\r\n以下实例演示了所有的拖放事件：\r\n<pre><code>/* 拖动时触发*/   \r\ndocument.addEventListener(\"dragstart\", function(event) {   \r\n    //dataTransfer.setData()方法设置数据类型和拖动的数据   \r\n    event.dataTransfer.setData(\"Text\", event.target.id);   \r\n    // 拖动 p 元素时输出一些文本   \r\n    document.getElementById(\"demo\").innerHTML = \"开始拖动 p 元素.\";   \r\n    //修改拖动元素的透明度   \r\n    event.target.style.opacity = \"0.4\";   \r\n});   \r\n//在拖动p元素的同时,改变输出文本的颜色   \r\ndocument.addEventListener(\"drag\", function(event) {   \r\n    document.getElementById(\"demo\").style.color = \"red\";   \r\n});   \r\n// 当拖完p元素输出一些文本元素和重置透明度   \r\ndocument.addEventListener(\"dragend\", function(event) {   \r\n    document.getElementById(\"demo\").innerHTML = \"完成 p 元素的拖动\";   \r\n    event.target.style.opacity = \"1\";   \r\n});   \r\n/* 拖动完成后触发 */   \r\n// 当p元素完成拖动进入droptarget,改变div的边框样式   \r\ndocument.addEventListener(\"dragenter\", function(event) {   \r\n    if ( event.target.className == \"droptarget\" ) {   \r\n        event.target.style.border = \"3px dotted red\";   \r\n    }   \r\n});   \r\n// 默认情况下,数据/元素不能在其他元素中被拖放。对于drop我们必须防止元素的默认处理   \r\ndocument.addEventListener(\"dragover\", function(event) {   \r\n    event.preventDefault();   \r\n});   \r\n// 当可拖放的p元素离开droptarget，重置div的边框样式   \r\ndocument.addEventListener(\"dragleave\", function(event) {   \r\n    if ( event.target.className == \"droptarget\" ) {   \r\n        event.target.style.border = \"\";   \r\n    }   \r\n});   \r\n/*对于drop,防止浏览器的默认处理数据(在drop中链接是默认打开)  \r\n复位输出文本的颜色和DIV的边框颜色  \r\n利用dataTransfer.getData()方法获得拖放数据  \r\n拖拖的数据元素id(\"drag1\")  \r\n拖拽元素附加到drop元素*/   \r\ndocument.addEventListener(\"drop\", function(event) {   \r\n    event.preventDefault();   \r\n    if ( event.target.className == \"droptarget\" ) {   \r\n        document.getElementById(\"demo\").style.color = \"\";   \r\n        event.target.style.border = \"\";   \r\n        var data = event.dataTransfer.getData(\"Text\");   \r\n        event.target.appendChild(document.getElementById(data));   \r\n    }   \r\n});</code></pre>', '2018-03-16 10:01:00', 'CSDN', 'https://blog.csdn.net/ssisse/article/details/52628739');
INSERT INTO `wu_blog` (`id`, `post_title`, `post_author`, `post_type`, `post_content`, `post_date`, `post_from`, `post_link`) VALUES
(93, '出现HTTP: 401 的时候的解析思路', 'DXSmile', 'http', '<h3>说在前面的话:</h3>\r\n最近工作确实比较忙了一些, 毕竟是年初,很多事情都需要重新布置, 一年之计在于春嘛;<br>\r\n这几天,新来了一些小伙伴, 在他们接下来的一些工作中, 也发现了一些比较有意思的bug, 有些bug确属不应该,不过也有些bug比较有意思, 有时间了,我会慢慢的整理一些发上来和大家分享, 今天先分享一个:  HTTP: 401\r\n<h3>介绍: 什么是HTTP: 401</h3>\r\n时常做应用开发的伙伴们,估计大家对这个数字并不陌生, 毕竟只要你的应用需要申请服务器数据, 那么难免会遇到它,  当然我的新来的这批小伙伴们也比较幸运的遇到了它, 嗯, 确实比较幸运,  因为bug出现,就是学习和进步的时候到了!<br>\r\n所以,我也就花了一些空余时间来为大家整理了一下;\r\n<h3>常见的HTTP:401错误码:</h3>\r\n<pre><code>401.1 - Logon failed. -登陆失败\r\n401.2 - Logon failed due to server configuration.-基于服务器配置的登陆失败\r\n401.3 - Unauthorized due to ACL on resource.-资源访问控制列表返回未授权\r\n401.4 - Authorization failed by filter.-服务器filter返回未授权\r\n401.5 - Authorization failed by ISAPI/CGI application.-服务器ISAPI/CGI返回未授权\r\n</code></pre>\r\n<strong>对于401,我们可以用一句话描述它:那就是 HTTP 401 错误 - 未授权： (Unauthorized)   [绝大多数情况下]</strong>\r\n简单的来说: 就是你的Web服务器认为，客户端发送的 HTTP 数据流是正确的，但进入网址 (URL) 资源 ， 需要用户身份验证 ， 而相关信息 尚未被提供, 或 已提供但没有通过授权测试。<br>\r\n这就是通常所知的“ HTTP 基本验证 ”。<br>\r\n而需客户端提供的验证请求在 HTTP 协议中被定义为 WWW – 验证标头字段 (WWW-Authenticate header field) 。\r\n<h3>那这个401错误码 什么时候会产生呢?</h3>\r\n<h4>HTTP 循环中的 401错误</h4>\r\n任何客户端 ( 比如浏览器,比如APP等等 ) ，都需要通过以下循环去向服务器请求数据:\r\n<pre><code>1.首先从你的站点的 IP 名称 ( 即您站点的网址-URL, 不带起始的 ‘http://\') 获得一个 IP 地址。这是由DNS来解析的;\r\n2.接着, 打开一个 IP 套接字 (socket) 连接到该 IP 地址。\r\n3.通过该套接字写 HTTP 数据流。\r\n4.从您的Web服务器接受响应的 HTTP 数据流。该数据流包括状态编码， 其值取决于 HTTP 协议 。 解析该数据流得到 状态编码和其他有用信息。\r\n</code></pre>\r\n<strong>而401错误在容易在以上所述的最后一步产生，即当客户端收到 HTTP 状态编码并识别其为 ‘401‘ 时</strong>\r\n例如我这里做了一个测试: 大家看代码 ,(由于请求网络服务器比较不好操作,所以,这个测试我用了自己电脑搭建的本地服务器;)<br>\r\n首先我给自己电脑的本地服务器(webDav)发送一个put请求, 准备上传一张图片到webDav服务器\r\n<pre><code>NSURL *url = [NSURL URLWithString:@\"http://127.0.0.1/uploads/123.jpg\"]; \r\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];    \r\nrequest.HTTPMethod =@\"put\";\r\n</code></pre>\r\n然后获取一张本地的图片,\r\n<pre><code> //本地文件    \r\nNSURL *fileUrl = [[NSBundle mainBundle] URLForResource:@\"head2.png\"withExtension:nil];  \r\n[[[NSURLSession sharedSession] uploadTaskWithRequest:request fromFile:\r\nfileUrl completionHandler:^(NSData *_Nullabledata, NSURLResponse *_Nullableresponse, NSError *_Nullableerror) {\r\nNSString *str = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];    \r\n}] resume];\r\n</code></pre>\r\n接着开始执行:\r\n这里就会出现问题:<br>\r\n输出结果:\r\n<img src=\"https://upload-images.jianshu.io/upload_images/1483059-6ed4b576bd197ae6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/531\" alt=\"输出结果\">\r\n通过输出结果,可以明显的看得到 服务器返回的是401, 因为我们没有授权, 那么怎样授权呢?\r\n<h3>解决 401 错误 – 情景一 : 有防御性的安全策略</h3>\r\n通常情况下<br>\r\n每个Web服务器都有自己的方式管理用户验证。通常由该网站的网络安全员（例如，系统管理员）决定哪些用户被允许访问该网址。 该人员使用 Web 服务器软件来建立这些用户的用户名及其密码。 因此， 如果您需要访问某个网址（或您忘记了自己的用户名和密码）， 只有该网站的网络安全员可以帮助您。任何安全问题需直接提交给他们。\r\n如果你认为该网站上的网页 应该 是对任何互联网用户开放的， 那么 401 信息就表明了一个更深层问题。 首先，您可以通过一个浏览器检查您的网址。 该浏览器应该运行在一台您以前从未使用过， 也不包含任何有关您的信息的计算机上， 同时， 您还应避免使用您以前用过的身份验证（密码等）。 理想情况是， 这一切应该通过一个完全不同于任何您用过的互联网连接（例如由不同的互联网服务供应商- ISP 提供的拨号连接）。 简而言之，您要模拟一个完全陌生的人通过网上冲浪访问您的网页的情况。\r\n如果这种通过浏览器的检查表明没有授权问题，则可能是您的 Web 服务器 ( 或周边系统 ) 被设置为不允许某种 HTTP 传输模式。 换句话说就是， 来自一个知名浏览器的 HTTP 通讯是允许的， 但来自其他系统的自动通讯则被拒绝， 并生成 401 错误代码。这是一种异常情况， 但是也许表明您的 Web 服务器周围 采取了非常具有防御性的安全策略。\r\n比如: iOS9.0之后,就统一规定,对于http请求,只有经过苹果认可的证书且是https:// 的,才可以直接通过访问,如果还是http:// 或者,不是苹果认可的证书的https,都是不可以直接访问的,  所以,通常情况下,解决这类问题,我们会事先在info.plist文件中做一些配置,  也就是我们常说的ATS配置: 我们可以把下面这几行配置添加到info.plist文件中, 首先用源代码方式打开info.plist文件, 然后拷贝下面的几行代码: 如下:\r\n<pre><code>&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;\r\n&lt;dict&gt;\r\n&lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;\r\n&lt;true/&gt;\r\n&lt;/dict&gt;\r\n</code></pre>\r\n<h3>解决 401 错误 – 情景二: 密码,账户名错误</h3>\r\n情景二: 需要提供密码和账号<br>\r\n当服务器需要验证您的帐户时，您可以有选择性地提供两项信息\r\n<ol>\r\n<li>网站用户名,</li>\r\n<li>网站密码。<br>\r\n当然只有当您的站点使用 HTTP 基本验证时您才应该提供这些信息。 如果您不提供这些信息，服务器是通不过的,您也会得到 401 错误。</li>\r\n</ol>\r\n就如最上面的put请求的代码, 在服务器端,其实我是设定了需要密码和账号才能通过的,<br>\r\n所以,这种情况下,我们就需要提供账号和密码给服务器了,<br>\r\n当然,实际开发中,密码和账号是需要严格加密的,都是需要和服务器人员沟通一套非常保密的加密的方法的, 整个过程是比较复杂的,<br>\r\n不过由于我这里只是做一个演示, 那么就不需要特别复杂了, 就简单一点,说明一个思路即可:<br>\r\n这里,我就手动来拼接一个账号和密码, 密码加密就用最简单的base64编码;\r\n假设我们的账号是admin,密码也是123456, 那么我们怎样来设定密码呢?<br>\r\n首先我们需要定义方法,来拼接密码,并转化为base64编码;\r\n<pre><code>//定义一个方法: 获取授权的字符串\r\n- (NSString *)getAuth:(NSString *)name pwd:(NSString *)pwd {\r\n//拼字符串  admin:123456\r\nNSString *tmpStr = [NSString stringWithFormat:@\"%@:%@\",name,pwd];\r\n//base64编码\r\ntmpStr = [self base64Encode:tmpStr];\r\n\r\nreturn [NSString stringWithFormat:@\"Basic %@\",tmpStr];\r\n}\r\n\r\n//base64编码\r\n- (NSString *)base64Encode:(NSString *)str  {\r\nNSData *data = [str dataUsingEncoding:NSUTF8StringEncoding];\r\nreturn [data base64EncodedStringWithOptions:0];\r\n}\r\n\r\n</code></pre>\r\n然后我们在发送put请求的时候, 就同时提供授权\r\n<pre><code>//上传文件\r\n- (void)uploadTask {\r\nNSURL *url = [NSURL URLWithString:@\"http://127.0.0.1/uploads/123.jpg\"];\r\nNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];\r\nrequest.HTTPMethod = @\"put\";\r\n//设置账号和密码\r\n//Authorization: Basic YWRtaW46MTIzNDU2\r\n// admin:123456\r\n[request setValue:[self getAuth:@\"admin\" pwd:@\"123456\"] forHTTPHeaderField:@\"Authorization\"];\r\n\r\n//本地文件\r\nNSURL *fileUrl = [[NSBundle mainBundle] URLForResource:@\"head2.png\" withExtension:nil];  \r\n[[[NSURLSession sharedSession] uploadTaskWithRequest:request fromFile:fileUrl completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {\r\n\r\nNSString *str = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\r\n\r\nNSLog(@\"--%@\",str);\r\n\r\n}] resume];\r\n}\r\n</code></pre>\r\n执行结果:\r\n<img src=\"https://upload-images.jianshu.io/upload_images/1483059-44e0a08032812143.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"执行结果\">\r\n通过结果,我们可以看出, 已经上传成功了,  也就是说,我们顺利的解决了401问题,\r\n<h3>总结解决bug的思路:</h3>\r\n如果遇到401问题, 我们解决的思路,可以这样来考虑:\r\n<ol>\r\n<li>优先考虑是否是需要验证,也就是是否需要授权账号和密码信息;</li>\r\n<li>如果是开放的服务器资源, 需要考虑的是是否有防御性的安全策略;</li>\r\n</ol>\r\n一般情况下,都属于这两种原因,\r\n<strong>以上属于我整理的,如有不足之处,望大家斧正! 感谢!!</strong>', '2018-03-16 14:50:00', '简书', 'https://www.jianshu.com/p/ca3e561e09ae'),
(94, 'Bootstrap 3用得才半生不熟 Bootstrap 4 又如天使般来临', '华言巧语', 'JS', 'Bootstrap 3开始，华哥知道了这个国外的响应式前端框架，这真是一个前端界面ui利器，在没有美工的情况下可以快速弄出简洁美观的ui。不过呢，Bootstrap 3文档虽然看了好几遍，然实际工作中却没有怎么用到它，技术这个东东，看懂了理解了只是一方面，要用得随心应手去解决问题，则是要去反复实践练习才成的。毕竟毕竟，哥不是搞开发的。\r\n<img src=\"http://imgs.tzres.com/?url=http://inews.gtimg.com/newsapp_bt/0/2762905349/640\" width=\"100%\" style=\"display:block;\" data-width=\"560\" data-height=\"420\" kb-src=\"http://inews.gtimg.com/newsapp_bt/0/2762905349/1000\">\r\n虽然Bootstrap 3还用得半生不熟，但是Bootstrap 4已如天使般来临。\r\n<img src=\"http://imgs.tzres.com/?url=http://inews.gtimg.com/newsapp_bt/0/2762905351/640\" width=\"100%\" style=\"display:block;\" data-width=\"640\" data-height=\"336\" kb-src=\"http://inews.gtimg.com/newsapp_bt/0/2762905351/1000\">\r\n2018年01月18日，Bootstrap 4.0.0 正式版已发布。要用的就快点去用吧。\r\nBootstrap4 目前是 Bootstrap 的最新版本，是一套用于 HTML、CSS 和 JS 开发的开源工具集。如果要学习和掌握Bootstrap 4，那就得趁早，赶在2018农历年之前，或许年后开工，就能派上大用场。\r\n个人认为Bootstrap不管是3还是4，最有价值的，最值得让我们花费时间去研究实践的，就是其<strong>响应式、移动设备优先的流式网格（栅格）系统</strong>，如果你学过平面设计或接触过杂志排版，就应当知晓栅格系统，不过相比于平面那种固定的栅格，bootstarp的栅格可是响应式的，其列会随不同设备的屏幕大小自动重新排列。\r\n<img src=\"http://imgs.tzres.com/?url=http://inews.gtimg.com/newsapp_bt/0/2762905352/640\" width=\"100%\" style=\"display:block;\" data-width=\"600\" data-height=\"323\" kb-src=\"http://inews.gtimg.com/newsapp_bt/0/2762905352/1000\">\r\n<img src=\"http://imgs.tzres.com/?url=http://inews.gtimg.com/newsapp_bt/0/2762905353/640\" width=\"100%\" style=\"display:block;\" data-width=\"600\" data-height=\"423\" kb-src=\"http://inews.gtimg.com/newsapp_bt/0/2762905353/1000\">\r\n网页也是排版，bootstarp的栅格系统，在华哥可看来，这是好灵活，好有含金量的东东。如果研究透了bootstarp栅格布局，就掌握了bootstarp的精髓，响应式的网页制作复杂度会大大降低，至于bootstarp提供的其他组件，都是相对简单的玩艺，拿来用就好。', '2018-03-16 15:37:00', '优秀范文网', 'http://www.yxtvg.com/toutiao/5059687/20180124A03QLW00.html'),
(95, 'PHP导出数据库的表数据', 'Oink', 'PHP', '<pre><code>&lt;?php\r\n@mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;)or die;    //链接数据库\r\n@mysql_select_db(&quot;test1&quot;)or die;    //选择数据库\r\n$query = @mysql_query(&quot;select * from yonghu&quot;)or die;    //查询‘yonghu’表中的所有记录\r\necho &quot;&lt;table border=1&gt;&lt;tr align=center&gt;&lt;th&gt;用户名&lt;/th&gt;&lt;th&gt;性别&lt;/th&gt;&lt;th&gt;出生日期&lt;/th&gt;&lt;th&gt;邮箱&lt;/th&gt;&lt;/tr&gt;&quot;;\r\n$n=0;\r\nwhile ($row = mysql_fetch_array($query))    //遍历‘yonghu’表中的数据，并形成数组\r\n{\r\n    $username = $row[&#x27;username&#x27;];    //使用键获取数组中对应的值\r\n    $sex = $row[&#x27;sex&#x27;];\r\n    $birth = $row[&#x27;birth&#x27;];\r\n    $email = $row[&#x27;email&#x27;];\r\n    echo &quot;&lt;tr&gt;&quot;;\r\n    echo &quot;&lt;td&gt;{$username}&lt;/td&gt;&quot;;    //按照数据表的列在表格里输出对应数据\r\n    echo &quot;&lt;td&gt;{$sex}&lt;/td&gt;&quot;;\r\n    echo &quot;&lt;td&gt;{$birth}&lt;/td&gt;&quot;;\r\n    echo &quot;&lt;td&gt;{$email}&lt;/td&gt;&quot;;\r\n    echo &quot;&lt;/tr&gt;&quot;;\r\n    $n++;\r\n/*    if($n&gt;14){\r\n        return;\r\n    }*/\r\n}    \r\necho &quot;&lt;table&gt;&quot;;\r\n?&gt;</code></pre>\r\n<img src=\"https://images2015.cnblogs.com/blog/1046842/201611/1046842-20161127235212471-1522710497.png\">', '2018-03-16 16:00:00', '博客园', 'https://www.cnblogs.com/xieyaojin/p/6107984.html'),
(96, 'B/S结构简介', 'citywalker007', 'baike', '    B/S结构，即Browser/Server(浏览器/服务器)结构，是随着Internet技术的兴起，对C/S结构的一种变化或者改进的结构。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现，形成所谓3-tier结构。B/S结构，主要是利用了不断成熟的WWW浏览器技术，结合浏览器的多种Script语言(VBScript、JavaScript…)和ActiveX技术，用通用浏览器就实现了原来需要复杂专用软件才能实现的强大功能，并节约了开发成本，是一种全新的软件系统构造技术。随着Windows 98/Windows 2000将浏览器技术植入操作系统内部，这种结构更成为当今应用软件的首选体系结构。 \r\n\r\n  B／S结构，即Browser／Server(浏览器／服务器)结构，就是只安装维护一个服务器(Server)，而客户端采用浏览器(Browse)运行软件。它是随着Internet技术的兴起，对C／S结构的一种变化和改进。主要利用了不断成熟的WWW浏览器技术，结合多种Script语言(VBScript、JavaScript…)和ActiveX技术，是一种全新的软件系统构造技术。 \r\n\r\nB／S三层体系结构采用三层客户／g艮务器结构，在数据管理层(Server)和用户界面层(Client)增加了一层结构，称为中间件(Middleware)，使整个体系结构成为三层。三层结构是伴随着中间件技术的成熟而兴起的，核心概念是利用中间件将应用分为表示层、业务逻辑层和数据存储层三个不同的处理层次，如图2所示。三个层次的划分是从逻辑上分的，具体的物理分法可以有多种组合。中间件作为构造三层结构应用系统的基础平台，提供了以下主要功能：负责客户机与服务器、服务器与服务器间的连接和通信；实现应用与数据库的高效连接；提供一个三层结构应用的开发、运行、部署和管理的平台。这种三层结构在层与层之间相互独立，任何一层的改变不会影响其它层的功能。 \r\n\r\n在B／S体系结构系统中，用户通过浏览器向分布在网络上的许多服务器发出请求，服务器对浏览器的请求进行处理，将用户所需信息返回到浏览器。而其余如数据请求、加工、结果返回以及动态网页生成、对数据库的访问和应用程序的执行等工作全部由Web Server完成。随着Windows将浏览器技术植入操作系统内部，这种结构已成为当今应用软件的首选体系结构。显然B／S结构应用程序相对于传统的C／S结构应用程序是一个非常大的进步。 \r\n\r\nB／S结构的主要特点是分布性强、维护方便、开发简单且共享性强、总体拥有成本低。但数据安全性问题、对服务器要求过高、数据传输速度慢、软件的个性化特点明显降低，这些缺点是有目共睹的，难以实现传统模式下的特殊功能要求。例如通过浏览器进行大量的数据输入或进行报表的应答、专用性打印输出都比较困难和不便。此外，实现复杂的应用构造有较大的困难。虽然可以用ActiveX、Java等技术开发较为复杂的应用，但是相对于发展已非常成熟C／S的一系列应用工具来说，这些技术的开发复杂，并没有完全成熟的技术工具供使用。\r\n\r\n \r\n\r\n近年来，随着网络技术不断发展，尤其是基于Web的信息发布和检索技术、Java计算技术以及网络分布式对象技术的飞速发展，导致了很多应用系统的体系结构从C／S结构向更加灵活的B／S多级分布结构演变，使得软件系统的网络体系结构跨入一个新阶段。认识这些结构的特征，并根据实际情况进行系统的选型，对于成功开发一个MIS系统是非常关键的。\r\n\r\n C／S结构与B／S结构\r\n\r\n1．1 C／S结构\r\n\r\nC／S结构，即Client／Server(客户机／服务器)结构。此结构把数据库内容放在远程的服务器上，而在客户机上安装相应软件。C／S软件一般采用两层结构，其分布结构如图1所示。它由两部分构成：前端是客户机，即用户界面(Client)结合了表示与业务逻辑，接受用户的请求，并向数据库服务提出请求，通常是一个PC机；后端是服务器，即数据管理(Server)将数据提交给客户端，客户端将数据进行计算并将结果呈现给用户。还要提供完善的安全保护及对数据的完整性处理等操作，并允许多个客户同时访问同一个数据库。在这种结构中，服务器的硬件必须具有足够的处理能力，这样才能满足各客户的要求。\r\n\r\nC／S结构在技术上很成熟，它的主要特点是交互性强、具有安全的存取模式、网络通信量低、响应速度快、利于处理大量数据。但是该结构的程序是针对性开发，变更不够灵活，维护和管理的难度较大。通常只局限于小型局域网，不利于扩展。并且，由于该结构的每台客户机都需要安装相应的客户端程序，分布功能弱且兼容性差，不能实现快速部署安装和配置，因此缺少通用性，具有较大的局限性。要求具有一定专业水准的技术人员去完成。\r\n\r\n1．2 B／S结构\r\n\r\nB／S结构，即Browser／Server(浏览器／服务器)结构，就是只安装维护一个服务器(Server)，而客户端采用浏览器(Browse)运行软件。它是随着Internet技术的兴起，对C／S结构的一种变化和改进。主要利用了不断成熟的WWW浏览器技术，结合多种Script语言(VBScript、javascript…)和ActiveX技术，是一种全新的软件系统构造技术。图片点击可在新窗口打开查看\r\n\r\nB／S三层体系结构采用三层客户／g艮务器结构，在数据管理层(Server)和用户界面层(Client)增加了一层结构，称为中间件(Middleware)，使整个体系结构成为三层。三层结构是伴随着中间件技术的成熟而兴起的，核心概念是利用中间件将应用分为表示层、业务逻辑层和数据存储层三个不同的处理层次，如图2所示。三个层次的划分是从逻辑上分的，具体的物理分法可以有多种组合。中间件作为构造三层结构应用系统的基础平台，提供了以下主要功能：负责客户机与服务器、服务器与服务器间的连接和通信；实现应用与数据库的高效连接；提供一个三层结构应用的开发、运行、部署和管理的平台。这种三层结构在层与层之间相互独立，任何一层的改变不会影响其它层的功能。\r\n\r\n在B／S体系结构系统中，用户通过浏览器向分布在网络上的许多服务器发出请求，服务器对浏览器的请求进行处理，将用户所需信息返回到浏览器。而其余如数据请求、加工、结果返回以及动态网页生成、对数据库的访问和应用程序的执行等工作全部由Web Server完成。随着Windows将浏览器技术植入操作系统内部，这种结构已成为当今应用软件的首选体系结构。显然B／S结构应用程序相对于传统的C／S结构应用程序是一个非常大的进步。\r\n\r\nB／S结构的主要特点是分布性强、维护方便、开发简单且共享性强、总体拥有成本低。但数据安全性问题、对服务器要求过高、数据传输速度慢、软件的个性化特点明显降低，这些缺点是有目共睹的，难以实现传统模式下的特殊功能要求。例如通过浏览器进行大量的数据输入或进行报表的应答、专用性打印输出都比较困难和不便。此外，实现复杂的应用构造有较大的困难。虽然可以用ActiveX、Java等技术开发较为复杂的应用，但是相对于发展已非常成熟C／S的一系列应用工具来说，这些技术的开发复杂，并没有完全成熟的技术工具供使用。\r\n\r\n2 C／S结构与B／S结构的分析比较\r\n\r\n2．1 硬件环境不同\r\n\r\nC／S建立在局域网的基础上，通过专门服务器提供连接和数据交换服务。所处理的用户不仅固定，并且处于相同区域，要求拥有相同的操作系统。B／S建立在广域网的基础上，信息自己管理，有比C／S更强的适应范围，一般只要有操作系统和浏览器就行。与操作系统平台关系最小。面向不可知的用户群。\r\n\r\n2．2 结构不同\r\n\r\nC／S软件一般采用两层结构，而B／S采用三层结构：\r\n\r\n这两种结构的不同点是两层结构中客户端参与运算，而三层结构中客户端并不参与运算，只是简单地接收用户的请求，显示最后的结果。由于三层结构中的客户端并不需要参与计算，所以对客户端的计算机电脑配置要求较低。虽然BlS采用了逻辑上的三层结构，但在物理上的网络结构仍然是原来的以太网或环形网。这样，第一层与第二层结构之间的通信、第二层与第三层结构之间的通信都需占用同一条网络线路，网络通信量大。而C／S只有两层结构，网络通信量只包括Client与Server之间的通信量，网络通信量低。所以，C／S处理大量信息的能力是B／S无法比拟的。\r\n\r\n2．3 处理模式不同\r\n\r\nB／S的处理模式与C／S相比，大大简化了客户端，只要装上操作系统、网络协议软件以及浏览器即可，这时的客户机成为瘦客户机，而服务器则集中了所有的应用逻辑。\r\n\r\n2．4 构件重用不同\r\n\r\n在构件的重用性方面，C／S程序从整体进行考虑，具有较低的重用性。 而BlS对应的是多重结构，要求构件具有相对独立的功能，具有较好的重用性。\r\n\r\n2．5 系统维护不同\r\n\r\n系统维护是在软件生存周期中开销最大的一部分。C／S程序由于其本身的整体性，必须整体考察并处理出现的问题。而B／S结构，客户端不必安装及维护。B／S结构在构件组成方面只变更个别构件，开发、维护等工作都集中在服务器端。当需要升级时，只需更新服务器端的软件，而不必更换客户端软件，实现系统的无缝升级。这样就减轻了系统维护与升级的成本和工作量，使用户的总体拥有成本(TCO)大大降低。\r\n\r\n2．6 对安全的要求不同\r\n\r\n由于C／S采用配对的点对点的结构模式，并采用适用于局域网、安全性比较好的网络协议(例如NT的NetBEUI协议)，安全性可得到较好的保证。C／S一般面向相对固定的用户群，程序更加注重流程，它可以对权限进行多层次校验，提供了更安全的存取模式，对信息安全的控制能力很强。一般高度机密的信息系统采用C／S结构适宜。而B／S采用点对多点、多点对多点这种开放的结构模式，并采用TCP／IP这一类运用于Intemet的开放性协议，其安全性只能靠数据服务器上管理密码的数据库来保证。所以B／S对安全以及访问速度比C／S有更高的要求。而Intemet技术中这些关键的安全问题远未解决。\r\n\r\n2．7 速度不同\r\n\r\n由于C／S在逻辑结构上比B／S少一层，对于相同的任务，C／S完成的速度总比B／S快。使得C／S更利于处理大量数据。\r\n\r\n2．8 交互性与信息流不同\r\n\r\n交互性强是C／S固有的一个优点。在C／S中，客户端有一套完整的应用程序，在出错提示、在线帮助等方面都有强大的功能，并且可以在子程序间自由切换。B／S虽然由javascript、VBScript提供了一定的交互能力，但与C／S的一整套客户应用相比是太有限了。C／S的信息流单一，而B／S可处理如B-B、B-C、B-G等信息并具有流向的变化。\r\n\r\n3 基于B／S结构与C／S结构结合的体系结构\r\n\r\n综上所述，可见B／S与C／S这两种技术是各有利弊的。\r\n\r\nC／S技术是20年前的主流开发技术，它主要局限于内部局域网的需要。因而缺乏作为应用平台的一些特性，难以扩展到互联网这样的环境上去，而且要求开发者自己去处理事务管理、消息队列、数据的复制和同步、通信安全等系统级的问题。这对应用开发者提出了较高的要求，而且迫使应用开发者投入很多精力来解决应用程序以外的问题。这使得应用程序的维护、移植和互操作变得复杂，成了C／S的一大缺陷。\r\n\r\n但是，与B／S结构相比，C／S技术发展历史更为“悠久”。从技术成熟度及软件设计、开发人员的掌握水平来看，C／S技术更成熟、更可靠。在某些情况下，采用100％的B／S方式将造成系统响应速度慢、服务器开销大、通信带宽要求高、安全性差、总投资增加等问题。而且，对于一些复杂的应用，B／S方式目前尚没有合适方式进行开发。\r\n图片点击可在新窗口打开查看\r\n    客观地分析C／S、B／S的优劣，建立C／S、B／S结构相结合的网络构架已成为必然趋势。在实际开发和规划系统的时候要有的放矢，才能够搭建成合适的信息系统。\r\n\r\n下面以学校学生管理系统为实例说明这种设计方法。该系统采用B／S+C／S体系结构，结合了ASP技术，并将组件技术COM+和ActiveX技术分别应用在服务器端和客户端。该系统的实现主要分为三个部分：ASP页面、COM+组件和数据库，是一个三层结构。表示层由ASP页面组成，用以实现WEB页面显示和调用COM+组件，业务逻辑和数据访问由一组用VC实现的COM+组件构成。为了便于维护、升级和实现分布式应用，在实现过程中，又将业务逻辑层和数据访问层分离开，ASP页面不直接调用数据访问层，而是通过业务逻辑层调用数据库。一些需要用WEB处理的、满足大多数访问者请求的功能界面采用B／S结构，例如任课教师可以通过浏览器查询所教班级学生各种相关信息；学校管理人员通过浏览器对学校的学生、教师等信息进行管理与维护以及查询统计；领导层可通过浏览器进行数据的查询和决策。这样客户端比较灵活。而后台只需少数人使用的功能则采用C／S结构，例如数据库管理维护界面。如此处理，可充分发挥各种模式的优越性——避免了B／S结构在安全性、保密性和响应速度等方面的缺点以及C／S结构在维护和灵活性等方面的缺点。COM+的实现可分为三个步骤：COM+组件的设计、COM+应用程序的生成和编程。COM+组件位于WEB应用程序中，客户端发出请求到WEB SERVER。WEB SERVER将请求传给WEB应用程序。WEB应用程序将数据请求传送给数据库服务器，数据库服务器将数据返回WEB应用程序。然后再由WEB SERVER将数据传送给客户端。对于一些较难实现的功能通过在页面中嵌入ActiveX控件来实现。\r\n\r\n采用这种结构优点在于：\r\n\r\n(1)充分发挥了B／S与C／S体系结构的优势，弥补了二者不足。充分考虑用户利益，保证浏览查询者方便操作的同时也使得系统更新简单，维护简单灵活，易于操作。\r\n\r\n(2)信息发布采用B／S结构，保持了瘦客户端的优点。装入客户机的软件可以采用统一的WWW浏览器。而且由于WWW浏览器和网络综合服务器都是基于工业标准，可以在所有的平台上工作。\r\n\r\n(3)数据库端采用C／S结构，通过ODBC／JDBC连接。这一部分只涉及到系统维护、数据更新等，不存在完全采用C／S结构带来的客户端维护工作量大等缺点。并且在客户端可以构造非常复杂的应用，界面友好灵活，易于操作，能解决许多B／S存在的固有缺点。\r\n\r\n(4)对于原有的基于C／S体系结构的应用，只需开发用于发布的WWW界面，就可非常容易地升级到这种体系结构，并保留原来的某些子系统。这样就充分地利用现有系统的资源。\r\n\r\n(5)通过在浏览器中嵌入ActiveX控件可以实现在浏览器中不能实现或实现起来比较困难的功能。例如通过浏览器进行报表的应答。\r\n\r\n(6)将服务器端划分为WEB服务器和WEB应用程序两部分。WEB应用程序采用组件技术实现三层体系结构中的逻辑部分，达到封装的目的。\r\n\r\nB／S结构与C／S结构各具优缺点，怎样结合B／S与C／S开发系统是开发MIS系统普遍关注的问题。在应用过程中，应结合实际情况，并根据实际情况进行系统的选型与构建，从而开发出高效、安全的应用系统。\r\n\r\n为什么说B/S结构优于C/S结构\r\n\r\nC/S结构，即Client/Server(客户机/服务器)结构，是大家熟知的软件系统体系结构，通过将任务合理分配到Client端和Server端，降低了系统的通讯开销，可以充分利用两端硬件环境的优势。\r\n　　B/S结构，即Browser/Server(浏览器/服务器)结构，是随着Internet技术的兴起，对C/S结构的一种变化或者改进的结构。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现，形成所谓3-tier结构。B/S结构利用不断成熟和普及的浏览器技术实现原来需要复杂专用软件才能实现的强大功能，并节约了开发成本，是一种全新的软件系统构造技术。这种结构更成为当今应用软件的首选体系结构，microsoft.net也是在这样一种背景下被提出来的架构，但微软的方案只是一种构想，要成为现实还需要几年，而JAVA技术已经是很成熟的应用了。\r\n　　目前大多数应用软件系统都是Client/Server形式的两层结构，现在的软件应用系统正在向分布式的Web应用发展；内部的和外部的用户都可以访问新的和现有的应用系统，Web和Client/Server 应用都可以进行同样的业务处理；不同的应用模块共享逻辑组件；通过现有应用系统中的逻辑可以扩展出新的应用系统。这也就是目前应用系统的发展方向。\r\n　　管理软件的主流技术与管理思想一样，也经历了三个发展时期：界面技术从DOS字符界面，到Windows图形界面（或图形用户界面GUI），直至今天的Browser浏览器界面。最新浏览器界面，不仅直观和易于使用，更主要的是基于浏览器平台的任何应用软件其界面风格一致，用户对操作培训的要求大为下降，软件可操作性增强；平台体系结构也从单机单用户发展到文件／服务器（F／S）体系，再到客户机／服务器（C／S）体系和浏览器／服务器（B／S）体系。\r\n　　传统的C／S体系结构虽然采用的是开放模式，但这只是系统开发一级的开放性，在特定的应用中无论是Client端还是Server端都还需要特定的软件，没能提供用户真正期望的开放环境；B／S结构则不同，它的前端是以TCP／IP协议为基础的，企业内的WWW服务器可以接受安装有Web浏览程序的Internet终端的访问，作为最终用户，只要通过Web浏览器，各种处理任务都可以调用系统资源来完成，这样大大简化了客户端，减轻了系统维护与升级的成本和工作量，降低了用户的总体拥有成本（TCO）。\r\n　　越来越厚的使用说明书和越来越花时间的培训，并不能称为\"良好的售后服务\"，真正好的产品在功能越来越复杂的同时应该使产品的使用越来越简单，使用浏览器作为软件界面不但容易统一各种应用系统，也非常便于使用。在工作节奏越来越紧张的今天调集大批的职员进行培训是很困难的，时间和人力都难以集中，浏览器这种易于使用几乎不需要培训的方式是最好的选择。\r\n维护和升级方式的革命-瘦客户机\r\n　　软件系统的改进和升级越来越频繁，B/S架构的产品明显体现的更方便的特性。无论用户的规模有多大，有多少分支机构都不会增加任何维护升级的工作量，所有的操作只需要针对服务器进行，如果是异地只需要把服务器连接上网即可立即进行维护和升级，这对人力、时间、费用的节省是相当惊人的。\r\n　　一个稍微大一点单位来说，系统管理人员如果需要在几百甚至几千部电脑之间来回奔跑，效率和工作量是可想而知的，但B/S架构的软件只需要管理服务器就行了，所有的客户端只是浏览器，根本不需要做任何的维护。所以客户机越来越\"瘦\"而服务器越来越\"胖\"是将来软件的主流发展方向，这使得升级和维护越来越容易而使用越来越简单。\r\n成本降低，选择更多\r\n　　很明显windows在桌面电脑上几乎一统天下，浏览器成为了标准配置，但在服务器操作系统，windows并没有这种绝对的统治地位，而现在的趋势是应用软件都变成B/S架构的，只安装在服务器上，所以服务器操作系统的选择是很多的，不管选用那种操作系统都可以让大部分人使用windows作为桌面操作系统的情况不受影响，这就使的很多免费的操作系统如现在最流行的Linux得以快速发展，除了操作系统是免费的以外，连数据库也是免费的，这样的选择非常流行。\r\n　　比如说很多人每天上新浪网，只要安装了浏览器就可以了，并不需要了解新浪的服务器用的是什么操作系统，而事实上大部分网站确实没有使用windows操作系统，但用户的电脑本身安装的大部分是windows操作系统。\r\n中国政府处于安全和国家战略的考虑希望有自己的操作系统，而在桌面领域任何一种操作系统都难以和windows抗衡，　\r\n　　Linux的出现使这种想法变成了现实，由于Linux是免费产品，源代码也是公开的，中国出现很多开发Linux的力量，国家大力推动Linux，政府机关处于安全的考虑会越来越多使用Linux，从国内软件市场的销售来看Linux也是基本上每个月都是排名第一的产品。\r\n　　传统的C/S结构的软件需要针对不同的操作系统系统开发不同版本的软件，由于产品的更新换代十分快，这么高的代价和低效率已经越来越不适应了。在JAVA这样的跨平台语言出现之后B/S架构更是飞快地普及起来了。\r\n面向电子商务时代的技术\r\n　　将来所有的应用系统几乎都在互联网上运行，企业发展电子商务也是不可避免的，而B/S架构的软件则代表了将来的技术，只要连上互联网或内部广域网就可以与全球的客户相连，与各地的分支机构相连。\r\n移动办公\r\n☆　在办公室内移动的时候可以使用任何一台电脑办公，而传统的OA是每台电脑对应指定的用户，别的用户不能使用该电脑，而且还需要安装调试软件，相当不方便。\r\n☆　回家或离开办公室或出差到其他地方只要有可以上网的电脑也可以使用办公系统。\r\n☆　分公司可以通过互联网、专线、电话网等连接使用资源共享，协同办公。\r\n系统整合\r\n　　无论是办公自动化管理系统，人力资源管理系统，客户关系管理系统，ERP等等，发展的趋势是不断融合，采用统一的B/S结构开发的产品无论是现在还是将来都是最好的选择。\r\n目前B/S模式下最好的选择---JAVA技术\r\n　　现在出现的Microsoft.NET也是模仿JAVA的思路，Microsoft.NET的蓝图与Java十分相似，目前还只是一个框架，还需要几年才能成熟，而JAVA已经是应用十分普及的技术了。', '2018-03-16 16:09:00', 'CSDN', 'https://blog.csdn.net/mxq007/article/details/1710164'),
(97, 'PHP导出生成CSV文件', 'King-', 'PHP', 'composer 用起来是非常方便的 所以我是依赖composer来做的包管理\r\n\r\n1.先安装composer 自行百度一下composer安装以及使用\r\n\r\n2.用composer下载安装office包即可\r\n\r\n3.不多废话 直接上代码\r\n<pre><code>\r\n/**\r\n * @param $data array  要下载的数据\r\n * @param $title_arr array　表头\r\n * @param $filename string　文件名称\r\n */\r\nfunction export_csv($data,$title_arr,$file_name=&#x27;&#x27;){\r\n    ini_set(&quot;max_execution_time&quot;, &quot;3600&quot;);\r\n\r\n    $csv_data = &#x27;&#x27;;\r\n\r\n    /** 标题 */\r\n    $nums = count($title_arr);\r\n\r\n    for ($i = 0; $i &lt; $nums - 1; ++$i) {\r\n        //$csv_data .= &#x27;&quot;&#x27; . $title_arr[$i] . &#x27;&quot;,&#x27;;\r\n        $csv_data .= $title_arr[$i] . &#x27;,&#x27;;\r\n    }\r\n    if ($nums &gt; 0) {\r\n        $csv_data .= $title_arr[$nums - 1] . &quot;\\r\\n&quot;;\r\n    }\r\n\r\n    foreach ($data as $k =&gt; $row) {\r\n        $_tmp_csv_data = &#x27;&#x27;;\r\n        foreach ($row as $key =&gt; $r){\r\n            $row[$key] = str_replace(&quot;\\&quot;&quot;, &quot;\\&quot;\\&quot;&quot;, $r);\r\n\r\n            if ( $_tmp_csv_data == &#x27;&#x27; ) {\r\n                $_tmp_csv_data = $row[$key];\r\n            }\r\n            else {\r\n                $_tmp_csv_data .= &#x27;,&#x27;. $row[$key];\r\n            }\r\n\r\n        }\r\n\r\n        $csv_data .= $_tmp_csv_data.$row[$nums - 1] . &quot;\\r\\n&quot;;\r\n        unset($data[$k]);\r\n    }\r\n\r\n    $csv_data = mb_convert_encoding($csv_data, &quot;cp936&quot;, &quot;UTF-8&quot;);\r\n    $file_name = empty($file_name) ? date(&#x27;Y-m-d-H-i-s&#x27;, time()) : $file_name;\r\n    // 解决IE浏览器输出中文名乱码的bug\r\n    if(preg_match( &#x27;/MSIE/i&#x27;, $_SERVER[&#x27;HTTP_USER_AGENT&#x27;] )){\r\n        $file_name = urlencode($file_name);\r\n        $file_name = iconv(&#x27;UTF-8&#x27;, &#x27;GBK//IGNORE&#x27;, $file_name);\r\n    }\r\n    $file_name = $file_name . &#x27;.csv&#x27;;\r\n    header(&#x27;Content-Type: application/download&#x27;);\r\n    header(&quot;Content-type:text/csv;&quot;);\r\n    header(&quot;Content-Disposition:attachment;filename=&quot; . $file_name);\r\n    header(&#x27;Cache-Control:must-revalidate,post-check=0,pre-check=0&#x27;);\r\n    header(&#x27;Expires:0&#x27;);\r\n    header(&#x27;Pragma:public&#x27;);\r\n    echo $csv_data;\r\n    exit();\r\n}</code></pre>', '2018-03-16 16:27:00', '博客园', 'https://www.cnblogs.com/wlsphper/p/6817545.html'),
(98, 'PHP 读取/导出 CSV文件', 'cheungkaming', 'PHP', '工作中经常会有遇到导入/导出的需求，下面是常用的方法。\r\n读取CSV文件，可以分页读取，设置读取行数，起始行数即可。\r\n导出CSV文件，用两种方法进行实现。\r\n<pre><code>/**\r\n * 读取CSV文件\r\n * @param string $csv_file csv文件路径\r\n * @param int $lines       读取行数\r\n * @param int $offset      起始行数\r\n * @return array|bool\r\n */\r\npublic function read_csv_lines($csv_file = &#x27;&#x27;, $lines = 0, $offset = 0)\r\n{\r\n    if (!$fp = fopen($csv_file, &#x27;r&#x27;)) {\r\n        return false;\r\n    }\r\n    $i = $j = 0;\r\n    while (false !== ($line = fgets($fp))) {\r\n        if ($i++ &lt; $offset) {\r\n            continue;\r\n        }\r\n        break;\r\n    }\r\n    $data = array();\r\n    while (($j++ &lt; $lines) &amp;&amp; !feof($fp)) {\r\n        $data[] = fgetcsv($fp);\r\n    }\r\n    fclose($fp);\r\n    return $data;\r\n}\r\n/**\r\n * 导出CSV文件\r\n * @param array $data        数据\r\n * @param array $header_data 首行数据\r\n * @param string $file_name  文件名称\r\n * @return string\r\n */\r\npublic function export_csv_1($data = [], $header_data = [], $file_name = &#x27;&#x27;)\r\n{\r\n    header(&#x27;Content-Type: application/octet-stream&#x27;);\r\n    header(&#x27;Content-Disposition: attachment; filename=&#x27; . $file_name);\r\n    if (!empty($header_data)) {\r\n        echo iconv(&#x27;utf-8&#x27;,&#x27;gbk//TRANSLIT&#x27;,&#x27;&quot;&#x27;.implode(&#x27;&quot;,&quot;&#x27;,$header_data).&#x27;&quot;&#x27;.&quot;\\n&quot;);\r\n    }\r\n    foreach ($data as $key =&gt; $value) {\r\n        $output = array();\r\n        $output[] = $value[&#x27;id&#x27;];\r\n        $output[] = $value[&#x27;name&#x27;];\r\n        echo iconv(&#x27;utf-8&#x27;,&#x27;gbk//TRANSLIT&#x27;,&#x27;&quot;&#x27;.implode(&#x27;&quot;,&quot;&#x27;, $output).&quot;\\&quot;\\n&quot;);\r\n    }\r\n}\r\n/**\r\n * 导出CSV文件\r\n * @param array $data        数据\r\n * @param array $header_data 首行数据\r\n * @param string $file_name  文件名称\r\n * @return string\r\n */\r\npublic function export_csv_2($data = [], $header_data = [], $file_name = &#x27;&#x27;)\r\n{\r\n    header(&#x27;Content-Type: application/vnd.ms-excel&#x27;);\r\n    header(&#x27;Content-Disposition: attachment;filename=&#x27;.$file_name);\r\n    header(&#x27;Cache-Control: max-age=0&#x27;);\r\n    $fp = fopen(&#x27;php://output&#x27;, &#x27;a&#x27;);\r\n    if (!empty($header_data)) {\r\n        foreach ($header_data as $key =&gt; $value) {\r\n            $header_data[$key] = iconv(&#x27;utf-8&#x27;, &#x27;gbk&#x27;, $value);\r\n        }\r\n        fputcsv($fp, $header_data);\r\n    }\r\n    $num = 0;\r\n    //每隔$limit行，刷新一下输出buffer，不要太大，也不要太小\r\n    $limit = 100000;\r\n    //逐行取出数据，不浪费内存\r\n    $count = count($data);\r\n    if ($count &gt; 0) {\r\n        for ($i = 0; $i &lt; $count; $i++) {\r\n            $num++;\r\n            //刷新一下输出buffer，防止由于数据过多造成问题\r\n            if ($limit == $num) {\r\n                ob_flush();\r\n                flush();\r\n                $num = 0;\r\n            }\r\n            $row = $data[$i];\r\n            foreach ($row as $key =&gt; $value) {\r\n                $row[$key] = iconv(&#x27;utf-8&#x27;, &#x27;gbk&#x27;, $value);\r\n            }\r\n            fputcsv($fp, $row);\r\n        }\r\n    }\r\n    fclose($fp);\r\n}</code></pre>', '2018-03-16 16:28:00', '博客园', 'https://www.cnblogs.com/CHEUNGKAMING/p/5706399.html'),
(99, '从零开始打jar包', '闪客sun', 'JAVA', '经常会头疼于一个jar包是如何制作的，包括maven的打包方式，springboot的打jar包的原理，jar包稍稍有错误就会完全无法运行。在网上折腾了很久终于有些思路和步骤，在这里做个笔记\r\n<strong>本文大纲：</strong>\r\n<strong>一、制作只含有字节码文件的jar包<br /></strong>1、最简单的jar包&mdash;&mdash;直接输出hello<br />2、含有两个类的jar包&mdash;&mdash;通过调用输出hello<br />3、有目录结构的jar包&mdash;&mdash;通过引包并调用输出hello\r\n<strong>二、制作含有jar文件的jar包<br /></strong>1、两个jar包间相互调用&mdash;&mdash;调用jar外的jar输出hello<br />2、jar包中含有jar包&mdash;&mdash;调用jar内的jar输出hello\r\n<strong>三、制作含有资源文件的jar包<br /></strong>1、资源文件在jar包内部&mdash;&mdash;读取jar内的文件<br />2、资源文件在另一个jar包内部&mdash;&mdash;读取另一个jar内的文件<br />3、资源文件在jar包外部&mdash;&mdash;读取jar外的文件\r\n<strong>正文：</strong>\r\n<strong>一、制作只含有字节码文件的jar包</strong>\r\n我们先来看只含有字节码文件，即只含有class文件的jar包怎么制作，这是最简单的形式\r\n<strong>1、最简单的jar包&mdash;&mdash;直接输出hello</strong>\r\n最终生成的jar包结构\r\n<blockquote>META-INF<br />Hello.class</blockquote>\r\n方法步骤\r\n（1）用记事本写一个Hello.java的文件\r\n<pre><code>class Hello{\r\n    public static void main(String[] agrs){\r\n        System.out.println(\"hello\");\r\n    }\r\n}</code></pre>\r\n（2）用命令行进入到该目录下，编译这个文件\r\n    <code>javac Hello.java&nbsp;</code>\r\n（3）将编译后的Hello.class文件打成jar包\r\n　　<code>jar -cvf hello.jar Hello.class</code>\r\n　　c表示要创建一个新的jar包，v表示创建的过程中在控制台输出创建过程的一些信息，f表示给生成的jar包命名\r\n（4）运行jar包\r\n　　<code>java -jar hello.jar</code>这时会报如下错误&nbsp;<code>hello.jar中没有主清单属性</code>&nbsp;\r\n　　添加Main-Class属性\r\n　　用压缩软件打开hello.jar，会发现里面多了一个META-INF文件夹，里面有一个MENIFEST.MF的文件，用记事本打开\r\n<pre><code>Manifest-Version: 1.0\r\nCreated-By: 1.8.0_121 (Oracle Corporation)</code></pre>\r\n　　在第三行的位置写入 Main-Class: Hello （注意冒号后面有一个空格，整个文件最后有一行空行），保存\r\n　　再次运行&nbsp;<code>java -jar hello.jar</code>，此时成功在控制台看到&nbsp; <code>hello</code> ，成功\r\n&nbsp;\r\n<strong>2、含有两个类的jar包&mdash;&mdash;通过调用输出hello</strong>\r\n最终生成的jar包结构\r\n<blockquote>META-INF<br />Tom.class<br />Hello.class</blockquote>\r\n方法步骤\r\n（1）用记事本写一个Hello.java和一个Tom.java的文件\r\n　　目的是让Hello调用Tom的speak方法\r\n<pre><code>class Hello{\r\n    public static void main(String[] agrs){\r\n        Tom.speak();\r\n    }\r\n}</code></pre>\r\n<pre><code>class Tom{\r\n    public static void speak(){\r\n        System.out.println(&lt;span style=\"color: #800000;\"&gt;\"&lt;span style=\"color: #800000;\"&gt;hello&lt;span style=\"color: #800000;\"&gt;\");\r\n    }\r\n5 }</code></pre>\r\n（2）编译：&nbsp;<code>javac Hello.java</code>&nbsp;\r\n　　此时Hello.java和Tom.java同时被编译，因为Hello中调用了Tom，在编译Hello的过程中发现还需要编译Tom\r\n（3）打jar包，这次我们换一种方式直接定义Main-Class。\r\n<pre><code>Manifest-Version: 1.0\r\nCreated-By: 1.8.0_121 (Oracle Corporation)\r\nMain-Class: Hello</code></pre>\r\n　　事先准备好上述的MENIFEST.MF文件，并存放在META-INF文件夹下，此时打jar包的命令如下\r\n　　&nbsp;<code>jar -cvfm hello.jar META-INF\\MENIFEST.MF&nbsp;Hello.class Tom.class</code>&nbsp;\r\n　　该命令表示用第一个文件当做MENIFEST.MF文件，hello.jar作为名称，将Hello.class和Tom.class打成jar包。其中多了一个参数m，表示要定义MENIFEST文件\r\n（4）运行&nbsp;<code>java -jar hello.jar</code>&nbsp;，此时成功在控制台看到&nbsp;&nbsp;<code>hello</code>&nbsp;，成功\r\n&nbsp;\r\n<strong>3、有目录结构的jar包&mdash;&mdash;通过引包并调用输出hello</strong>\r\n最终生成的jar包结构\r\n<blockquote>META-INF<br />com<br />　Tom.class<br />Hello.class</blockquote>\r\n　　我们将上一个稍稍变化一下，将Tom这个类放在com包下，源文件目录结构变成\r\n　　　　com<br />　　　　　Tom.java<br />　　　　Hello.java\r\n　　同时Tom.java需要在第一行声明自己的包名\r\n<code>package com;</code>\r\n　　Hello.java需要引入Tom这个类，同样要在第一行进行import\r\n<code>import com.Tom;</code>\r\n方法步骤\r\n（1）编译Hello.java\r\n（2）打jar包，同样准备好MENIFEST文件\r\n　　&nbsp;<code>jar -cvfm hello.jar META-INF\\MENIFEST.MF&nbsp;Hello.class com</code>&nbsp;\r\n　　注意，最后一个com表示把com这个文件夹下的所有文件都打进jar包\r\n（3）运行&nbsp;<code>java -jar hello.jar</code>&nbsp;&nbsp;，此时成功在控制台看到&nbsp;&nbsp;<code>hello</code>&nbsp;，成功\r\n（4）优化过程\r\n　　我们注意到，com包下是有Tom.java源文件的，也被打进了jar包里，这样不太好，能不能优化一下javac命令，使所有的编译后文件编译到另一个隔离的地方呢，答案是可以的。\r\n　　在编译Hello.java时，先新建一个target文件夹。然后我们用如下命令\r\n　　　　&nbsp;<code>javac Hello.java -d target</code>&nbsp;\r\n　　该命令表示，将所有编译后的文件，都放到target文件夹下。\r\n　　将META-INF文件夹也复制到target目录下，<strong>进入这个目录</strong>，输入如下命令\r\n　　　　&nbsp;<code>jar -cvfm hello.jar META-INF\\MENIFEST.MF&nbsp;*</code>&nbsp;\r\n　　注意最后一个位置变成了*，表示把当前目录下所有文件都打在jar包里\r\n　　优化完毕\r\n<blockquote>\r\n至此，我们可以总结出，制作一个只含有class字节码文件的jar包，以下命令足以\r\njavac 要编译的文件 -d 目标位置\r\njar -cvfm 命名 MENIFEST文件 要打包的文件1 要打包的文件2\r\n</blockquote>\r\n<strong>二、制作含有jar文件的jar包</strong>\r\n我们将场景稍稍变得复杂一点，看看jar包中需要引入其他jar包的场景\r\n<strong>1、两个jar包间相互调用&mdash;&mdash;调用jar外的jar输出hello</strong>\r\n最终生成的jar包结构\r\n<blockquote>hello.jar<br />tom.jar</blockquote>\r\n方法步骤\r\n准备：将上述一中写好的那个不带包的tom.jar复制过来（目的是调用里面的speak方法）\r\n（1）编写一个Hello.java并将其编译成Hello.class，注意，由于Hello里面引用了Tom类的speak方法，因此在打jar包时应使用-cp参数，将tom.jar包引入\r\n<code>&nbsp;javac -cp tom.jar&nbsp;Hello.class</code>&nbsp;\r\n　　这里的 -cp 表示 -classpath，指的是把tom.jar加入classpath路径下\r\n（2）将hello.class达成jar包，步骤略\r\n（3）此时运行 java -jar 发现报错&nbsp; <code>ClassNotFoundException：Tom</code>&nbsp;\r\n　　原因很简单，引入jar包需要在MENIFEST.MF文件中配置一个新属性：Class-Path，路径指向你需要的所有jar包\r\n　　现在MENIFEST.MF这个文件应该变成\r\n<pre><code>Manifest-Version: 1.0\r\nCreated-By: 1.8.0_121 (Oracle Corporation)\r\nMain-Class: Hello\r\nClass-Path: Tom.jar\r\n</code></pre>\r\n（4）好了，修改这个文件，再次运行，发现成功在控制台输出 hello&nbsp;\r\ntips：引入多个jar包，中间用空格隔开\r\n<blockquote>\r\n至此，我们可以总结出，命令变化如下\r\njavac&gt;&nbsp;-cp&nbsp;xxx.jar 要编译的文件 -d 目标位置\r\njar -cvfm 命名 MENIFEST文件 要打包的文件1 要打包的文件2\r\n</blockquote>\r\n&nbsp;\r\n<strong>2、jar包中含有jar包&mdash;&mdash;调用jar内的jar输出hello</strong>\r\n最终生成的jar包结构\r\n<blockquote>META-INF<br />Hello.class<br />tom.jar</blockquote>\r\n　　当项目中我们把所需要的第三方jar包也打进了我们自己的jar包中时，如果仍然按照上述操作方式，会报找不到Class异常。原因就是jar引用不到放在自己内部的jar包。\r\n　　这种情况的具体实现细节比较复杂，我会在后一篇介绍一些知名的java应用是如何加载jar包的，来说明这种情况。实现方式的简单说明，可以先参考这篇文章：\r\nhttp://www.cnblogs.com/adolfmc/archive/2012/10/07/2713562.html\r\n&nbsp;\r\n<strong>三、制作含有资源文件的jar包</strong>\r\n<strong>1、资源文件在jar包内部&mdash;&mdash;读取jar内的文件</strong>\r\n最终生成的jar包结构\r\n<blockquote>META-INF<br />Hello.class<br />text.txt</blockquote>\r\n&nbsp;方法步骤\r\n<div class=\"cnblogs_code\">\r\n<pre>1 <span style=\"color: #0000ff;\">import java.io.InputStream;\r\n2 <span style=\"color: #0000ff;\">import java.io.BufferedReader;\r\n3 <span style=\"color: #0000ff;\">import java.io.InputStreamReader;\r\n4 \r\n5 <span style=\"color: #0000ff;\">class Hello{\r\n6     <span style=\"color: #0000ff;\">public <span style=\"color: #0000ff;\">static <span style=\"color: #0000ff;\">void main(String[] args) <span style=\"color: #0000ff;\">throws Exception{\r\n7         Hello hello = <span style=\"color: #0000ff;\">new Hello();\r\n8         <span style=\"color: #000000; background-color: #ffff99;\">InputStream is = hello.getClass().getResourceAsStream(\"text.txt\");\r\n9         print(is);\r\n10     }\r\n11     \r\n12     <span style=\"color: #008000;\">/**\r\n13 <span style=\"color: #008000;\">     * 读取文件，输出里面的内容，通用方法\r\n14      <span style=\"color: #008000;\">*/\r\n15     <span style=\"color: #0000ff;\">public <span style=\"color: #0000ff;\">static <span style=\"color: #0000ff;\">void print(InputStream inputStream) <span style=\"color: #0000ff;\">throws Exception {\r\n16         InputStreamReader reader = <span style=\"color: #0000ff;\">new InputStreamReader(inputStream, \"utf-8\");\r\n17         BufferedReader br = <span style=\"color: #0000ff;\">new BufferedReader(reader);\r\n18         String s = \"\";\r\n19         <span style=\"color: #0000ff;\">while ((s = br.readLine()) != <span style=\"color: #0000ff;\">null)\r\n20             System.out.println(s);\r\n21         inputStream.close();\r\n22     }\r\n23 }</pre>\r\n</div>\r\n&nbsp;\r\n<span style=\"color: #333399;\"><strong>2、资源文件在另一个jar包内部&mdash;&mdash;读取另一个jar内的文件</strong>\r\n最终生成的jar包结构\r\n<blockquote>hello.jar<br />resource.jar<br />　text.txt</blockquote>\r\n&nbsp;方法步骤\r\n同1一样，只不过需要在MENIFEST文件中将resource.jar加入classpath\r\n<div class=\"cnblogs_code\">\r\n<pre>1 <span style=\"color: #0000ff;\">import java.io.InputStream;\r\n2 <span style=\"color: #0000ff;\">import java.io.BufferedReader;\r\n3 <span style=\"color: #0000ff;\">import java.io.InputStreamReader;\r\n4 \r\n5 <span style=\"color: #0000ff;\">class Hello{\r\n6     <span style=\"color: #0000ff;\">public <span style=\"color: #0000ff;\">static <span style=\"color: #0000ff;\">void main(String[] args) <span style=\"color: #0000ff;\">throws Exception{\r\n7         Hello hello = <span style=\"color: #0000ff;\">new Hello();\r\n8         <span style=\"background-color: #ffff99;\">InputStream is = hello.getClass().getResourceAsStream(\"text.txt\");\r\n9         print(is);\r\n10     }\r\n11     \r\n12     <span style=\"color: #008000;\">/**\r\n13 <span style=\"color: #008000;\">     * 读取文件，输出里面的内容，通用方法\r\n14      <span style=\"color: #008000;\">*/\r\n15     <span style=\"color: #0000ff;\">public <span style=\"color: #0000ff;\">static <span style=\"color: #0000ff;\">void print(InputStream inputStream) <span style=\"color: #0000ff;\">throws Exception {\r\n16         InputStreamReader reader = <span style=\"color: #0000ff;\">new InputStreamReader(inputStream, \"utf-8\");\r\n17         BufferedReader br = <span style=\"color: #0000ff;\">new BufferedReader(reader);\r\n18         String s = \"\";\r\n19         <span style=\"color: #0000ff;\">while ((s = br.readLine()) != <span style=\"color: #0000ff;\">null)\r\n20             System.out.println(s);\r\n21         inputStream.close();\r\n22     }\r\n23 }</pre>\r\n</div>\r\n&nbsp;\r\n<span style=\"color: #333399;\"><strong>3、资源文件在jar包外部&mdash;&mdash;读取jar外的文件</strong>\r\n最终生成的jar包结构\r\n<blockquote>hello.jar<br />text.txt</blockquote>\r\n&nbsp;方法步骤\r\n<div class=\"cnblogs_code\">\r\n<pre>1 <span style=\"color: #0000ff;\">import java.io.InputStream;\r\n2 <span style=\"color: #0000ff;\">import java.io.BufferedReader;\r\n3 <span style=\"color: #0000ff;\">import java.io.InputStreamReader;\r\n4 <span style=\"color: #0000ff;\">import java.io.FileInputStream;\r\n5 \r\n6 <span style=\"color: #0000ff;\">class Hello{\r\n7     <span style=\"color: #0000ff;\">public <span style=\"color: #0000ff;\">static <span style=\"color: #0000ff;\">void main(String[] args) <span style=\"color: #0000ff;\">throws Exception{\r\n8         Hello hello = <span style=\"color: #0000ff;\">new Hello();\r\n9         <span style=\"background-color: #ffff99;\">InputStream is = <span style=\"color: #0000ff;\">new FileInputStream(\"text.txt\");\r\n10         print(is);\r\n11     }\r\n12     \r\n13     <span style=\"color: #008000;\">/**\r\n14 <span style=\"color: #008000;\">     * 读取文件，输出里面的内容，通用方法\r\n15      <span style=\"color: #008000;\">*/\r\n16     <span style=\"color: #0000ff;\">public <span style=\"color: #0000ff;\">static <span style=\"color: #0000ff;\">void print(InputStream inputStream) <span style=\"color: #0000ff;\">throws Exception {\r\n17         InputStreamReader reader = <span style=\"color: #0000ff;\">new InputStreamReader(inputStream, \"utf-8\");\r\n18         BufferedReader br = <span style=\"color: #0000ff;\">new BufferedReader(reader);\r\n19         String s = \"\";\r\n20         <span style=\"color: #0000ff;\">while ((s = br.readLine()) != <span style=\"color: #0000ff;\">null)\r\n21             System.out.println(s);\r\n22         inputStream.close();\r\n23     }\r\n24 }</pre>\r\n</div>\r\n', '2018-03-16 16:30:00', '博客园', 'https://www.cnblogs.com/flashsun/p/7246260.html'),
(100, 'AJAX页面传值后处理方式', '呆子小白', 'JS', '之前在一个项目的时候，很多页面需要AJAX传值来渲染页面，每到这个时候，自己也觉得很头痛，因为每次渲染的时候，都使用的是把HTML代码拼接上去，一代代码量大了，很容易出错，还有就是没有易读性，在做完整个项目后，自己也觉得一定会有更好的办法，后来在一个朋友的帮助下，认识总算的到了一个他们使用的方案，让我豁然开朗，不一定是最优解，但是一定比使用HTML拼接更加容易维护更容易让人读懂。我把代码认真的读了几次，几乎把每一行都注释了，也写出了自己的疑问，希望大神解答。<pre><code>&lt;!doctype html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n &lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;Generator&quot; content=&quot;EditPlus®&quot;&gt;\n  &lt;meta name=&quot;Author&quot; content=&quot;&quot;&gt;\n  &lt;meta name=&quot;Keywords&quot; content=&quot;&quot;&gt;\n  &lt;meta name=&quot;Description&quot; content=&quot;&quot;&gt;\n  &lt;script type=&quot;text/javascript&quot; src=&quot;jquery.js&quot;&gt;&lt;/script&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n &lt;/head&gt;\n &lt;body&gt;\n &lt;!--非循环--&gt;\n        &lt;div id=&quot;container&quot; class=&quot;&quot;&gt;\n            &lt;p&gt;$[name]&lt;/p&gt;\n            &lt;p&gt;$[age]&lt;/p&gt;\n            &lt;p&gt;$[salary]&lt;/p&gt;\n        &lt;/div&gt;\n  &lt;!--循环--&gt;\n         &lt;!--模板 （不显示）--&gt;\n         &lt;div id=&quot;template&quot; style=&quot;display:none&quot;&gt;\n            &lt;div&gt;\n            $[name]&lt;br/&gt;\n            $[title]\n            &lt;/div&gt;\n         &lt;/div&gt;\n        &lt;div id=&quot;container1&quot; class=&quot;&quot;&gt;\n             \n        &lt;/div&gt;\n        &lt;a id=&quot;more&quot;&gt;点击加载更多&lt;/a&gt;\n &lt;/body&gt;\n&lt;/html&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    var json = {\n        name:&#x27;test&#x27;,\n        age:15,\n        salary:5500\n    }\n    //不循环绑定数据的话就直接指定容器\n    replaceElementInnerText($(&#x27;#container&#x27;),json)\n     \n    var json1 = {\n        name : &quot;这是循环的结果&quot;,\n        title:&quot;这是循环结果2&quot;\n    }\n    $(&#x27;#more&#x27;).click(function(){\n        var json2 = [{name:&#x27;name测试1&#x27;,title:&#x27;title测试1&#x27;},{name:&#x27;name测试2&#x27;,title:&#x27;title测试2&#x27;},{name:&#x27;name测试3&#x27;,title:&#x27;title测试3&#x27;}]\n    var temp = $(&#x27;#template&#x27;).children().prop(&#x27;outerHTML&#x27;);//获取template的子元素的HTML（包括自身）\n    for(var i = 0;i &lt;3;i++){//确定需要生成新模板的循环\n        var $temp = $(temp);//把模板转换为JQ对象\n        replaceElementInnerText($temp,json2[i]);\n        $(&#x27;#container1&#x27;).append($temp);\n    }\n     \n    })\n \n \n//替换函数\nfunction replaceElementInnerText (ele, data) {\n            var $ele,innerHTML;//创建两个变量\n            if(typeof ele == &#x27;string&#x27;){//判断ele是否为对象还是字符串，是字符串就再次转换为对象\n                $ele=$(ele);\n                innerHTML=$ele.html();//然后调出此对象的HTML\n            }else{//如果是对象\n                $ele=(ele instanceof jQuery)?ele:$(ele);//就判断ele的实例对象是否为jq如果不是则转换为jq对象\n                innerHTML=$ele.html();//得到此对象的HTML\n            }\n            var pattern=/\\$\\[(\\w+\\.*\\w*)]/g;//正则式，根据自己规则来编写\n            var replace_attr=[];//创建一个空数组，用来装即将匹配的文本\n            var i=0;\n            while(i++&lt;100) {\n                var result = pattern.exec(innerHTML);//把innerHTML放入正则式去搜索\n                if (!result) {//如果搜索不到，循环结束\n                    break;\n                }\n                replace_attr.push(result[1]);//把搜索到的文本添加到预先准备的数组里\n            }\n            for(var key in replace_attr){//给数组循环\n                var replace=new RegExp(&#x27;\\\\$\\\\[&#x27;+replace_attr[key]+&#x27;\\\\]&#x27;,&#x27;g&#x27;);//创建一个正则式\n                if(replace_attr[key].indexOf(&quot;.&quot;)&gt;0){//如果当前名字里有.去掉点，拆分为数组（注：这里自己感觉太累赘，可能我哪里没有想到）\n                    var replace_attr_keys=replace_attr[key].split(&quot;.&quot;);\n                    var replace_attr_str=&quot;data&quot;;//创建一个字符串，用于后面的拼接\n                    if(!data[replace_attr_keys[0]]||typeof data[replace_attr_keys[0]]!==&#x27;object&#x27;){\n                        continue;\n                    }\n                    for(var _key in replace_attr_keys){//循环拆分出来的数组\n                        replace_attr_str+=&#x27;[\\&#x27;&#x27;+replace_attr_keys[_key]+&#x27;\\&#x27;]&#x27;;//拼接拆分猪来的数组\n                    }\n                    if(eval(replace_attr_str)!=null){\n                        innerHTML=innerHTML.replace(replace,eval(replace_attr_str));//把值替换为后台服务器传值\n                    }\n                }else{\n                    if(data[replace_attr[key]]!=null){\n                        innerHTML=innerHTML.replace(replace,data[replace_attr[key]]);//把值替换\n                    }\n                }\n            }\n           $ele[0].innerHTML=innerHTML;\n          /*  $ele.find(&#x27;img[img-load=&quot;load&quot;]&#x27;).each(function () {\n                var reg=new RegExp(&quot;(http|ftp|https):\\/\\/w*&quot;);\n                if(reg.exec($(this).attr(&#x27;_src&#x27;))){\n                    $(this).attr(&quot;src&quot;,$(this).attr(&#x27;_src&#x27;));\n                }\n            });图片替换原理相同，这里没有图片所以注释*/\n            return $ele[0].outerHTML;//函数返回值\n        }</code></pre>再次感谢这位朋友，让我认识到前后端分离，框架，模块化管理。共勉！！', '2018-03-17 19:46:00', '博客园', 'https://www.cnblogs.com/daizixiaobai/p/5766037.html'),
(101, 'Ajax请求成功后打开新窗口地址', 'Ruthless', 'JS', '<blockquote>这篇文章主要介绍了Ajax请求成功后打开新窗口地址的相关资料,非常不错，具有参考借鉴价值，需要的朋友可以参考下</blockquote>\r\n废话不多说，关键代码如下所示：<pre><code>jQuery.ajax({\r\n\"type\":\"post\",\r\n\"url\":\"http://www.baidu.com\", \r\n\"success\":function(rel){\r\nif(rel.isSuccess){ \r\nwindow.open(rel.url,\"_blank\");\r\n}\r\n}\r\n}); </code></pre>\r\n这个url请求成功后window.open(rel.url,\"_blank\");会被浏览器拦截，无法打开新窗口，如果把window.open()放在ajax外面，问题就迎刃而解，代码如下：<pre><code>var result=\"\";\r\njQuery.ajax({\r\n\"type\":\"post\",\r\n\"url\":\"http://www.baidu.com\", \r\n\"success\":function(rel){\r\nif(rel.isSuccess){ \r\nresult=rel.url;\r\n//window.open(rel.url,\"_blank\");\r\n}\r\n}\r\n});\r\nif(result.length>0){\r\nwindow.open(result,\"_blank\");\r\n}</code></pre>\r\n下面看下在Ajax响应之后打开新窗口\r\n\r\n最近的开发中有一个功能，点击一个链接之后，要判断当前的用户是否登录，没有登录的话，需要弹出一个登录对话框，用户登录之后，再在新的窗口(标签)中打开链接指向的Url。\r\n\r\n不多说，直接贴出代码：\r\n<pre><code>$(document).delegate(\"a\", \"click\", function () { \r\nvar actionUrl = $(this).attr(\"href\"); \r\nvar ssoAction = function () { window.open(actionUrl, \'_blank\'); }; \r\nif (isLogin()) { \r\nssoAction(); \r\n} else { \r\npopup.show({login:function () { \r\n$.ajax({ \r\ntype: \"post\", \r\ndataType: \"json\", \r\nurl: \"/Account/Login\", \r\ndata: $(\"frmLogin\").serialize(), \r\n//发送方式改为同步，避免弹出页面被浏览器拦截\r\nasync: false, \r\nsuccess: function (oData) { \r\nssoAction(); \r\n} \r\n}); \r\n}); \r\n} \r\nreturn false; \r\n});</code></pre>\r\n重点：需要使用同步提交，使用异步提交，callback里面打开新窗口(标签)，会被浏览器认为是恶意行为。', '2018-03-17 19:50:00', '脚本之家', 'http://www.jb51.net/article/89860.htm'),
(102, '$.ajax()方法进行网页间传值示例', '佚名', 'JS', '<blockquote>这篇文章主要介绍了$.ajax()方法进行网页间传值的具体实现,需要的朋友可以参考下</blockquote>\r\najaxtext1.jsp \r\n<pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot;%&gt; \r\n&lt;script type=&quot;text/javascript&quot; language=&quot;javascript&quot; src=&quot;jquery.js&quot;&gt;&lt;/script&gt; &lt;!-- 必须包含 jquery.js文件，否则将无法传值--&gt; \r\n&lt;head&gt; \r\n&lt;script type=&quot;text/javascript&quot;&gt; \r\nfunction fun(){ \r\nvar ss; \r\nvar radio1=document.getElementsByName(&quot;radio1&quot;); //读取单选按钮的值 \r\nfor(var i=0;i&lt;radio1.length;i++){ \r\nif(radio1.item(i).checked){ \r\nss=radio1.item(i).value; \r\nbreak; \r\n} \r\n} \r\n// var sendstr=&quot;sendstr1=&quot;+form1.text1.value+&quot;&amp;sendstr2=&quot;+ss; \r\n$.ajax({ \r\ntype:&quot;POST&quot;, \r\nurl: &quot;ajaxtest2.jsp&quot;, \r\nasync:false, \r\n// data:sendstr, //也可以用注释的这方式来进行传值操作 \r\ndata:{sendstr1:form1.text1.value,sendstr2:ss}, //也可以用 $(&quot;#text1&quot;).val()的方式读取text1中的元素值 \r\nsuccess:function(data){ \r\nalert(data); \r\n} \r\n}); \r\n} \r\n&lt;/script&gt; \r\n&lt;/head&gt; \r\n&lt;body&gt; \r\n&lt;div align=&quot;center&quot;&gt; \r\n&lt;form id=&quot;form1&quot; name=&quot;form1&quot; action=&quot;&quot; method=&quot;post&quot; &gt; \r\n输入：&lt;input type=&quot;text&quot; name=&quot;text1&quot; id=&quot;text1&quot;&gt;&lt;br&gt; \r\n金球：&lt;input type=&quot;radio&quot; name=&quot;radio1&quot; value=&quot;梅西&quot;&gt;梅西 \r\n&lt;input type=&quot;radio&quot; name=&quot;radio1&quot; value=&quot;C罗&quot;&gt;C罗&lt;br&gt; \r\n&lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;fun()&quot;&gt; \r\n&lt;/form&gt; \r\n&lt;/div&gt; \r\n&lt;/body&gt; \r\n&lt;/html&gt; </code></pre>\r\najaxtest2.jsp <pre><code>&lt;pre code_snippet_id=&quot;269881&quot; snippet_file_name=&quot;blog_20140402_4_8173458&quot; class=&quot;javascript&quot; name=&quot;code&quot;&gt;&lt;%@ page contentType=&quot;text/html;charset=utf-8&quot;%&gt; \r\n\r\n&lt;% \r\nrequest.setCharacterEncoding(&quot;utf-8&quot;); \r\nString sendstr1=request.getParameter(&quot;sendstr1&quot;); \r\nString sendstr2=request.getParameter(&quot;sendstr2&quot;); \r\nString sReturn=sendstr1+&quot;_new_&quot;+sendstr2; \r\n%&gt; \r\n&lt;%=sReturn%&gt;&lt;/pre&gt;&lt;pre code_snippet_id=&quot;269881&quot; snippet_file_name=&quot;blog_20140402_5_3124712&quot; class=&quot;javascript&quot; name=&quot;code&quot;&gt;&lt;/pre&gt;&lt;pre code_snippet_id=&quot;269881&quot; snippet_file_name=&quot;blog_20140402_5_3124712&quot; class=&quot;javascript&quot; name=&quot;code&quot;&gt;&lt;h2 class=&quot;titName SG_txta&quot; id=&quot;t_4f925fc30100la36&quot;&gt;JQuery中$.ajax()方法参数详解 问百度或Google \r\n&lt;/h2&gt;&lt;/pre&gt; \r\n&lt;pre&gt;&lt;/pre&gt; \r\n&lt;div style=&quot;top:177px&quot;&gt;﻿﻿&lt;/div&gt; \r\n&lt;pre&gt;&lt;/pre&gt; </code></pre>', '2018-03-17 20:01:00', '脚本之家', 'http://www.jb51.net/article/48668.htm'),
(103, 'php导出excel（xls或xlsx）（解决长数字显示问题）', 'Tiac', 'PHP', '1）demo<pre><code>\r\n$titles = array(\'订单号\',\'商品结算码\',\'合同号\',\'供应商名称\',\'专柜\',\'商品名称\',\'商品货号\',\'商品单价\',\'商品总价\',\'供应商结算金额\',\'商品数量\',\'商品促销优惠\',\'平台优惠抵扣\',\'品牌订单优惠抵扣\');\r\n\r\n//导出准备\r\nob_get_clean();\r\nob_start();\r\necho implode(\"\\t\", $titles),\"\\n\";\r\n\r\n$currencyModel      = app::get(\'ectools\')->model(\'currency\');\r\nforeach ($lists as $key=>$value) {\r\n    $row                             = array();\r\n    $row[\'order_id\']                = html_entity_decode(\"&iuml;&raquo;&iquest;\".$value[\'order_id\']);\r\n    $row[\'supplier_num\']            = $value[\'supplier_num\'];\r\n    $row[\'agreement_code\']            = $value[\'agreement_code\'];\r\n    $row[\'supplier_name\']            = $value[\'supplier_name\'];\r\n    $row[\'shoppe_name\']                = $value[\'shoppe_name\'];\r\n    $row[\'name\']                    = $value[\'name\'];\r\n    $row[\'bn\']                        = $value[\'bn\'];\r\n    $row[\'price\']                   = $value[\'price\'];\r\n    $row[\'nums\']                    = $value[\'nums\'];\r\n    $row[\'g_price\']                 = $value[\'g_price\'];\r\n    $row[\'settlement_amount\']       = $value[\'settlement_amount\'];\r\n    $row[\'goods_amount_off\']         = $value[\'goods_amount_off\'];\r\n    $row[\'amount_off\']                 = $value[\'amount_off\'];\r\n    $row[\'brand_amount_off\']         = $value[\'brand_amount_off\'];\r\n\r\n    echo implode(\"\\t\", $row),\"\\n\";\r\n}\r\n\r\nheader(\'Content-Disposition: attachment; filename=\'.$filename);\r\nheader(\'Accept-Ranges:bytes\');\r\nheader(\'Content-Length:\' . ob_get_length());\r\nheader(\'Content-Type:application/vnd.ms-excel\');\r\nob_end_flush();\r\n</code></pre>\r\n 2）格式选择\r\n\r\n需要导出xls的话，用<code>\r\nheader(\'Content-Type:application/vnd.ms-excel\');</code>\r\n需要导出xlsx的话，用\r\n<code>\r\nheader(\'Content-Type:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\');\r\n</code>xls和xlsx的区别的话，是储存数据量大小的问题，xls只可以保存大概5、6w数据，xlsx可以100w左右\r\n\r\n3）长数字完整显示解决办法\r\n<code>\r\n$row[\'order_id\'] = html_entity_decode(\"&iuml;&raquo;&iquest;\".$value[\'order_id\']);\r\n</code>就是先拼上html 特殊字符 &iuml;&raquo;&iquest;，再转回去的意思\r\n\r\nPS:这个办法，是从PHPExcel上逆回去找到的\r\n\r\n我把PHPExcel生成的数字复制到txt文件里，再解释它是什么东东，然后就发现这个东西了', '2018-03-18 11:05:00', '博客园', 'https://www.cnblogs.com/tujia/p/5999806.html'),
(104, 'php导出csv报表', '剑侠之孤狼', 'PHP', '实际工作中,报表导出功能很常见,导出格式常见分为excel格式和csv格式.如果报表数据量非常大,那么excel就表现不足,excel2003版只有65536行,excel2007开始上升到1048576行.但是大数据量依然不够.这时,csv就体现出它的优越性,没有限制行.导出功能也更加简单,下面为大家介绍csv导出功能的实现.\r\n\r\ncsv导出分为3个步骤:\r\n\r\n1.数据库取出数据,存放在二维数组中<pre><code>//1.数据库取出数据  \r\n$conn=new mysqli(\'localhost\',\'root\',\'root\',\'myDBPDO\');  \r\n$result=$conn->query(\'select * from emp\');  \r\n$emps=array();  \r\nwhile($row=$result->fetch_assoc()){  \r\n    static $i=0;  \r\n    $emps[$i] = $row;  \r\n    $i++;  \r\n}</code></pre>2.输出csv数据(表头及内容)<pre><code>//设置内存占用  \r\nset_time_limit(0);  \r\nini_set(\'memory_limit\', \'512M\');  \r\n  \r\n//为fputcsv()函数打开文件句柄  \r\n$output = fopen(\'php://output\', \'w\') or die(\"can\'t open php://output\");  \r\n//告诉浏览器这个是一个csv文件  \r\n$filename = \"员工信息表\" . date(\'Y-m-d\', time());  \r\nheader(\"Content-Type: application/csv\");  \r\nheader(\"Content-Disposition: attachment; filename=$filename.csv\");  \r\n//输出表头  \r\n$table_head = array(\'id\',\'姓名\',\'年龄\', \'薪水\');  \r\nfputcsv($output, $table_head);  \r\n//输出每一行数据到文件中  \r\nforeach ($emps as $e) {  \r\n//    unset($e[\'xx\']);//若有多余字段可以使用unset去掉  \r\n//    $e[\'xx\'] = isset($e[\'xxx\']) ? \"xx\" : \'x\'; //可以根据需要做相应处理  \r\n    //输出内容  \r\n    fputcsv($output, array_values($e));  \r\n}</code></pre>3.关闭句柄<pre><code>&lt;span style=&quot;font-size:14px;&quot;&gt;  \r\n//关闭文件句柄  \r\nfclose($output) or die(&quot;can&#x27;t close php://output&quot;);  \r\nexit;  \r\n  \r\n&lt;/span&gt;</code></pre>到这里，我们就成功实现了csv报表导出功能。', '2018-03-18 11:12:00', 'CSDN', 'https://blog.csdn.net/happy1314515/article/details/51057546');
INSERT INTO `wu_blog` (`id`, `post_title`, `post_author`, `post_type`, `post_content`, `post_date`, `post_from`, `post_link`) VALUES
(105, 'PHP实现导出带样式的Excel', 'hebedich', 'PHP', '<blockquote>有时客户会向你抱怨，软件为他们导出的Excel格式太难看了，或许这篇文章会对你有所帮助。在用PHP导出数据的同时还可以设置颜色、字号大小、加粗、合并单元格等等。</blockquote>工作中做导出的时候，需要导出自定义的表格或嫌弃导出的Excel格式太难看了。\r\n\r\n需要设置颜色、字号大小、加粗、合并单元格等等。\r\n\r\n效果图：\r\n\r\nPHP代码：<pre><code>/**\r\n* 导出文件\r\n* @return string\r\n*/\r\npublic function export()\r\n{\r\n$file_name  = &quot;成绩单-&quot;.date(&quot;Y-m-d H:i:s&quot;,time());\r\n$file_suffix = &quot;xls&quot;;\r\nheader(&quot;Content-Type: application/vnd.ms-excel&quot;);\r\nheader(&quot;Content-Disposition: attachment; filename=$file_name.$file_suffix&quot;);\r\n//根据业务，自己进行模板赋值。\r\n$this-&gt;display();\r\n}</code></pre>HTML代码：<pre><code>&lt;html xmlns:o=&quot;urn:schemas-microsoft-com:office:office&quot;\r\nxmlns:x=&quot;urn:schemas-microsoft-com:office:excel&quot;\r\nxmlns=&quot;http://www.w3.org/TR/REC-html40&quot;&gt;\r\n&lt;head&gt;\r\n&lt;meta http-equiv=Content-Type content=&quot;text/html; charset=utf-8&quot;&gt;\r\n&lt;meta name=ProgId content=Excel.Sheet&gt;\r\n&lt;meta name=Generator content=&quot;Microsoft Excel 11&quot;&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n&lt;table border=1 cellpadding=0 cellspacing=0 width=&quot;100%&quot; &gt;\r\n&lt;tr&gt;\r\n&lt;td colspan=&quot;5&quot; align=&quot;center&quot;&gt;\r\n&lt;h2&gt;成绩单&lt;/h2&gt;\r\n&lt;/td&gt;\r\n&lt;/tr&gt;\r\n&lt;tr&gt;\r\n&lt;td style=&#x27;width:54pt&#x27; align=&quot;center&quot;&gt;编号&lt;/td&gt;\r\n&lt;td style=&#x27;width:54pt&#x27; align=&quot;center&quot;&gt;姓名&lt;/td&gt;\r\n&lt;td style=&#x27;width:54pt&#x27; align=&quot;center&quot;&gt;语文&lt;/td&gt;\r\n&lt;td style=&#x27;width:54pt&#x27; align=&quot;center&quot;&gt;数学&lt;/td&gt;\r\n&lt;td style=&#x27;width:54pt&#x27; align=&quot;center&quot;&gt;英语&lt;/td&gt;\r\n&lt;/tr&gt;\r\n&lt;tr&gt;\r\n&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;\r\n&lt;td style=&quot;background-color: #00CC00;&quot; align=&quot;center&quot;&gt;Jone&lt;/td&gt;\r\n&lt;td style=&quot;background-color: #00adee;&quot; align=&quot;center&quot;&gt;90&lt;/td&gt;\r\n&lt;td style=&quot;background-color: #00CC00;&quot; align=&quot;center&quot;&gt;85&lt;/td&gt;\r\n&lt;td style=&quot;background-color: #00adee;&quot; align=&quot;center&quot;&gt;100&lt;/td&gt;\r\n&lt;/tr&gt;\r\n&lt;tr&gt;\r\n&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;\r\n&lt;td style=&quot;background-color: #00CC00;&quot; align=&quot;center&quot;&gt;Tom&lt;/td&gt;\r\n&lt;td style=&quot;background-color: #00adee;&quot; align=&quot;center&quot;&gt;99&lt;/td&gt;\r\n&lt;td style=&quot;background-color: #00CC00;&quot; align=&quot;center&quot;&gt;85&lt;/td&gt;\r\n&lt;td style=&quot;background-color: #00adee;&quot; align=&quot;center&quot;&gt;80&lt;/td&gt;\r\n&lt;/tr&gt;\r\n&lt;/table&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;</code></pre>我们再来看一个更方便的组件\r\n\r\n在这里需要用到PEAR的两个软件包 Spreadsheet Excel Writer 和 OLE，如果没有可以分别从 <a href=\"http://pear.php.net/package/Spreadsheet_Excel_Writer/\">http://pear.php.net/package/Spreadsheet_Excel_Writer/</a> 和 <a href=\"http://pear.php.net/package/OLE/\">http://pear.php.net/package/OLE/</a> 下载，解压放在PEAR目录下。\r\n\r\n全部代码如下：<pre><code>&lt;?php\r\ninclude &#x27;Writer.php&#x27;;\r\n\r\n/* *** 准备导出的数据 *** */\r\n$head = &#x27;One Week Schedule&#x27;;\r\n$data = array(&#x27;Monday&#x27; =&gt;   array( array(&#x27;time&#x27; =&gt; &#x27;09:00&#x27;, &#x27;event&#x27; =&gt; &#x27;公司例会例会&#x27;),\r\n                      array(&#x27;time&#x27; =&gt; &#x27;14:00&#x27;, &#x27;event&#x27; =&gt; &#x27;部门例会&#x27;)\r\n                    ),\r\n         &#x27;Tuesday&#x27; =&gt;   array( array(&#x27;time&#x27; =&gt; &#x27;09:30&#x27;, &#x27;event&#x27; =&gt; &#x27;和 Mr. Stinsen 早餐&#x27;)),\r\n         &#x27;Wednesday&#x27; =&gt;   array(array(&#x27;time&#x27; =&gt; &#x27;12:10&#x27;, &#x27;event&#x27; =&gt; &#x27;市场中阶报告&#x27;),\r\n                    array(&#x27;time&#x27; =&gt; &#x27;15:30&#x27;, &#x27;event&#x27; =&gt; &#x27;市场部战略部署会议&#x27;) ),\r\n         &#x27;Thursday&#x27; =&gt;   array( array(&#x27;time&#x27; =&gt; &#x27;&#x27;, &#x27;event&#x27; =&gt; &#x27;&#x27;)),\r\n         &#x27;Friday&#x27; =&gt;   array( array(&#x27;time&#x27; =&gt; &#x27;16:00&#x27;, &#x27;event&#x27; =&gt; &#x27;WoC Stock 研讨会&#x27;),\r\n                    array(&#x27;time&#x27; =&gt; &#x27;17:00&#x27;, &#x27;event&#x27; =&gt; &#x27;飞往华尔街&#x27;),\r\n                    array(&#x27;time&#x27; =&gt; &#x27;21:00&#x27;, &#x27;event&#x27; =&gt; &#x27;会见克林顿&#x27;))\r\n     );\r\n/* *** *** */\r\n\r\n$workbook = new Spreadsheet_Excel_Writer();\r\n$filename = date(&#x27;YmdHis&#x27;).&#x27;.xls&#x27;;//csv\r\n$workbook-&gt;send($filename); // 发送 Excel 文件名供下载\r\n$workbook-&gt;setVersion( 8 );\r\n\r\n$sheet = &amp;$workbook-&gt;addWorksheet(&quot;Sheet1&quot;);   // 创建工作表\r\n$sheet-&gt;setInputEncoding(&#x27;utf-8&#x27;);          // 字符集\r\n$headFormat = &amp;$workbook-&gt;addFormat(array(&#x27;Size&#x27; =&gt; 14, &#x27;Align&#x27; =&gt; &#x27;center&#x27;,&#x27;Color&#x27; =&gt; &#x27;white&#x27;, &#x27;FgColor&#x27; =&gt; &#x27;brown&#x27;, &#x27;Bold&#x27;=&gt;&#x27;1&#x27;, &#x27;Border&#x27; =&gt; &#x27;1&#x27;));//定义格式\r\n$dayFormat = &amp;$workbook-&gt;addFormat(array(&#x27;Size&#x27; =&gt; 12, &#x27;Align&#x27; =&gt; &#x27;center&#x27;, &#x27;VAlign&#x27; =&gt; &#x27;vcenter&#x27;, &#x27;FgColor&#x27; =&gt; &#x27;green&#x27;, &#x27;Color&#x27; =&gt; &#x27;white&#x27;, &#x27;Border&#x27; =&gt; &#x27;1&#x27;));//定义格式\r\n$dataFormat = &amp;$workbook-&gt;addFormat(array(&#x27;Size&#x27; =&gt; 10, &#x27;Align&#x27; =&gt; &#x27;left&#x27;, &#x27;Border&#x27; =&gt; &#x27;1&#x27;, &#x27;Color&#x27; =&gt; &#x27;black&#x27;, &#x27;FgColor&#x27;=&gt; &#x27;cyan&#x27;));//定义格式\r\n\r\n$sheet-&gt;setColumn(0, 0, 20);   // 设置宽度\r\n$sheet-&gt;setColumn(1, 1, 15);   // 设置宽度\r\n$sheet-&gt;setColumn(2, 2, 30);   // 设置宽度\r\n\r\n$r = 0;   \r\n$sheet-&gt;write(0, $r, $head, $headFormat);   // 表格标题\r\n$sheet-&gt;mergeCells(0, 0, 0, 2);   // 跨列显示\r\n\r\n$r++;   // 数据从第2行开始\r\nforeach ($data as $day =&gt; $events){\r\n   $c = 0;\r\n   $sheet-&gt;write($r, $c, $day, $dayFormat);\r\n   if (!$events){\r\n     // 当天没有计划\r\n     $r++;\r\n   } else {\r\n     $startRow = $r;\r\n     foreach ($events as $e){\r\n        $c = 1;\r\n        $sheet-&gt;write($r, $c++, $e[&#x27;time&#x27;], $dataFormat);   // 工作表写入数据\r\n        $sheet-&gt;write($r, $c++, $e[&#x27;event&#x27;], $dataFormat);   // 工作表写入数据\r\n        $r++;\r\n     }\r\n     // 合并 $day 单元格\r\n     $sheet-&gt;mergeCells($startRow, 0, $r - 1, 0);\r\n   }\r\n}\r\n$workbook-&gt;close(); // 完成下载\r\n ?&gt;</code></pre>', '2018-03-18 11:13:00', '脚本之家', 'http://www.jb51.net/article/91395.htm'),
(106, 'PHP5.2中date()函数显示时间与北京时间相差8小时的解决办法', '佚名', 'PHP', '<blockquote>北京时间是东8区,可能是时区问题.但是此前都没问题啊,经过google发现原来从php5.1.0开始，php.ini里加入了 date.timezone这个选项，默认情况下是关闭的</blockquote>\r\n问题:\r\n\r\nphp函数date(\"Y-n-d   H-i-s\");   输出的时间与当地时间相差8个小时.\r\n\r\n解决思路\r\n\r\n北京时间是东8区,可能是时区问题.但是此前都没问题啊,经过google发现原来从php5.1.0开始，php.ini里加入了 date.timezone这个选项，默认情况下是关闭的,也就是显示的时间（无论用什么php命令）都是格林威治标准时间,和我们的时间（北京时间）差了正好8个小时。\r\n\r\n 在调用date()函数之前先设定时区。\r\n\r\n方法一：\r\ndate_default_timezone_set(\'PRC\');\r\n没有返回值。下面再直接使用date函数就OK了\r\n$time = date(Y.\"年\".m.\"月\".d.\"日\".G.\"时\".i.\"分\");\r\n\r\n方法二：\r\n\r\n修改php.ini中的;date.timezone = 为date.timezone = \"Asia/Shanghai\"(或者改为date.timezone = PRC)并去掉前面的分号，重启Apache即可。', '2018-03-18 11:13:00', '脚本之家', 'http://www.jb51.net/article/18322.htm'),
(107, '关于easyui Resource interpreted as Document but transferred with MIME type application/json', '圣环的博客', 'JS,Apache', 'PS：项目是用SpringMVC+easyui搭建的\r\n\r\n今天用谷歌调试测试新写的保存功能，发现保存成功之后出现Resource interpreted as Document but transferred with MIME type application/json \r\n\r\n如图：\r\n\r\n<img src=\"https://img-blog.csdn.net/20150624103507091?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDE2MTA4Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\">\r\n\r\n猜想会出现的原因是服务器响应的content-type值是application/json,而谷歌浏览器所期望的值应该是text/html。\r\n\r\n所以翻回配置文件查看，找到org.springframework.http.converter.json.MappingJacksonHttpMessageConverter Bean 更改値为text/html。\r\n\r\n重新启动项目调试，果然没有再出现Resource interpreted as Document but transferred with MIME type application/json ', '2018-03-18 21:44:00', 'CSDN', 'https://blog.csdn.net/u010161082/article/details/46618947'),
(108, 'php的header函数之设置content-type', 'kankan231', 'PHP', '设置常用的content-type：<pre><code>//定义编码\nheader( &#x27;Content-Type:text/html;charset=utf-8 &#x27;);\n\n//Atom\nheader(&#x27;Content-type: application/atom+xml&#x27;);\n\n//CSS\nheader(&#x27;Content-type: text/css&#x27;);\n\n//Javascript\nheader(&#x27;Content-type: text/javascript&#x27;);\n\n//JPEG Image\nheader(&#x27;Content-type: image/jpeg&#x27;);\n\n//JSON\nheader(&#x27;Content-type: application/json&#x27;);\n\n//PDF\nheader(&#x27;Content-type: application/pdf&#x27;);\n\n//RSS\nheader(&#x27;Content-Type: application/rss+xml; charset=ISO-8859-1&#x27;);\n\n//Text (Plain)\nheader(&#x27;Content-type: text/plain&#x27;);\n\n//XML\nheader(&#x27;Content-type: text/xml&#x27;);\n\n// ok\nheader(&#x27;HTTP/1.1 200 OK&#x27;);\n\n//设置一个404头:\nheader(&#x27;HTTP/1.1 404 Not Found&#x27;);\n\n//设置地址被永久的重定向\nheader(&#x27;HTTP/1.1 301 Moved Permanently&#x27;);\n\n//转到一个新地址\nheader(&#x27;Location: http://www.example.org/&#x27;);\n\n//文件延迟转向:\nheader(&#x27;Refresh: 10; url=http://www.example.org/&#x27;);\nprint &#x27;You will be redirected in 10 seconds&#x27;;\n\n//当然，也可以使用html语法实现\n// &lt;meta http-equiv=&quot;refresh&quot; content=&quot;10;http://www.example.org/ /&gt;\n\n// override X-Powered-By: PHP:\nheader(&#x27;X-Powered-By: PHP/4.4.0&#x27;);\nheader(&#x27;X-Powered-By: Brain/0.6b&#x27;);\n\n//文档语言\nheader(&#x27;Content-language: en&#x27;);\n\n//告诉浏览器最后一次修改时间\n$time = time() - 60; // or filemtime($fn), etc\nheader(&#x27;Last-Modified: &#x27;.gmdate(&#x27;D, d M Y H:i:s&#x27;, $time).&#x27; GMT&#x27;);\n\n//告诉浏览器文档内容没有发生改变\nheader(&#x27;HTTP/1.1 304 Not Modified&#x27;);\n\n//设置内容长度\nheader(&#x27;Content-Length: 1234&#x27;);\n\n//设置为一个下载类型\nheader(&#x27;Content-Type: application/octet-stream&#x27;);\nheader(&#x27;Content-Disposition: attachment; filename=&quot;example.zip&quot;&#x27;);\nheader(&#x27;Content-Transfer-Encoding: binary&#x27;);\n// load the file to send:\nreadfile(&#x27;example.zip&#x27;);\n\n// 对当前文档禁用缓存\nheader(&#x27;Cache-Control: no-cache, no-store, max-age=0, must-revalidate&#x27;);\nheader(&#x27;Expires: Mon, 26 Jul 1997 05:00:00 GMT&#x27;); // Date in the past\nheader(&#x27;Pragma: no-cache&#x27;);\n\n//设置内容类型:\nheader(&#x27;Content-Type: text/html; charset=iso-8859-1&#x27;);\nheader(&#x27;Content-Type: text/html; charset=utf-8&#x27;);\nheader(&#x27;Content-Type: text/plain&#x27;); //纯文本格式\nheader(&#x27;Content-Type: image/jpeg&#x27;); //JPG***\nheader(&#x27;Content-Type: application/zip&#x27;); // ZIP文件\nheader(&#x27;Content-Type: application/pdf&#x27;); // PDF文件\nheader(&#x27;Content-Type: audio/mpeg&#x27;); // 音频文件\nheader(&#x27;Content-Type: application/x-shockw**e-flash&#x27;); //Flash动画\n\n//显示登陆对话框\nheader(&#x27;HTTP/1.1 401 Unauthorized&#x27;);\nheader(&#x27;WWW-Authenticate: Basic realm=&quot;Top Secret&quot;&#x27;);\nprint &#x27;Text that will be displayed if the user hits cancel or &#x27;;\nprint &#x27;enters wrong login data&#x27;;</pre></code>下载xlsx文件<pre><code>$filename = rtrim($_SERVER[&#x27;DOCUMENT_ROOT&#x27;],&#x27;/&#x27;).&#x27;/app/files/payment_status.csv&#x27;;  \nheader(&#x27;Content-Disposition: attachment; filename=payment_status.xlsx&#x27;);  \nheader(&#x27;Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&#x27;);  \nheader(&#x27;Content-Length: &#x27; . filesize($filename));  \nheader(&#x27;Content-Transfer-Encoding: binary&#x27;);  \nheader(&#x27;Cache-Control: must-revalidate&#x27;);  \nheader(&#x27;Pragma: public&#x27;);  \nreadfile($filename);</code></pre>', '2018-03-18 21:45:00', 'CSDN', 'https://blog.csdn.net/kankan231/article/details/37929409'),
(109, ' HTTP URL最大长度', '清箫', 'http', 'HTTP RFC2616协议没有规定URL的最大长度，但规定服务器如果不能处理太长的URL，就得返回414状态码（Request-URI Too Long）。\r\n\r\nHTTP RFC2616协议指出，某些旧的客户端或代理，可能无法处理超过255个字节的URI。\r\n\r\n既然HTTP协议没有规定URL的最大长度，那么URL的最大长度与用户的浏览器有关，同时和服务器能够处理的最大长度URL有关。\r\n\r\n站点地图协议（sitemap protocol），限制URL的长度是2048，如果你想让搜索引擎能够搜索到你，2048是最大极限了。\r\n\r\nGoogle最大能抓取和索引2047个字节的URL，但是，用户点击的时候会返回414，经过测试，Google的SERP连接，最大不能超过1855个字符，超过这个数，用户点击则返回414。\r\n\r\nIE8的URL的最大URL长度是2083个字节，其中路径部分（Path）最大长度是2048个字节。IE9也有类似限制，IE10也只接受2083个字节。虽然点击URL长度比这个长的连接依然可以工作，但地址栏只显示前2083个字节。\r\n\r\n有网友测试了个浏览器和服务器支持的最大URL长度，附表如下：<table cellpadding=\"0\" cellspacing=\"0\" border=\"1\"><tbody><tr><td valign=\"top\"><p>IE</p></td>  <td valign=\"top\"><p>URL最大限制是2083个字节，Path长度最大是2048字节（Get请求）。</p></td> </tr><tr><td valign=\"top\"><p>Firefox</p></td>  <td valign=\"top\"><p>65536</p></td> </tr><tr><td valign=\"top\"><p>Safari</p></td>  <td valign=\"top\"><p>80000以上</p></td> </tr><tr><td valign=\"top\"><p>Opera</p></td>  <td valign=\"top\"><p>190000字节以上</p></td> </tr><tr><td valign=\"top\"><p>Chrome</p></td>  <td valign=\"top\"><p>8182字节</p></td> </tr><tr><td valign=\"top\"><p>Apache Server</p></td>  <td valign=\"top\"><p>8192字节</p></td> </tr><tr><td valign=\"top\"><p>IIS</p></td>  <td valign=\"top\"><p>16384字节</p></td> </tr><tr><td valign=\"top\"><p>Perl HTTP::Daemon</p></td>  <td valign=\"top\"><p>至少8000字节</p></td> </tr></tbody></table>这里有一个有趣的测试：\r\n\r\nhttp://www.seomofo.com/experiments/title-and-h1-of-this-post-but-for-the-sake-of-keyword-prominence-stuffing-im-going-to-mention-it-again-using-various-synonyms-stemmed-variations-and-of-coursea-big-fat-prominent-font-size-heres-the-stumper-that-stumped-me-what-is-the-max-number-of-chars-in-a-url-that-google-is-willing-to-crawl-and-index-for-whatever-reason-i-thought-i-had-read-somewhere-that-googles-limit-on-urls-was-255-characters-but-that-turned-out-to-be-wrong-so-maybe-i-just-made-that-number-up-the-best-answer-i-could-find-was-this-quote-from-googles-webmaster-trends-analyst-john-mueller-we-can-certainly-crawl-and-index-urls-over-1000-characters-long-but-that-doesnt-mean-that-its-a-good-practice-the-setup-for-this-experiment-is-going-to-be-pretty-simple-im-going-to-edit-the-permalink-of-this-post-to-be-really-really-long-then-im-going-to-see-if-google-indexes-it-i-might-even-see-if-yahoo-and-bing-index-iteven-though-no-one-really-cares-what-those-assholes-are-doing-url-character-limits-unrelated-to-google-the-question-now-is-how-many-characters-should-i-make-the-url-of-this-post-there-are-a-couple-of-sources-ill-reference-to-help-me-make-this-decision-the-first-is-this-quote-from-the-microsoft-support-pages-microsoft-internet-explorer-has-a-maximum-uniform-resource-locator-url-length-of-2083-characters-internet-explorer-also-has-a-maximum-path-length-of-2048-characters-this-limit-applies-to-both-post-request-and-get-request-urls-the-second-source-ill-cite-is-the-http-11-protocol-which-says-the-http-protocol-does-not-place-any-a-priori-limit-on-the-length-of-a-uri-servers-must-be-able-to-handle-the-uri-of-any-resource-they-serve-and-should-be-able-to-handle-uris-of-unbounded-length-if-they-provide-get-based-forms-that-could-generate-such-uris-a-server-should-return-414-request-uri-too-long-status-if-a-uri-is-longer.html', '2018-03-18 22:01:00', 'CSDN', 'https://blog.csdn.net/woxueliuyun/article/details/41866611'),
(110, 'URL特殊字符的转义', 'sunyujia', 'http', '特殊符号 十六进制值\r\n\r\n+ 转义符为 %2B\r\n\r\n空格 转义符为 + 或 %20\r\n\r\n/ 转义符为 %2F\r\n\r\n? 转义符为 %3F\r\n\r\n% 转义符为 %25\r\n\r\n# 转义符为 %23\r\n\r\n&amp; 转义符为 %26\r\n\r\n= 转义符为 %3D', '2018-03-18 22:30:00', 'CSDN', 'https://blog.csdn.net/sunyujia/article/details/2205364'),
(111, '几行代码轻松实现PHP文件打包下载zip', '吕滔', 'PHP', '<blickquote>这篇文章主要为大家详细介绍了使用PHP自带zlib函数 ，轻松实现PHP文件打包下载zip，具有一定的参考价值，感兴趣的小伙伴们可以参考一下</blockquote>\r\n本文实例为大家分享了PHP文件打包下载zip的具体代码，供大家参考，具体内容如下<pre><code><?php\r\n//获取文件列表\r\nfunction list_dir($dir){\r\n   $result = array();\r\n   if (is_dir($dir)){\r\n   $file_dir = scandir($dir);\r\n   foreach($file_dir as $file){\r\n    if ($file == \'.\' || $file == \'..\'){\r\n    continue;\r\n    }\r\n    elseif (is_dir($dir.$file)){\r\n    $result = array_merge($result, list_dir($dir.$file.\'/\'));\r\n    }\r\n    else{\r\n    array_push($result, $dir.$file);\r\n    }\r\n   }\r\n   }\r\n   return $result;\r\n  }\r\n\r\n//获取列表 \r\n$datalist=list_dir(\'../\');\r\n$filename = \"./bak.zip\"; //最终生成的文件名（含路径）  \r\nif(!file_exists($filename)){  \r\n//重新生成文件  \r\n  $zip = new ZipArchive();//使用本类，linux需开启zlib，windows需取消php_zip.dll前的注释  \r\n  if ($zip->open($filename, ZIPARCHIVE::CREATE)!==TRUE) {  \r\n    exit(\'无法打开文件，或者文件创建失败\');\r\n  }  \r\n  foreach( $datalist as $val){  \r\n    if(file_exists($val)){  \r\n      $zip->addFile( $val, basename($val));//第二个参数是放在压缩包中的文件名称，如果文件可能会有重复，就需要注意一下  \r\n    }  \r\n  }  \r\n  $zip->close();//关闭  \r\n}  \r\nif(!file_exists($filename)){  \r\n  exit(\"无法找到文件\"); //即使创建，仍有可能失败。。。。  \r\n}  \r\nheader(\"Cache-Control: public\"); \r\nheader(\"Content-Description: File Transfer\"); \r\nheader(\'Content-disposition: attachment; filename=\'.basename($filename)); //文件名  \r\nheader(\"Content-Type: application/zip\"); //zip格式的  \r\nheader(\"Content-Transfer-Encoding: binary\"); //告诉浏览器，这是二进制文件  \r\nheader(\'Content-Length: \'. filesize($filename)); //告诉浏览器，文件大小  \r\n@readfile($filename);\r\n?></code></pre>PHP ZipArchive是PHP自带的扩展类，可以轻松实现ZIP文件的压缩和解压，使用前首先要确保PHP ZIP扩展已经开启，具体开启方法这里就不说了，不同的平台开启PHP扩增的方法网上都有，如有疑问欢迎交流。\r\n\r\n这里整理一下利用php zipArchive进行文件的压缩与解压缩的常用的示例供参考。\r\n\r\n<strong>一、解压缩zip文件</strong><pre><code>$zip=new ZipArchive;//新建一个ZipArchive的对象\r\n if($zip->open(\'test.zip\')===TRUE){\r\n $zip->extractTo(\'images\');//假设解压缩到在当前路径下images文件夹内\r\n $zip->close();//关闭处理的zip文件\r\n}</code></pre><strong>二、将文件压缩成zip文件</strong><pre><code>$zip=new ZipArchive;\r\nif($zip->open(\'test.zip\',ZipArchive::OVERWRITE)===TRUE){\r\n $zip->addFile(\'image.txt\');//假设加入的文件名是image.txt，在当前路径下\r\n $zip->close();\r\n}</code></pre><strong>三、文件追加内容添加到zip文件</strong><pre><code>$zip=new ZipArchive;\r\n$res=$zip->open(\'test.zip\',ZipArchive::CREATE);\r\nif($res===TRUE){\r\n $zip->addFromString(\'test.txt\',\'file content goes here\');\r\n $zip->close();\r\n echo \'ok\';\r\n}else{\r\n echo \'failed\';\r\n}</code></pre><strong>四、将文件夹打包成zip文件</strong><pre><code>function addFileToZip($path,$zip){\r\n $handler=opendir($path); //打开当前文件夹由$path指定。\r\n while(($filename=readdir($handler))!==false){\r\n if($filename != \".\" && $filename != \"..\"){//文件夹文件名字为\'.\'和‘..\'，不要对他们进行操作\r\n  if(is_dir($path.\"/\".$filename)){// 如果读取的某个对象是文件夹，则递归\r\n  addFileToZip($path.\"/\".$filename, $zip);\r\n  }else{ //将文件加入zip对象\r\n  $zip->addFile($path.\"/\".$filename);\r\n  }\r\n }\r\n }\r\n @closedir($path);\r\n}\r\n$zip=new ZipArchive();\r\nif($zip->open(\'images.zip\', ZipArchive::OVERWRITE)=== TRUE){\r\n addFileToZip(\'images/\', $zip); //调用方法，对要打包的根目录进行操作，并将ZipArchive的对象传递给方法\r\n $zip->close(); //关闭处理的zip文件\r\n}</code></pre>以上就是本文的全部内容，希望对大家的学习有所帮助，也希望大家多多支持脚本之家。', '2018-03-19 13:54:00', '脚本之家', 'http://www.jb51.net/article/107165.htm'),
(112, 'php通用安装程序,php项目安装程序', 'lijia168', 'PHP', '文件目录结构\r\n<pre><code>│index.php  程序首页\r\n│  \r\n├─conf      安装后配置文件目录\r\n├─data　　　 目录写入测试目录\r\n└─install   安装程序目录\r\n│  index.php　　 安装程序主文件\r\n│  step_0.php　　安装过程模版文件\r\n│  step_1.php　　同上\r\n│  step_2.php　　同上\r\n│  step_3.php　　同上\r\n│  step_4.php　　同上\r\n│  step_5.php　　同上\r\n│  \r\n├─css　　　　　　 样式目录\r\n│      install.css\r\n│      perfect-scrollbar.min.css\r\n│      \r\n├─data          \r\n│      config.php           安装配置文件如数据库信息等\r\n│      utf8.sql　　　　　　　 创建表的SQL\r\n│      utf8_add.sql　　　　　 演示数据SQL文件,安装过程中选中演示数据时执行\r\n│      \r\n├─images\r\n│      install_bg.png  \r\n│      \r\n├─include\r\n│      function.php        主要函数,如文件夹权限检查等\r\n│      var.php　　　　　　　 配置所有检查的文件夹等\r\n│      \r\n└─js                       JS文件\r\njquery.icheck.min.js\r\njquery.js\r\njquery.mousewheel.js\r\njquery.validation.min.js\r\nperfect-scrollbar.min.js\r\n</code></pre>\r\n安装界面\r\n<img src=\"https://images2015.cnblogs.com/blog/1130751/201704/1130751-20170413151517392-1837661192.png\" alt=\"\">\r\n<img src=\"https://images2015.cnblogs.com/blog/1130751/201704/1130751-20170413151517392-1837661192.png\" alt=\"\">\r\n&nbsp;\r\n<img src=\"https://images2015.cnblogs.com/blog/1130751/201704/1130751-20170413151528064-1288297744.png\" alt=\"\">\r\n<img src=\"https://images2015.cnblogs.com/blog/1130751/201704/1130751-20170413151536314-1900876012.png\" alt=\"\">\r\n<img src=\"https://images2015.cnblogs.com/blog/1130751/201704/1130751-20170413151543720-214870419.png\" alt=\"\">\r\n<img src=\"https://images2015.cnblogs.com/blog/1130751/201704/1130751-20170413151552033-2051033273.png\" alt=\"\">\r\n&nbsp;\r\n<a href=\"http://files.cnblogs.com/files/lijia168/install.zip\" target=\"_blank\">点我下载</a>', '2018-03-19 13:55:00', '博客园', 'https://www.cnblogs.com/lijia168/p/6704079.html'),
(113, 'JavaScript生成.xls文件的代码', 'mrr', 'JS', '<blockquote>这篇文章主要介绍了JavaScript生成.xls文件的代码,非常不错，具有参考借鉴价值，需要的朋友可以参考下</blockquote>\r\n贴代码，一切尽在注释中<pre><code>&lt;html&gt;\r\n&lt;head&gt; \r\n&lt;meta charset=&quot;utf-8&quot;&gt; \r\n&lt;/head&gt; \r\n&lt;body&gt; \r\n&lt;input type=&quot;button&quot; value=&quot;下载设备模板&quot; onclick=&quot;foo;&quot; /&gt; \r\n&lt;script type=&quot;text/javascript&quot; language=&quot;javascript&quot;&gt; \r\nvar downloadTemplate = function \r\n{\r\n/** * 根据所给数据创建并返回单行 tr节点 * data (必选), tag (可选, 标识创建的节点类型) **/\r\nvar getTr=function(data,tag)\r\n{\r\nvar tr=document.createElement(&quot;tr&quot;); for(var i=0;i&lt;data.length;i++)\r\n{ \r\nvar item=document.createElement(tag||&quot;td&quot;); item.innerHTML=data[i]; tr.appendChild(item);\r\n} \r\nreturn tr;\r\n}\r\n; /** * 根据所给数据创建并返回 table节点 * data (可选,无则返回空的table节点), head(可选, 标识是否存在表头) **/\r\nvar getTable=function(data,head)\r\n{\r\nvar table=document.createElement(&quot;table&quot;);\r\nvar head=head||false; //存在表头设标识为th,否则为td\r\nvar tag=head?&quot;th&quot;:&quot;td&quot;; //判断是一维||二维,执行不同逻辑\r\nif(data[0] instanceof Array)\r\n{ \r\nfor(var i=0;i&lt;data.length;i++)\r\n{\r\n//第一行数据根据tag创建节点类型 \r\n(i==0)?table.appendChild(getTr(data[i],tag)):table.appendChild(getTr(data[i]));\r\n}\r\n}\r\nelse if(data instanceof Array)\r\ntable.appendChild(getTr(data,tag));\r\nreturn table; \r\n}\r\n; /** * table (必选, table节点) * uri 为生成excel的头部标签 * xmlns xml命名空间 * 返回xls资源 **/\r\nvar getXls=function(table)\r\n{\r\nvar uri = &#x27;data:application/vnd.ms-excel;base64,&#x27;;\r\nvar template = &#x27;&lt;html xmlns:o=&quot;urn:schemas-microsoft-com:office:office&quot; &#x27;+ &#x27;xmlns:x=&quot;urn:schemas-microsoft-com:office:excel&quot; &#x27;+ &#x27;xmlns=&quot;http://www.w3.org/TR/REC-html40&quot;&gt;&#x27;+ &#x27;&lt;head&gt;&#x27;+ &#x27;&lt;!--[if gte mso 9]&gt;&#x27;+ &#x27;&lt;xml&gt;&#x27;+ &#x27;&lt;x:ExcelWorkbook&gt;&#x27;+ &#x27;&lt;x:ExcelWorksheets&gt;&#x27;+ &#x27;&lt;x:ExcelWorksheet&gt;&#x27;+ &#x27;&lt;x:WorksheetOptions&gt;&#x27;+ &#x27;&lt;x:DisplayGridlines/&gt;&#x27;+ &#x27;&lt;/x:WorksheetOptions&gt;&#x27;+ &#x27;&lt;/x:ExcelWorksheet&gt;&#x27;+ &#x27;&lt;/x:ExcelWorksheets&gt;&#x27;+ &#x27;&lt;/x:ExcelWorkbook&gt;&#x27;+ &#x27;&lt;/xml&gt;&#x27;+ &#x27;&lt;![endif]--&gt;&#x27;+ &#x27;&lt;/head&gt;&#x27;+ &#x27;&lt;body&gt;&#x27;+ &#x27;&lt;table&gt;{table}&lt;/table&gt;&#x27;+ &#x27;&lt;/body&gt;&#x27;+ &#x27;&lt;/html&gt;&#x27;; \r\n/** * 转码 base 64 * window.btoa能从ascii/二进制流中创建一个base64编码的字符串 * escape编码 unescape 解码字符串 * encodeURIComponent编码 DecodeURIComponent 解码字符串 **/ \r\nvar base64 = function(s)\r\n{ \r\nreturn window.btoa(unescape(encodeURIComponent(s))); \r\n};\r\n//返回替换完具体数据的xls模板 var getXlsXml = function(template,data)\r\n{\r\nreturn template.replace(/{(\\w+)}/g,data);\r\n};\r\n//返回资源链接\r\nreturn uri+base64(getXlsXml(template, table.innerHTML));\r\n};\r\n/** * IE浏览器 * 使用Microsoft ActiveXObject组件生成xls ( 只兼容IE浏览器,选择允许加载组件 ) * table(必选, table节点) **/\r\nvar msDownload=function(data)\r\n{\r\nvar xls = new ActiveXObject(&quot;Excel.Application&quot;); \r\nxls.visible = true;\r\nvar xlsBook = xls.Workbooks.Add;\r\nvar xlsheet = xlsBook.Worksheets(1); \r\nfor(var i=0;i&lt;data.length;i++)\r\nif(data[0] instanceof Array) \r\nfor(var j=0;j&lt;data[0].length;j++)\r\nxlsheet.Cells(i+1,j+1).Value=data[i][j]; else xlsheet.Cells(1,i+1).Value=data[i]; //用完释放 xls=null; };\r\n//参数: data(必选,一维||二维 数组), head(可选, 标识是否存在表头)\r\nvar download=function(data , head)\r\n{ \r\nif(window.navigator.userAgent.indexOf(&quot;MSIE&quot;) &gt;= 0)\r\nmsDownload(data);\r\nelse //下载(RestFul:资源下载置于超链接,地址为资源定位地址)\r\nwindow.location.href =getXls(getTable(data,head));\r\n}; \r\nreturn \r\n{ \r\ngetXls:getXls, msDownload:msDownload, download:download\r\n};\r\n}; \r\n//测试数据 var od=[&#x27;aid&#x27;,&#x27;pwd&#x27;,&#x27;设备名称&#x27;,&#x27;网关DK&#x27;,&#x27;区域&#x27;];\r\nvar td=[ [&#x27;aid&#x27;,&#x27;pwd&#x27;,&#x27;设备名称&#x27;,&#x27;网关DK&#x27;,&#x27;区域&#x27;], [&#x27;10086&#x27;,&#x27;root&#x27;,&#x27;松下R-399&#x27;,&#x27;208564165456542&#x27;,&#x27;2 #201&#x27;], [&#x27;10001&#x27;,&#x27;root&#x27;,&#x27;索尼SUV 09&#x27;,&#x27;456542895564165&#x27;,&#x27;2 #201&#x27;] ];\r\nvar foo=function\r\n{ \r\n// new downloadTemplate.download(od,true); \r\nnew downloadTemplate.download(td,true); \r\n}\r\n; \r\n&lt;/script&gt;\r\n&lt;/body&gt; \r\n&lt;/html&gt;</code></pre>测试结果:\r\n\r\n在IE浏览器上需要允许加载ActiveX控件，之后在弹出的对话框中点击\"是\"\r\n\r\n<img src=\"http://files.jb51.net/file_images/article/201612/20161222102741659.png?20161122102755\">\r\n\r\n下载下来的表格如下:\r\n\r\n<img src=\"http://files.jb51.net/file_images/article/201612/20161222102814052.png?20161122102832\">\r\n\r\nchrome：\r\n\r\n<img src=\"http://files.jb51.net/file_images/article/201612/20161222102853257.png?2016112210293\">\r\n\r\n打开表格：\r\n\r\n<img src=\"http://files.jb51.net/file_images/article/201612/20161222102920235.png?20161122102928\">\r\n\r\n以上所述是小编给大家介绍的JavaScript生成.xls文件的代码，希望对大家有所帮助，如果大家有任何疑问请给我留言，小编会及时回复大家的。在此也非常感谢大家对脚本之家网站的支持！', '2018-03-19 16:13:00', '脚本之家', 'http://www.jb51.net/article/100835.htm'),
(114, 'JS导出excel 兼容ie、chrome、firefox', 'Jaye118', 'JS', '运用js实现将页面中的table导出为excel文件，页面显示如下：\r\n\r\n<img src=\"https://images2015.cnblogs.com/blog/932245/201612/932245-20161229163443382-338586938.png\">\r\n\r\n导出的excel文件显示如下：\r\n\r\n<img src=\"https://images2015.cnblogs.com/blog/932245/201612/932245-20161229163652476-1388630864.png\">\r\n\r\n实现代码：<pre><code>&lt;!DOCTYPE html&gt;\r\n&lt;html&gt;\r\n&lt;head&gt;\r\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\r\n    &lt;style type=&quot;text/css&quot;&gt;\r\n        table{border-collapse: collapse; }\r\n        th, td{border: 1px solid #4d4d4d;padding: 5px; }\r\n    &lt;/style&gt;\r\n    &lt;script type=&quot;text/javascript&quot; language=&quot;javascript&quot;&gt;\r\n        var idTmr;\r\n        function  getExplorer() {\r\n            var explorer = window.navigator.userAgent ;\r\n            //ie\r\n            if (explorer.indexOf(&quot;MSIE&quot;) &gt;= 0) {\r\n                return &#x27;ie&#x27;;\r\n            }\r\n            //firefox\r\n            else if (explorer.indexOf(&quot;Firefox&quot;) &gt;= 0) {\r\n                return &#x27;Firefox&#x27;;\r\n            }\r\n            //Chrome\r\n            else if(explorer.indexOf(&quot;Chrome&quot;) &gt;= 0){\r\n                return &#x27;Chrome&#x27;;\r\n            }\r\n            //Opera\r\n            else if(explorer.indexOf(&quot;Opera&quot;) &gt;= 0){\r\n                return &#x27;Opera&#x27;;\r\n            }\r\n            //Safari\r\n            else if(explorer.indexOf(&quot;Safari&quot;) &gt;= 0){\r\n                return &#x27;Safari&#x27;;\r\n            }\r\n        }\r\n        function method1(tableid) {//整个表格拷贝到EXCEL中\r\n            if(getExplorer()==&#x27;ie&#x27;) {\r\n                var curTbl = document.getElementById(tableid);\r\n                var oXL = new ActiveXObject(&quot;Excel.Application&quot;);\r\n\r\n                //创建AX对象excel\r\n                var oWB = oXL.Workbooks.Add();\r\n                //获取workbook对象\r\n                var xlsheet = oWB.Worksheets(1);\r\n                //激活当前sheet\r\n                var sel = document.body.createTextRange();\r\n                sel.moveToElementText(curTbl);\r\n                //把表格中的内容移到TextRange中\r\n                sel.select;\r\n                //全选TextRange中内容\r\n                sel.execCommand(&quot;Copy&quot;);\r\n                //复制TextRange中内容\r\n                xlsheet.Paste();\r\n                //粘贴到活动的EXCEL中\r\n                oXL.Visible = true;\r\n                //设置excel可见属性\r\n\r\n                try {\r\n                    var fname = oXL.Application.GetSaveAsFilename(&quot;Excel.xls&quot;, &quot;Excel Spreadsheets (*.xls), *.xls&quot;);\r\n                } catch (e) {\r\n                    print(&quot;Nested catch caught &quot; + e);\r\n                } finally {\r\n                    oWB.SaveAs(fname);\r\n\r\n                    oWB.Close(savechanges = false);\r\n                    //xls.visible = false;\r\n                    oXL.Quit();\r\n                    oXL = null;\r\n                    //结束excel进程，退出完成\r\n                    //window.setInterval(&quot;Cleanup();&quot;,1);\r\n                    idTmr = window.setInterval(&quot;Cleanup();&quot;, 1);\r\n                }\r\n            } else {\r\n                tableToExcel(&#x27;ta&#x27;)\r\n            }\r\n        }\r\n        function Cleanup() {\r\n            window.clearInterval(idTmr);\r\n            CollectGarbage();\r\n        }\r\n\r\n        /*\r\n            template ： 定义文档的类型，相当于html页面中顶部的&lt;!DOCTYPE&gt; 声明。（个人理解，不确定）\r\n            encodeURIComponent:解码\r\n            unescape() 函数：对通过 escape() 编码的字符串进行解码。\r\n            window.btoa(window.encodeURIComponent(str)):支持汉字进行解码。\r\n            \\w ：匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’\r\n            replace()方法：用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。\r\n            {(\\w+)}：匹配所有 {1个或更多字符} 形式的字符串；此处匹配输出内容是 “worksheet”\r\n            正则中的() ：是为了提取匹配的字符串。表达式中有几个()就有几个相应的匹配字符串。\r\n            讲解(/{(\\w+)}/g, function(m, p) { return c[p]; } ：\r\n                /{(\\w+)}/g 匹配出所有形式为“{worksheet}”的字符串；\r\n                function参数：  m  正则所匹配到的内容，即“worksheet”；\r\n                                p  正则表达式中分组的内容,即“(\\w+)”分组中匹配到的内容，为“worksheet”；\r\n                c ：为object，见下图3\r\n                c[p] : 为“worksheet”\r\n\r\n        */\r\n        var tableToExcel = (function() {\r\n            var uri = &#x27;data:application/vnd.ms-excel;base64,&#x27;,\r\n            template = &#x27;&lt;html xmlns:o=&quot;urn:schemas-microsoft-com:office:office&quot; xmlns:x=&quot;urn:schemas-microsoft-com:office:excel&quot; xmlns=&quot;http://www.w3.org/TR/REC-html40&quot;&gt;&lt;head&gt;&lt;!--[if gte mso 9]&gt;&lt;xml&gt;&lt;x:ExcelWorkbook&gt;&lt;x:ExcelWorksheets&gt;&lt;x:ExcelWorksheet&gt;&lt;x:Name&gt;{worksheet}&lt;/x:Name&gt;&lt;x:WorksheetOptions&gt;&lt;x:DisplayGridlines/&gt;&lt;/x:WorksheetOptions&gt;&lt;/x:ExcelWorksheet&gt;&lt;/x:ExcelWorksheets&gt;&lt;/x:ExcelWorkbook&gt;&lt;/xml&gt;&lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt;{table}&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,\r\n            base64 = function(s) {\r\n                return window.btoa(unescape(encodeURIComponent(s)))\r\n            },\r\n            // 下面这段函数作用是：将template中的变量替换为页面内容ctx获取到的值\r\n            format = function(s, c) {\r\n                    return s.replace(/{(\\w+)}/g,\r\n                                    function(m, p) {\r\n                                        return c[p];\r\n                                    }\r\n                    )\r\n            };\r\n            return function(table, name) {\r\n                if (!table.nodeType) {\r\n                    table = document.getElementById(table)\r\n                }\r\n                // 获取表单的名字和表单查询的内容\r\n                var ctx = {worksheet: name || &#x27;Worksheet&#x27;, table: table.innerHTML};\r\n                // format()函数：通过格式操作使任意类型的数据转换成一个字符串\r\n                // base64()：进行编码\r\n                window.location.href = uri + base64(format(template, ctx))\r\n            }\r\n        })()\r\n    &lt;/script&gt;\r\n\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;table id=&quot;ta&quot;&gt;\r\n        &lt;tr&gt;\r\n            &lt;th&gt;&lt;/th&gt;\r\n            &lt;th&gt;一&lt;/th&gt;\r\n            &lt;th&gt;二&lt;/th&gt;\r\n            &lt;th&gt;三&lt;/th&gt;\r\n            &lt;th&gt;四&lt;/th&gt;\r\n        &lt;/tr&gt;\r\n        &lt;tr&gt;\r\n            &lt;td&gt;万籁寂无声&lt;/td&gt;\r\n            &lt;td&gt;衾铁棱棱近五更&lt;/td&gt;\r\n            &lt;td&gt;香断灯昏吟未稳&lt;/td&gt;\r\n            &lt;td&gt;凄清&lt;/td&gt;\r\n            &lt;td&gt;只有霜华伴月明&lt;/td&gt;\r\n        &lt;/tr&gt;\r\n        &lt;tr&gt;\r\n            &lt;td&gt;应是夜寒凝&lt;/td&gt;\r\n            &lt;td&gt;恼得梅花睡不成&lt;/td&gt;\r\n            &lt;td&gt;我念梅花花念我&lt;/td&gt;\r\n            &lt;td&gt;关情&lt;/td&gt;\r\n            &lt;td&gt;起看清冰满玉瓶&lt;/td&gt;\r\n        &lt;/tr&gt;\r\n    &lt;/table&gt;\r\n    &lt;br/&gt;\r\n    &lt;input type=&quot;button&quot; value=&quot;导出EXCEL&quot; onclick=&quot;method1(&#x27;ta&#x27;)&quot; /&gt;\r\n&lt;/body&gt;\r\n&lt;/html&gt;</code></pre>图3：\r\n\r\n<img src=\"https://images2015.cnblogs.com/blog/932245/201612/932245-20161230095908648-1415562385.png\">\r\n\r\n　　代码事例中运用到的知识都在注释中说明，方便以后查看，尤其是正则 replace 各个参数的意义，是属于比较细的知识点。个人见解欢迎指正。', '2018-03-19 16:28:00', '博客园', 'https://www.cnblogs.com/zhangym118/p/6235801.html'),
(115, 'js导出excel文件的简洁方法', 'jingxian', 'JS', '<blockquote>下面小编就为带来一篇js导出excel文件的简洁方法(推荐)。小编觉得挺不错的，现在就分享给大家，也给大家做个参考。一起跟随小编过来看看吧</blockquote>\r\n用js可以直接在jsp页面导出数据到excel文件，方法很简洁，如下：\r\n\r\n第一，准备一个jsp（暂时取名为export.jsp），内容为:<pre><code>&lt;%@ page contentType=&quot;text/html; charset=GBK&quot;%&gt;\r\n&lt;%\r\n  String context = request.getParameter(&quot;sContent&quot;);\r\n  response.setHeader(&quot;Content-type&quot;,&quot;application/vnd.ms-xls&quot;);\r\n  response.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=export.xls&quot;);\r\n  response.setHeader(&quot;Expires&quot;,&quot;0&quot;);\r\n  response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache, must-revalidate&quot;);\r\n  response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);\r\n  out.print(context);\r\n%&gt;</code></pre>\r\n\r\n第二，写一个导出数据的jsp页面（暂时命名为test.jsp），内容如下：<pre><code>&lt;%@ page contentType=&quot;text/html; charset=GBK&quot;%&gt;\r\n&lt;% \r\n String path = request.getContextPath();\r\n%&gt;\r\n&lt;html&gt;\r\n &lt;head&gt;\r\n &lt;script type=&quot;text/javascript&quot;&gt;\r\n  function exportData(){\r\n  var html=&quot;&lt;table&gt;&lt;tr&gt;&lt;td&gt;星期一&lt;/td&gt;&lt;td&gt;星期二&lt;/td&gt;&lt;td&gt;星期三&lt;/td&gt;&lt;td&gt;星期四&lt;/td&gt;&lt;/tr&gt;&quot;;\r\n  html+=&quot;&lt;tr&gt;&lt;td&gt;monday&lt;/td&gt;&lt;td&gt;tuesday&lt;/td&gt;&lt;td&gt;wednesday&lt;/td&gt;&lt;td&gt;thursday&lt;/td&gt;&quot;;\r\n  html+=&quot;&lt;/tr&gt;&lt;/table&gt;&quot;;\r\n  document.getElementByIdx_x_x(&quot;sContent&quot;).value=html;\r\n  document.getElementByIdx_x_x(&quot;form1&quot;).submit();\r\n  }\r\n &lt;/script&gt;\r\n &lt;/head&gt;\r\n &lt;body&gt;\r\n &lt;iframe id=&quot;exeframe&quot; name=&quot;exeframe&quot; style=&quot;display:none&quot;&gt;\r\n &lt;/iframe&gt;\r\n &lt;form id=&quot;form1&quot; method=&quot;post&quot; target=&quot;exeframe&quot; action=&quot;export.jsp?ver=导出&quot;&gt;\r\n  &lt;input type=&quot;hidden&quot; id=&quot;sContent&quot; name=&quot;sContent&quot; value=&quot;&quot;/&gt;\r\n &lt;/form&gt;\r\n \r\n &lt;input type=&quot;button&quot; onclick=&quot;exportData()&quot; value=&quot;导出&quot;&gt;\r\n &lt;/body&gt;\r\n&lt;/html&gt; </code></pre>\r\n\r\nok，至此，导出功能结束。\r\n\r\n以上就是小编为大家带来的js导出excel文件的简洁方法(推荐)全部内容了，希望大家多多支持脚本之家~', '2018-03-19 16:34:00', '脚本之家', 'http://www.jb51.net/article/96287.htm'),
(116, 'Oracle中的rowid', '小强斋太', 'SQL', 'ROWID是ORACLE中的一个重要的概念。用于定位数据库中一条记录的一个相对唯一地址值。通常情况下，该值在该行数据插入到数据库表时即被确定且唯一。ROWID它是一个伪列，它并不实际存在于表中。它是ORACLE在读取表中数据行时，根据每一行数据的物理地址信息编码而成的一个伪列。所以根据一行数据的ROWID能找到一行数据的物理地址信息。从而快速地定位到数据行。数据库的大多数操作都是通过ROWID来完成的，而且使用ROWID来进行单记录定位速度是最快的。\r\n要理解索引，必须先搞清楚ROWID。\r\n<strong>B-Tree索引</strong>的每个索引条目具有两个字段。第一个字段表示索引的键值，对于单列索引来说是一个值；而对于多列索引来说则是多个值组合在一起的。第二个字段表示键值所对应的记录行的ROWID。所以索引能加快查询速度！\r\n<strong>索引值&rarr;ROWID-&gt;将ROWID换算成一行数据的物理地址-&gt;得到一行数据</strong>\r\n<h3>一、ROWID的格式：</h3>\r\n<img src=\"https://images0.cnblogs.com/blog/733883/201504/230157371561018.png\">\r\n          https://images0.cnblogs.com/blog/733883/201504/230157371561018.png\r\n第一部分6位表示：该行数据所在的数据对象的 <strong>data_object_id</strong>； <br />第二部分3位表示：该行数据所在的相对数据文件的id;     <br />第三部分6位表示：该数据行所在的数据块的编号；     <br />第四部分3位表示：该行数据的行的编号；\r\n<blockquote>\r\n索引就是保存了rowid后三个部分的信息。索引是物理存在的，而rowid是伪列。所以索引可以用来快速地定位到数据行。</blockquote>\r\n<h4>data_object_id </h4>\r\n下面以SAKILA数据库的ACTOR表为例\r\n这里我们要注意将 <strong>data_object_id&nbsp; </strong>与 <strong>object_id </strong>区分开来，前者是oracle为它的每一个对象唯一分配的id,而后者与表ACTOR对应的&ldquo;段&rdquo;有关，是存放表tt的段的id，也就是与存放表tt中数据的物理位置有关：\r\n<pre><code>select owner,object_id,data_object_id,status from dba_objects where object_name=\'ACTOR\';</code></pre>\r\n<img src=\"https://images0.cnblogs.com/blog/733883/201504/230157395006102.png\">\r\n<pre><code>alter table ACTOR move tablespace users;\r\n\r\nselect owner,object_id,data_object_id,status from dba_objects where object_name=\'ACTOR\';</code></pre>\r\n我们看到当表ACTOR move到了users表空间时，段发生了改变，物理位置发生了变化，从而 <strong>DATA_OBJECT_ID </strong>也发生了变化。我们知道表是存放在&ldquo;表段&rdquo;中的，索引是存放在&ldquo;索引段&rdquo;中的。<strong>DATA_OBJECT_ID</strong>就是表示存放数据的&ldquo;数据段对象的id&rdquo;\r\n<h4>相对文件编码</h4>\r\n关于相对文件编码和绝对文件编号：相对文件id是指相对于表空间，在表空间唯一，绝对文件是指相当于全局数据库而言的，全局唯一；\r\n<pre><code>select file_name,file_id,relative_fno from dba_data_files;</code></pre>\r\n<img src=\"https://images0.cnblogs.com/blog/733883/201504/230157412186544.png\">\r\n<h4>rowid采用64进制来编码</h4>\r\n编码方法是：A~Z表示0到25；a~z表示26到51；0~9表示52到61；+表示62；/表示63；刚好64个字符。\r\n<h2>Base64编码表</h2>\r\n<table border=\"1\">\r\n<tbody>\r\n<tr><th>码值</th><th>字符</th>\r\n<td rowspan=\"17\">&nbsp;</td>\r\n<th>码值</th><th>字符</th>\r\n<td rowspan=\"17\">&nbsp;</td>\r\n<th>码值</th><th>字符</th>\r\n<td rowspan=\"17\">&nbsp;</td>\r\n<th>码值</th><th>字符</th></tr>\r\n<tr>\r\n<td>0</td>\r\n<td>A</td>\r\n<td>16</td>\r\n<td>Q</td>\r\n<td>32</td>\r\n<td>g</td>\r\n<td>48</td>\r\n<td>w</td>\r\n</tr>\r\n<tr>\r\n<td>1</td>\r\n<td>B</td>\r\n<td>17</td>\r\n<td>R</td>\r\n<td>33</td>\r\n<td>h</td>\r\n<td>49</td>\r\n<td>x</td>\r\n</tr>\r\n<tr>\r\n<td>2</td>\r\n<td>C</td>\r\n<td>18</td>\r\n<td>S</td>\r\n<td>34</td>\r\n<td>i</td>\r\n<td>50</td>\r\n<td>y</td>\r\n</tr>\r\n<tr>\r\n<td>3</td>\r\n<td>D</td>\r\n<td>19</td>\r\n<td>T</td>\r\n<td>35</td>\r\n<td>j</td>\r\n<td>51</td>\r\n<td>z</td>\r\n</tr>\r\n<tr>\r\n<td>4</td>\r\n<td>E</td>\r\n<td>20</td>\r\n<td>U</td>\r\n<td>36</td>\r\n<td>k</td>\r\n<td>52</td>\r\n<td>0</td>\r\n</tr>\r\n<tr>\r\n<td>5</td>\r\n<td>F</td>\r\n<td>21</td>\r\n<td>V</td>\r\n<td>37</td>\r\n<td>l</td>\r\n<td>53</td>\r\n<td>1</td>\r\n</tr>\r\n<tr>\r\n<td>6</td>\r\n<td>G</td>\r\n<td>22</td>\r\n<td>W</td>\r\n<td>38</td>\r\n<td>m</td>\r\n<td>54</td>\r\n<td>2</td>\r\n</tr>\r\n<tr>\r\n<td>7</td>\r\n<td>H</td>\r\n<td>23</td>\r\n<td>X</td>\r\n<td>39</td>\r\n<td>n</td>\r\n<td>55</td>\r\n<td>3</td>\r\n</tr>\r\n<tr>\r\n<td>8</td>\r\n<td>I</td>\r\n<td>24</td>\r\n<td>Y</td>\r\n<td>40</td>\r\n<td>o</td>\r\n<td>56</td>\r\n<td>4</td>\r\n</tr>\r\n<tr>\r\n<td>9</td>\r\n<td>J</td>\r\n<td>25</td>\r\n<td>Z</td>\r\n<td>41</td>\r\n<td>p</td>\r\n<td>57</td>\r\n<td>5</td>\r\n</tr>\r\n<tr>\r\n<td>10</td>\r\n<td>K</td>\r\n<td>26</td>\r\n<td>a</td>\r\n<td>42</td>\r\n<td>q</td>\r\n<td>58</td>\r\n<td>6</td>\r\n</tr>\r\n<tr>\r\n<td>11</td>\r\n<td>L</td>\r\n<td>27</td>\r\n<td>b</td>\r\n<td>43</td>\r\n<td>r</td>\r\n<td>59</td>\r\n<td>7</td>\r\n</tr>\r\n<tr>\r\n<td>12</td>\r\n<td>M</td>\r\n<td>28</td>\r\n<td>c</td>\r\n<td>44</td>\r\n<td>s</td>\r\n<td>60</td>\r\n<td>8</td>\r\n</tr>\r\n<tr>\r\n<td>13</td>\r\n<td>N</td>\r\n<td>29</td>\r\n<td>d</td>\r\n<td>45</td>\r\n<td>t</td>\r\n<td>61</td>\r\n<td>9</td>\r\n</tr>\r\n<tr>\r\n<td>14</td>\r\n<td>O</td>\r\n<td>30</td>\r\n<td>e</td>\r\n<td>46</td>\r\n<td>u</td>\r\n<td>62</td>\r\n<td>+</td>\r\n</tr>\r\n<tr>\r\n<td>15</td>\r\n<td>P</td>\r\n<td>31</td>\r\n<td>f</td>\r\n<td>47</td>\r\n<td>v</td>\r\n<td>63</td>\r\n<td>/</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3>二、使用rowid访问数据的执行计划</h3>\r\n<pre><code>SELECT t.*, \'\'||t.ROWID FROM \"SAKILA\".\"ACTOR\" t;</code></pre>\r\n<img src=\"https://images0.cnblogs.com/blog/733883/201504/230233256712335.png\">\r\n<pre><code>EXPLAIN PLAN FOR                                                                                         \r\nselect * FROM ACTOR where rowid=\'AAAYEVAAJAAAACrAAA\';  \r\nselect * from table(DBMS_XPLAN.DISPLAY)</code></pre>\r\n<img src=\"https://images0.cnblogs.com/blog/733883/201504/230233278438704.png\">\r\n<h3>三、例子：如何从rowid计算得到obj#,rfile#,block#,row#</h3>\r\n我们演示一下具体的计算方法：\r\n<pre><code>SELECT t.*, \'\'||t.ROWID FROM \"SAKILA\".\"ACTOR\" t;</code></pre>\r\n<img src=\"https://images0.cnblogs.com/blog/733883/201504/230157445463227.png\">\r\n表sakila的 data_object_id 为 AAAYEVAAJAAAACrAAA的前6位：AAAYEV，那么我们来计算一下 AAAYEV的值到底是多少：\r\n\r\n查询Base64编码表\r\n<table border=\"1\">\r\n<tbody>\r\n<tr>\r\n<td>码值</td>\r\n<td>字符</td>\r\n</tr>\r\n<tr>\r\n<td>0</td>\r\n<td>A</td>\r\n</tr>\r\n<tr>\r\n<td>24</td>\r\n<td>Y</td>\r\n</tr>\r\n<tr>\r\n<td>4</td>\r\n<td>E</td>\r\n</tr>\r\n<tr>\r\n<td>21</td>\r\n<td>V</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\nselect 24 * 64 * 64 + 4 * 64 + 21 from dual;\r\n<strong>AAAYEV=</strong>24 * 64 * 64 + 4 * 64 + 21=98581\r\n然后我们查询字典表，看两种方法得到的值是否相等：\r\n<pre><code>select owner,object_id,data_object_id,status from dba_objects where object_name=\'ACTOR\';</code></pre>\r\n<img src=\"https://images0.cnblogs.com/blog/733883/201504/230157455788811.png\">\r\n我们看到通过rowid计算得到的data_object_id和通过字典表查到的值相等！\r\n表ACTOR的相对文件编号为 <strong>AAAYEVAAJAAAACrAAA </strong>的中的 <strong>AAJ</strong>，显然查表可知 AAJ= 9；\r\n我们在再来查询字典表：\r\n<img src=\"https://images0.cnblogs.com/blog/733883/201504/230157472652795.png\">\r\n可以看到字典表显示relative_fno为9的数据文件为C:\\APP\\ORACLE\\ORADATA\\ORCL\\PDBORCL\\SAMPLE_SCHEMA_USERS01.DBF\r\n查询当前数据库中的users表空间和对应的数据文件\r\n<pre><code>select file_name,tablespace_name from dba_data_files;</code></pre>\r\n<img src=\"https://images0.cnblogs.com/blog/733883/201504/230157472652795.png\">\r\n两者结果一致。\r\n而我们前面执行过：alter table ACTOR move tablespace users;所以两种方式得到的结果是一致的。\r\n表ACTOR中的第一行数据存放的block的编号为 <strong>AAAYEVAAJAAAACrAAA </strong>中的 AAAACr，而AAAACr = 2*64+43=171 <br />表ACTOR中的第一行数据存放的行的编号为<strong>AAAYEVAAJAAAACrAAA </strong>中的 AAA，显然值为0，即第一行。\r\n我们也可以通过Oracle提供的存储过程来计算出上面的值：\r\n<pre><code>SELECT\r\n\r\ndbms_rowid.rowid_object (ROWID) data_object_id,\r\n\r\ndbms_rowid.rowid_relative_fno (ROWID) relative_fno,\r\n\r\ndbms_rowid.rowid_block_number (ROWID) block_no,\r\n\r\ndbms_rowid.rowid_row_number (ROWID) row_no\r\n\r\nFROM\r\n\r\nACTOR;</code></pre>\r\n<img src=\"https://images0.cnblogs.com/blog/733883/201504/230157499535308.png\">\r\n显然这个结果和我们手动计算的结果是一致的。\r\n', '2018-03-20 16:04:00', '博客园', 'https://www.cnblogs.com/xqzt/p/4449184.html'),
(117, 'PHP页面跳转操作实例分析(header方法)', 'ligbee', 'PHP', '<blockquote>这篇文章主要介绍了PHP页面跳转操作,结合实例形式对比分析了HTML跳转与php使用header方法跳转的相关操作技巧与注意事项,并给出了一个跳转的封装函数供大家参考,需要的朋友可以参考下</blockquote>本文实例分析了PHP页面跳转操作。分享给大家供大家参考，具体如下：\r\n\r\n跳转\r\n\r\nheader()为php函数，向浏览器发送指定命令\r\n\r\nHTML<pre><code>&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;3;url=other.php&quot;/&gt;</code></pre>立刻跳转：<pre><code>header(\'Location:other.php\');\r\n//file_put_contents(\'bee.txt\',\'execute\');\r\ndie;</code></pre>执行header时候，并不是立即结束，而是会把页面执行完毕；在header前面不能有任何输出，若有开启输出缓冲则不提示错误，php.ini->output_buffering = 4096|OFF\r\n\r\n提示跳转：<pre><code>header(\'Refresh:3,Url=other.php\');\r\necho \'3s 后跳转\';\r\n//由于只是普通页面展示，提示的样式容易定制\r\ndie;</code></pre>封装的跳转函数：<pre><code>/*\r\n *跳转\r\n *@param $url 目标地址\r\n *@param $info 提示信息\r\n *@param $sec 等待时间\r\n *return void\r\n*/\r\nfunction jump($url,$info=null,$sec=3)\r\n{\r\n if(is_null($info)){\r\n  header(&quot;Location:$url&quot;);\r\n }else{\r\n  // header(&quot;Refersh:$sec;URL=$url&quot;);\r\n  echo&quot;&lt;meta http-equiv=\\&quot;refresh\\&quot; content=&quot;.$sec.&quot;;URL=&quot;.$url.&quot;&gt;&quot;;\r\n  echo $info;\r\n }\r\n die;\r\n}</code></pre>', '2018-03-20 21:09:00', '脚本之家', 'http://www.jb51.net/article/93683.htm'),
(118, 'java中Action层、Service层和Dao层的功能区分', '王YMsir', 'JAVA', 'Action/Service/DAO简介：\r\nAction是管理业务（Service）调度和管理跳转的。\r\nService是管理具体的功能的。\r\nAction只负责管理，而Service负责实施。\r\nDAO只完成增删改查，虽然可以1-n，n-n，1-1关联，模糊、动态、子查询都可以。但是无论多么复杂的查询，dao只是封装增删改查。至于增删查改如何去实现一个功能，dao是不管的。\r\n总结这三者，通过例子来解释：\r\nAction像是服务员，顾客点什么菜，菜上给几号桌，都是ta的职责；\r\nService是厨师，action送来的菜单上的菜全是ta做的；\r\nDao是厨房的小工，和原材料打交道的事情全是ta管。\r\n相互关系是，小工(dao)的工作是要满足厨师(service)的要求，厨师要满足服务员(action)转达的客户（页面用户）的要求，服务员自然就是为客户服务喽。\r\n现在最基本的分层方式，结合了SSH架构。Model层就是对应的数据库表的实体类。Dao层是使用了hibernate连接数据库、操作数据库（增删改查）。Service层：引用对应的Dao数据库操作。Action层：引用对应的Service层，在这里结合Struts的配置文件，跳转到指定的页面，当然也能接受页面传递的请求数据，也可以做些计算处理。\r\n以上的Hibernate, Struts，都需要注入到spring的配置文件中，Spring把这些联系起来，成为一个整体。\r\n三大框架Struts/Hibernate/Spring\r\n简单地说：\r\nStruts——控制用的；\r\nHibernate——操作数据库的；\r\nSpring——解耦用的。\r\n详细地说：\r\nStruts在SSH框架中起控制的作用，其核心是Controller，即ActionServlet，而ActionServlet的核心就是Struts-config.xml，主要控制逻辑关系的处理。\r\nHibernate是数据持久化层，是一种新的对象、关系的映射工具，提供了从Java类到数据表的映射，也提供了数据查询和恢复等机制，大大减少数据访问的复杂度。把对数据库的直接操作，转换为对持久对象的操作。\r\nSpring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。面向接口的编程，由容器控制程序之间的依赖关系，而非传统实现中，由程序代码直接操控。这就是所谓“控制反转”的概念所在：（依赖）控制权由应用代码中转到了外部容器，控制权的转移，是所谓反转。依赖注入，即组件之间的依赖关系由容器在运行期决定，形象地说，即由容器动态地将某种依赖关系注入到组件之中，起到的主要作用是解耦。\r\nStruts、Spring、Hibernate在各层的作用：\r\n（1）Struts负责Web层：ActionFormBean接收网页中表单提交的数据，然后通过Action进行处理，再Forward到对应的网页。在Struts-config.xml中定义，ActionServlet会加载。\r\n（2） Spring负责业务层管理，即Service（或Manager）。\r\nService为action提供统计的调用接口，封装持久层的DAO；\r\n可以写一些自己的业务方法；\r\n统一的Javabean管理方法；\r\n声明式事务管理；\r\n集成Hibernate。\r\n（3）Hibernate，负责持久化层，完成对数据库的crud操作。提供OR/Mapping。它由一组.hbm.xml文件和POJO，是跟数据库中的表相对应的。然后定义DAO，这些是跟数据库打交道的类，它们会使用PO。\r\n框架业务逻辑分析：\r\n在Struts + Spring + Hibernate的系统中，\r\n对象的调用流程是：JSP—Action—Service—DAO—Hibernate。\r\n数据的流向是：ActionFormBean接受用户的数据，Action将数据从ActionFormBean中取出，封装成VO或PO，再调用业务层的Bean类，完成各种业务处理后再Forward。而业务层Bean收到这个PO对象之后，会调用DAO接口方法，进行持久化操作。\r\nSSH框架的优点:Hibernate的最大好处就是根据数据库的表，反向生成实体\r\n类，并且还有关系在里面，还有就是它对数据的操作也很方便,Spring省去了在类里面new对象的过程，把这个调用与被调用的关系直接展示到了配置文件里，\r\n做任何操作都变得简单了。\r\n简单流程举例说明:程序框架搭建好，并且把各种jar包导入后，就开始进行业务逻辑分析——假设一个最基本的注册功能：页面有两个文本框，一个用户名(username)和一个密码(password)。以QQ注册网页说明，这里以昵称和密码为代表进行 举例。\r\n首先是action层：它是负责在页面和程序之间传输数据的，还有作用是做页面跳转。页面由用户填写表单数据，点击提交按钮，页面的表单数据由Hibernate自动封装到该页面表单所对应的ActionFrom（ActionFrom跟实体类不是一个东西，ActionFrom是页面有什么值，类里就写什么属性，是用来封装表单数据用的；而实体类是完全按照数据库的字段生成的，实体类可以当做ActionFrom用，但ActionFrom绝对不可以当做实体类用），这样表单数据就以ActionFrom对象的形式在Action的点击“提交按钮”执行的那个方法里存在了。这个时候需要做的就是把表单数据存入数据库中。此时，Action的功能告一段落，接着是把数据传入BIZ层。 BIZE层（业务逻辑层）：负责的是对数据的处理。如果没有数据处理任务的话，此层只做单纯的数据传递作用，而后又到了DAO层。\r\nDAO层（数据库操作层）：负责对数据向数据库增删改查的操作.在该注册的框架中，如果不使用Spring的话，每个层之间的数据传递都需要new一个调用该层数据的类的实例。而使用了Spring的话，需要做的就是把DAO层和BIZ层的每个类都写一个接口类，接口类里写实现类的方法，在调用的时候不new对象，直接用对象点(.)方法就可以，别忘了对每个对象加上set/get方法。', '2018-03-21 10:14:00', '博客园', 'https://www.cnblogs.com/wym789/p/6393857.html');
INSERT INTO `wu_blog` (`id`, `post_title`, `post_author`, `post_type`, `post_content`, `post_date`, `post_from`, `post_link`) VALUES
(119, 'JQery icheck 插件', '哦先生', 'JS', '<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\r\n$(document).ready(function(){\r\nvar callbacks_list = $(&#x27;.demo-callbacks&#x27;);\r\n$(&#x27;.demo-list input&#x27;).on(&#x27;ifCreated ifClicked ifChanged ifChecked ifUnchecked ifDisabled ifEnabled ifDestroyed&#x27;, function(event){\r\n}).iCheck({\r\ncheckboxClass: &#x27;icheckbox_square-blue&#x27;,\r\nradioClass: &#x27;iradio_square-blue&#x27;,\r\nincreaseArea: &#x27;20%&#x27;,\r\n});\r\n});\r\n&lt;/script&gt;\r\n&lt;div class=&quot;col-sm-3 col-md-offset-5 demo-list&quot;&gt;\r\n&lt;form class=&quot;form-horizontal&quot;&gt;\r\n&lt;div class=&quot;form-group&quot;&gt;\r\n&lt;label&gt;&lt;input type=&quot;radio&quot; class=&quot;form-control&quot; &gt;迟到扣款除于当月全勤人数&lt;/label&gt;\r\n&lt;/div&gt;\r\n&lt;div class=&quot;form-group&quot;&gt;\r\n&lt;label&gt;&lt;input type=&quot;radio&quot; class=&quot;form-control&quot; &gt;固定&lt;/label&gt;&lt;input type=&quot;text&quot; class=&quot;form-control xztable_select_s margin5&quot; &gt;/人/月\r\n&lt;/div&gt;\r\n&lt;/form&gt;\r\n&lt;/div&gt;</code></pre>加载icheck.js<pre><code>&lt;?php\r\n/**\r\n * Created by PhpStorm.\r\n * User: Administrator\r\n * Date: 2016/1/18\r\n * Time: 16:27\r\n */\r\nuse yii\\web\\View;\r\nuse yii\\helpers\\Url;\r\nuse app\\assets\\AppAsset;\r\nuse yii\\helpers\\Html;\r\n\r\nAppAsset::addScript($this, &#x27;@web/assets/Public/static/icheck/custom.min.js&#x27;);\r\nAppAsset::addScript($this, &#x27;@web/assets/Public/static/icheck/icheck.js&#x27;);\r\n?&gt;</code></pre>如上所示 ，实际项目中用到的例子。\r\n\r\n首先引入jQuery v1.7+ (或 Zepto)，然后引入jquery.icheck.js (或者zepto.icheck.js) 。\r\n\r\niCheck支持所有选择器（selectors），并且只针对复选框和单选按钮起作用<pre><code>&lt;script src=&quot;../Public/static/icheck/icheck.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;\r\n&lt;script src=&quot;../Public/static/icheck/custom.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code></pre>回调事件\r\niCheck提供了大量回调事件，都可以用来监听change事件。如上面的例子中，绑定了所有事件<table>\r\n<thead>\r\n<tr><th>事件名称</th>\r\n<td>使用时机</td>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr><th>ifClicked</th>\r\n<td>用户点击了自定义的输入框或与其相关联的label</td>\r\n</tr>\r\n<tr><th>ifChanged</th>\r\n<td>输入框的 checked 或 disabled 状态改变了</span></span></td>\r\n</tr>\r\n<tr><th>ifChecked</th>\r\n<td>输入框的状态变为 checked</span></td>\r\n</tr>\r\n<tr><th>ifUnchecked</th>\r\n<td>checked 状态被移除</span></td>\r\n</tr>\r\n<tr><th>ifDisabled</th>\r\n<td>输入框状态变为 disabled</span></td>\r\n</tr>\r\n<tr><th>ifEnabled</th>\r\n<td>disabled 状态被移除</span></td>\r\n</tr>\r\n<tr><th>ifCreated</th>\r\n<td>输入框被应用了iCheck样式</td>\r\n</tr>\r\n<tr><th>ifDestroyed</th>\r\n<td>iCheck样式被移除</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n使用on()方法绑定事件：<pre><code>$(&#x27;input&#x27;).on(&#x27;ifChecked&#x27;, function(event){\r\n  alert(event.type + &#x27; callback&#x27;);\r\n});</code></pre>方法\r\n下面这些方法可以用来通过编程方式改变输入框状态（可以使用任何选择器）：<pre><code>$(&#x27;input&#x27;).iCheck(&#x27;check&#x27;); — 将输入框的状态设置为checked\r\n\r\n$(&#x27;input&#x27;).iCheck(&#x27;uncheck&#x27;); — 移除 checked 状态\r\n\r\n$(&#x27;input&#x27;).iCheck(&#x27;toggle&#x27;); — toggle checked state\r\n\r\n$(&#x27;input&#x27;).iCheck(&#x27;disable&#x27;); — 将输入框的状态设置为 disabled\r\n\r\n$(&#x27;input&#x27;).iCheck(&#x27;enable&#x27;); — 移除 disabled 状态\r\n\r\n$(&#x27;input&#x27;).iCheck(&#x27;update&#x27;); — apply input changes, which were done outside the plugin\r\n\r\n$(&#x27;input&#x27;).iCheck(&#x27;destroy&#x27;); — 移除iCheck样式\r\n</code></pre>使用方法：\r\n\r\n1、选择你要使用的皮肤样式主题，共6个\r\n\r\nflat, futurico, line, minimal, polaris, square\r\n\r\n每个皮肤底下有好几个可以选择的颜色，例如：\r\n\r\nBlack — square.css\r\n\r\nRed — red.css\r\n\r\nGreen — green.css\r\n\r\nBlue — blue.css\r\n\r\nAero — aero.css\r\n\r\nGrey — grey.css\r\n\r\nOrange — orange.css\r\n\r\nYellow — yellow.css\r\n\r\nPink — pink.css\r\n\r\nPurple — purple.css\r\n\r\n2 例如选择square皮肤下的blue.css,复制 skin/square文件夹下的到css文件夹下<pre><code>&lt;link href=&quot;css/square/blue.css&quot; rel=&quot;stylesheet&quot;&gt;</code></pre>3 引入icheck.js\r\n\r\n移动端引入：<pre><code>&lt;script src=&quot;js/zepto.js&quot;&gt;&lt;/script&gt;\r\n\r\n&lt;script src=&quot;js/icheck.min.js&quot;&gt;&lt;/script&gt;\r\n</code></pre>PC端引入<pre><code>\r\n&lt;script src=&quot;js/jquery.js&quot;&gt;&lt;/script&gt;\r\n\r\n&lt;script src=&quot;js/icheck.min.js&quot;&gt;&lt;/script&gt;</code></pre>4 在页面添加以下代码\r\n\r\nHTML：<pre><code>&lt;input type=&quot;checkbox&quot;&gt;\r\n\r\n&lt;input type=&quot;checkbox&quot; checked&gt;\r\n\r\n&lt;input type=&quot;radio&quot; name=&quot;iCheck&quot;&gt;\r\n\r\n&lt;input type=&quot;radio&quot; name=&quot;iCheck&quot; checked&gt;\r\n</code></pre>JavaScript：<pre><code>\r\n&lt;script&gt;\r\n\r\n$(document).ready(function(){\r\n\r\n $(&#x27;input&#x27;).iCheck({\r\n\r\n   checkboxClass: &#x27;icheckbox_square-blue&#x27;,  // 注意square和blue的对应关系\r\n\r\n   radioClass: &#x27;iradio_square-blue&#x27;,\r\n\r\n   increaseArea: &#x27;20%&#x27; // optional\r\n\r\n });\r\n\r\n});\r\n\r\n&lt;/script&gt;</code></pre>iCheck提供了大量回调事件，都可以用来监听change事件。', '2018-03-21 19:02:00', '博客园', 'https://www.cnblogs.com/xp796/p/5508145.html'),
(120, 'SQL语句增加字段、修改字段、修改类型、修改默认值', '没得不安逸', 'SQL', '<pre><code>--一、修改字段默认值\r\n\r\nalter table 表名 drop constraint 约束名字   ------说明：删除表的字段的原有约束\r\n\r\nalter table 表名 add constraint 约束名字 DEFAULT 默认值 for 字段名称 -------说明：添加一个表的字段的约束并指定默认值\r\n\r\n--二、修改字段名：\r\n\r\nalter table 表名 rename column A to B\r\n\r\n--三、修改字段类型：\r\n\r\nalter table 表名 alter column UnitPrice decimal(18, 4) not null \r\n\r\n--四、修改增加字段：\r\n\r\nalter table 表名 ADD 字段 类型 NOT NULL Default 0</code></pre>', '2018-03-22 08:43:00', '博客园', 'https://www.cnblogs.com/huangyoum/p/6625213.html'),
(121, 'svn 下，通过TortoiseSVN修改文件夹名、文件名', '星晴', 'baike', '对于已经受svn源代码管理的文件或者文件夹，若想修改名字，可以这样操作：\r\n1.选中文件或者文件夹》右键》TortoiseSVN》改名。\r\n2.SVN 提交。\r\n\r\n注：\r\n1.直接修改文件名是不可以的。因为在本地修改了文件名后，提交时，服务器是不知道你修改了哪个文件，只知道你提交了一个新的文件名。', '2018-03-22 16:43:00', '博客园', 'https://www.cnblogs.com/qilei/archive/2010/09/03/1817212.html'),
(122, '$.ajax()常用方法详解', '前端小角色一枚', 'JS', '<blockquote>AJAX 是一种与服务器交换数据的技术，可以在补充在整个页面的情况下更新网页的一部分。接下来通过本文给大家介绍ajax一些常用方法，非常不错，具有参考借鉴价值，感兴趣的朋友一起学习吧</blockquote>AJAX 是一种与服务器交换数据的技术，可以在补充在整个页面的情况下更新网页的一部分。接下来通过本文给大家介绍ajax一些常用方法，大家有需要可以一起学习。\r\n<span style=\"color: #ff0000\"><strong>1.url: </strong></span>\r\n\r\n要求为String类型的参数，（默认为当前页地址）发送请求的地址。\r\n\r\n<span style=\"color: #ff0000\"><strong>2.type: \r\n</strong></span>\r\n要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。\r\n\r\n<span style=\"color: #ff0000\"><strong>3.timeout: \r\n</strong></span>\r\n要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。\r\n\r\n<span style=\"color: #ff0000\"><strong>4.async: </strong></span>\r\n\r\n要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。\r\n\r\n<span style=\"color: #ff0000\"><strong>5.cache: </strong></span>\r\n\r\n要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。\r\n\r\n<span style=\"color: #ff0000\"><strong>6.data: </strong></span>\r\n\r\n要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看　　processData选项。对象必须为key/value格式，例如{foo1:\"bar1\",foo2:\"bar2\"}转换为&foo1=bar1&foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[\"bar1\",\"bar2\"]}转换为&foo=bar1&foo=bar2。\r\n\r\n<span style=\"color: #ff0000\"><strong>7.dataType: \r\n</strong></span>\r\n要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：\r\n\r\nxml：返回XML文档，可用JQuery处理。\r\n\r\nhtml：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。\r\n\r\nscript：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。\r\n\r\njson：返回JSON数据。\r\n\r\njsonp：JSONP格式。使用SONP形式调用函数时，例如myurl&#63;callback=&#63;，JQuery将自动替换后一个“&#63;”为正确的函数名，以执行回调函数。\r\n\r\ntext：返回纯文本字符串。\r\n\r\n<span style=\"color: #ff0000\"><strong>8.beforeSend：</strong></span>\r\n\r\n要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。\r\n\r\n<pre><code>\r\nfunction(XMLHttpRequest){\r\nthis; //调用本次ajax请求时传递的options参数\r\n}</code></pre>\r\n<span style=\"color: #ff0000\"><strong>9.complete：\r\n</strong></span>\r\n要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。\r\n\r\n<pre><code>\r\nfunction(XMLHttpRequest, textStatus){\r\nthis; //调用本次ajax请求时传递的options参数\r\n}</code></pre>\r\n<span style=\"color: #ff0000\"><strong>10.success：\r\n</strong></span>\r\n要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。\r\n\r\n(1)由服务器返回，并根据dataType参数进行处理后的数据。\r\n\r\n(2)描述状态的字符串。\r\n\r\n<pre><code>\r\nfunction(data, textStatus){\r\n//data可能是xmlDoc、jsonObj、html、text等等\r\nthis; //调用本次ajax请求时传递的options参数\r\n}</code></pre>\r\n<span style=\"color: #ff0000\"><strong>11.error:</strong></span>\r\n\r\n要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下：\r\n\r\n<pre><code>\r\nfunction(XMLHttpRequest, textStatus, errorThrown){\r\n//通常情况下textStatus和errorThrown只有其中一个包含信息\r\nthis; //调用本次ajax请求时传递的options参数\r\n}</code></pre>\r\n<span style=\"color: #ff0000\"><strong>12.contentType：\r\n</strong></span>\r\n要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为\"application/x-www-form-urlencoded\"。该默认值适合大多数应用场合。\r\n\r\n<span style=\"color: #ff0000\"><strong>13.dataFilter：</strong></span>\r\n\r\n要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。\r\n\r\n<pre><code>\r\nfunction(data, type){\r\n//返回处理后的数据\r\nreturn data;\r\n}</code></pre>\r\n<span style=\"color: #ff0000\"><strong>14.dataFilter：</strong></span>\r\n\r\n要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理。\r\n\r\n<pre><code>\r\nfunction(data, type){\r\n//返回处理后的数据\r\nreturn data;\r\n}</code></pre>\r\n<span style=\"color: #ff0000\"><strong>15.global：</strong></span>\r\n\r\n要求为Boolean类型的参数，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件。\r\n\r\n<span style=\"color: #ff0000\"><strong>16.ifModified：</strong></span>\r\n\r\n要求为Boolean类型的参数，默认为false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是Last-Modified头信息。默认值是false，即忽略头信息。\r\n\r\n<span style=\"color: #ff0000\"><strong>17.jsonp：\r\n</strong></span>\r\n要求为String类型的参数，在一个jsonp请求中重写回调函数的名字。该值用来替代在\"callback=&#63;\"这种GET或POST请求中URL参数里的\"callback\"部分，例如{jsonp:\'onJsonPLoad\'}会导致将\"onJsonPLoad=&#63;\"传给服务器。\r\n\r\n<span style=\"color: #ff0000\"><strong>18.username：\r\n</strong></span>\r\n要求为String类型的参数，用于响应HTTP访问认证请求的用户名。\r\n\r\n<span style=\"color: #ff0000\"><strong>19.password：</strong></span>\r\n\r\n要求为String类型的参数，用于响应HTTP访问认证请求的密码。\r\n\r\n<span style=\"color: #ff0000\"><strong>20.processData：</strong></span>\r\n\r\n要求为Boolean类型的参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型\"application/x-www-form-urlencoded\"。如果要发送DOM树信息或者其他不希望转换的信息，请设置为false。\r\n\r\n<span style=\"color: #ff0000\"><strong>21.scriptCharset：</strong></span>\r\n要求为String类型的参数，只有当请求时dataType为\"jsonp\"或者\"script\"，并且type是GET时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用。\r\n\r\n<strong>案例代码：\r\n</strong>\r\n<pre><code>\r\n$(function(){\r\n$(\'#send\').click(function(){\r\n$.ajax({\r\ntype: \"GET\",\r\nurl: \"test.json\",\r\ndata: {username:$(\"#username\").val(), content:$(\"#content\").val()},\r\ndataType: \"json\",\r\nsuccess: function(data){\r\n$(\'#resText\').empty(); //清空resText里面的所有内容\r\nvar html = \'\'; \r\n$.each(data, function(commentIndex, comment){\r\nhtml += \'&lt;div class=\"comment\"&gt;&lt;h6&gt;\' + comment[\'username\']\r\n+ \':&lt;/h6&gt;&lt;p class=\"para\"\' + comment[\'content\']\r\n+ \'&lt;/p&gt;&lt;/div&gt;\';\r\n});\r\n$(\'#resText\').html(html);\r\n}\r\n});\r\n});\r\n});</code></pre>\r\n以上所述是小编给大家介绍的$.ajax()常用方法详解(推荐)，希望对大家有所帮助，如果大家有任何疑问请给我留言，小编会及时回复大家的。在此也非常感谢大家对脚本之家网站的支持！\r\n\r\n', '2018-03-23 09:11:00', '脚本之家', 'http://www.jb51.net/article/89028.htm'),
(123, '为什么 ++[[]][+[]]+[+[]] = 10？', 'justjavac(迷渡)', 'JS', '首先，问“<a href=\"http://stackoverflow.com/q/7202157/343194\" title=\"Can you explain why ++[[]][+[]]+[+[]] = “10”?\">这个问题(英文)</a>”的人是个天才，他怎么会遇到这样的一个问题。\n其次，回答这个问题的人更是一个天才，我难以想象他会回答这个问题，更难以想象的是，他的回答是如此的详细和丰富和完整，真正称得上诲人不倦。\n既然遇到了这个问题，我们不妨也跟着提高一下。\n这是一个<a href=\"http://justjavac.com/javascript/2012/04/05/you-dont-know-javascript.html\">Javascript 语言题目</a>，一个完全有效的等式，不信自己可以试一下，下面看看高人的题解：\n<pre><code>++[[]][+[]]+[+[]]</code></pre>如果把这段表达式拆分开来，它相等于：\n<pre><code>++[[]][+[]]\n+\n[+[]]</code></pre>在 JavaScript 里，<code>+[] === 0</code> 是完全正确的。 <code>+</code> 会把一些字符转化成数字，在这里，这个式子会变成 <code class=\"highlighter-rouge\">+\"\"</code> 或 <code class=\"highlighter-rouge\">0</code>。\n因此，我们可以简化一下(<code class=\"highlighter-rouge\">++</code> 比 <code class=\"highlighter-rouge\">+</code> 有更高的优先级)：\n<pre><code>++[[]][0]\n+\n[0]</code></pre>因为 <code class=\"highlighter-rouge\">[[]][0]</code> 的意思是：获取 <code class=\"highlighter-rouge\">[[]]</code> 的第一个元素，这就得出了下面的结果：\n<ul>\n<li><code class=\"highlighter-rouge\">[[]][0]</code> 返回内部数组 (<code class=\"highlighter-rouge\">[]</code>)。根据语言规范，我们说 <code class=\"highlighter-rouge\">[[]][0] === []</code> 是不正确的，但让我们把这个内部数组称作 A，以避免错误的写法。</li>\n<li><code class=\"highlighter-rouge\">++[[]][0] == A + 1</code>， 因为 <code class=\"highlighter-rouge\">++</code> 的意思是”加一”。</li>\n<li><code class=\"highlighter-rouge\">++[[]][0] === +(A + 1)</code>；换句话说，你得到的永远是个数值( <code class=\"highlighter-rouge\">+1</code> 并不一定得到的是个数值，但 <code class=\"highlighter-rouge\">++</code> 一定是)。</li>\n</ul>同样，我们可以把这一堆代码简化的更清晰。让我们把 A 换回成 <code class=\"highlighter-rouge\">[]</code> :\n<pre><code>+([] + 1)\n+\n[0]</code></pre>在 JavaScript 里，这也是正确的：<code class=\"highlighter-rouge\">[] + 1 === \"1\"</code>，因为 <code class=\"highlighter-rouge\">[] == \"\"</code> (这相当于一个空的数组的内部元素连接)，于是：\n<pre><code>+([] + 1) === +(\"” + 1)，并且 \n+(\"” + 1) === +(\"1\")，并且 \n+(\"1\") === 1 </code></pre>让我们再次简化一下：\n<pre><code>1\n+\n[0]</code></pre>同样，在 Javascript 里，这是正确的：<code class=\"highlighter-rouge\">[0] == \"0\"</code>，因为这是相当于一个有一个元素的数组的内部元素的连接。\n各元素会使用，分隔。\n当只有一个元素时，你可以推论出这个过程的结果就是它自身的第一个元素。\n所以，最终我们得到 (数字 + 字符串 = 字符串)：\n<pre><code>1\n+\n\"0\"\n\n=== \"10\" // 耶！</code></pre>如果你想知道更详细的信息，请访问<a href=\"http://stackoverflow.com/q/7202157/343194\" title=\"Can you explain why ++[[]][+[]]+[+[]] = “10”?\">这里(英文)</a>。\n继续阅读关于<a href=\"/tags.html#javascript-ref\" rel=\"tag\">javascript</a>的文章', '2018-05-17 20:22:00', '个人博客', 'http://justjavac.com/javascript/2012/05/24/can-you-explain-why-10.html'),
(124, '彻底的卸载干净oracle 11g', 'Devin_LiuYM', 'SQL', '1.关闭oracle所有的服务。可以在windows的服务管理器中关闭；\r\n<img src=\"https://img-blog.csdn.net/20170302161502166?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGV2aW5fTGl1WU0=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\" />\r\n\r\n2.打开注册表：regedit 打开路径： &lt;找注册表 ：开始-&gt;运行-&gt;regedit&gt;\r\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\ \r\n删除该路径下的所有以oracle开始的服务名称，这个键是标识Oracle在windows下注册的各种服务。\r\n<img src=\"https://img-blog.csdn.net/20170302161554433?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGV2aW5fTGl1WU0=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\" />\r\n\r\n3.打开注册表，找到路径：  \r\nHKEY_LOCAL_MACHINE\\SOFTWARE\\ORACLE\r\n删除该oracle目录，该目录下注册着Oracle数据库的软件安装信息。\r\n\r\n<img src=\"https://img-blog.csdn.net/20170302162146985?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGV2aW5fTGl1WU0=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\" />\r\n4.删除注册的oracle事件日志，打开注册表\r\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\r\n删除注册表的以oracle开头的所有项目。\r\n<img src=\"https://img-blog.csdn.net/20170302162230923?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGV2aW5fTGl1WU0=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\" />\r\n\r\n5.删除环境变量path中关于oracle的内容。\r\n鼠标右键右单击“我的电脑--&gt;属性--&gt;高级--&gt;环境变量--&gt;PATH 变量。\r\n删除Oracle在该值中的内容。注意:path中记录着一堆操作系统的目录，在windows中各个目录之间使用分号（;）隔开的，删除时注意。\r\n建议：删除PATH环境变量中关于Oracle的值时，将该值全部拷贝到文本编辑器中，找到对应的Oracle的值，删除后，再拷贝修改的串，\r\n粘贴到PATH环境变量中，这样相对而言比较安全。\r\n<img src=\"https://img-blog.csdn.net/20170302165915784?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGV2aW5fTGl1WU0=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\" />\r\n<img src=\"https://img-blog.csdn.net/20170302163351866?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRGV2aW5fTGl1WU0=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\" width=\"730\" height=\"232\" />\r\n\r\n6.重新启动操作系统。\r\n以上1~5个步骤操作完毕后，重新启动操作系统。\r\n\r\n\r\n7.重启操作系统后各种Oracle相关的进程都不会加载了。这时删除Oracle_Home下的所有数据。\r\n（Oracle_Home指Oracle程序的安装目录）\r\n\r\n\r\n8.删除C:\\Program Files下oracle目录。\r\n（该目录视Oracle安装所在路径而定）\r\n\r\n\r\n9.删除开始菜单下oracle项，如：\r\nC:\\Documents and Settings\\All Users\\「开始」菜单\\程序\\Oracle - Ora10g\r\n不同的安装这个目录稍有不同。\r\n如果不删除开始菜单下的Oracle相关菜单目录，没关系，这个不影响再次安装Oracle.当再次安装Oracle时，该菜单会被替换。\r\n\r\n\r\n至此，Windows平台下Oracle就彻底卸载了。 ', '2018-03-24 09:01:00', 'CSDN', 'https://blog.csdn.net/Devin_LiuYM/article/details/59539020'),
(125, 'PHP中的print_r 与 var_dump 输出数组', 'jingxian', 'PHP', '<blockquote>下面小编就为大家带来一篇PHP中的print_r 与 var_dump 输出数组。小编觉得挺不错的，现在就分享给大家，也给大家做个参考</blockquote>\r\n\r\nprint_r() 和 var_dump() 函数可以打印输出整个数组内容及结构。\r\n<span style=\"color: #ff0000\"><strong>print_r()</strong></span>\r\n利用 print_r() 函数可以打印输出整个数组内容及结构，按照一定格式显示键和元素。注意 print_r() 函数不仅是只用于打印，实际它是用于打印关于变量的易于理解的信息。\r\n<strong>语法：</strong>\r\nbool print_r( mixed expression )例子：\r\n<pre><code>&lt;&#63;php\r\n$arr_age = array(18, 20, 25);\r\nprint_r($arr_age);\r\n&#63;&gt;</code></pre>\r\n\r\n<strong>运行该例子输出：</strong>\r\nArray ( [0] =&gt; 18 [1] =&gt; 20 [2] =&gt; 25 ) 查看输出结果的网页源代码，可以看到更易读的格式：<br />\r\n\r\n<pre><code>Array\r\n(\r\n  [0] =&gt; 18\r\n  [1] =&gt; 20\r\n  [2] =&gt; 25\r\n) \r\nvar_dump()</code></pre>\r\n\r\n同 print_r() 函数一样，var_dump() 函数也可以用于打印数组的数据及结构。不过 var_dump() 函数功能比 print_r() 更强大，可以同时打印多个变量且给出变量的类型信息。\r\n<strong>例子：<br />\r\n</strong>\r\n<pre><code>&lt;&#63;php\r\n$arr_age = array(18, 20, 25);\r\nvar_dump($arr_age);\r\n&#63;&gt;</code></pre>\r\n\r\n运行该例子输出：<br />\r\n\r\n<pre><code>array(3) {\r\n [0]=&gt;\r\n int(18)\r\n [1]=&gt;\r\n int(20)\r\n [2]=&gt;\r\n int(25)\r\n}</code></pre>\r\n\r\nprint_r() 和 var_dump() 函数一般是用于调试程序使用，更多情况是使用 echo 来输出具体的数组单元值。\r\n以上这篇PHP中的print_r 与 var_dump 输出数组就是小编分享给大家的全部内容了，希望能给大家一个参考，也希望大家多多支持脚本之家。', '2018-03-24 20:27:00', '脚本之家', 'http://www.jb51.net/article/86470.htm'),
(126, 'PHP之十六个魔术方法详细介绍', 'chenyanxx', 'PHP', '<blockquote>PHP中把以两个下划线__开头的方法称为魔术方法(Magic methods),这些方法在PHP中充当了举足轻重的作用。这里进行详细介绍，感兴趣的小伙伴们可以参考一下。</blockquote>\r\n\r\nPHP中把以两个下划线__开头的方法称为魔术方法(Magic methods)，这些方法在PHP中充当了举足轻重的作用。 魔术方法包括：<br />\r\n\r\n<ul>\r\n  <li>__construct()，类的构造函数</li>\r\n  <li>__destruct()，类的析构函数</li>\r\n  <li>__call()，在对象中调用一个不可访问方法时调用</li>\r\n  <li>__callStatic()，用静态方式中调用一个不可访问方法时调用</li>\r\n  <li>__get()，获得一个类的成员变量时调用</li>\r\n  <li>__set()，设置一个类的成员变量时调用</li>\r\n  <li>__isset()，当对不可访问属性调用isset()或empty()时调用</li>\r\n  <li>__unset()，当对不可访问属性调用unset()时被调用。</li>\r\n  <li>__sleep()，执行serialize()时，先会调用这个函数</li>\r\n  <li>__wakeup()，执行unserialize()时，先会调用这个函数</li>\r\n  <li>__toString()，类被当成字符串时的回应方法</li>\r\n  <li>__invoke()，调用函数的方式调用一个对象时的回应方法</li>\r\n  <li>__set_state()，调用var_export()导出类时，此静态方法会被调用。</li>\r\n  <li>__clone()，当对象复制完成时调用</li>\r\n  <li>__autoload()，尝试加载未定义的类</li>\r\n  <li>__debugInfo()，打印所需调试信息</li>\r\n</ul>\r\n<strong>范例</strong><br />\r\n\r\n下面让我们以实例的形式向大家讲解下这几个魔术方法时如何使用的。\r\n<strong>一、 __construct()，类的构造函数<br />\r\n</strong>\r\nphp中构造方法是对象创建完成后第一个被对象自动调用的方法。在每个类中都有一个构造方法，如果没有显示地声明它，那么类中都会默认存在一个没有参数且内容为空的构造方法。\r\n1、 构造方法的作用\r\n通常构造方法被用来执行一些有用的初始化任务，如对成员属性在创建对象时赋予初始值。\r\n2、 构造方法的在类中的声明格式<br />\r\n\r\n<pre><code>\r\n\r\nfunction __constrct([参数列表]){\r\n\r\n  方法体 //通常用来对成员属性进行初始化赋值\r\n}\r\n</code></pre>\r\n3、 在类中声明构造方法需要注意的事项\r\n1、在同一个类中只能声明一个构造方法，原因是，PHP不支持构造函数重载。\r\n2、构造方法名称是以两个下画线开始的__construct()<br />\r\n\r\n下面是它的例子：<br />\r\n\r\n<pre><code>\r\n\r\n&lt;&#63;php\r\n  class Person\r\n  {                                   \r\n      public $name;    \r\n      public $age;    \r\n      public $sex;    \r\n                                 \r\n    /**\r\n     * 显示声明一个构造方法且带参数\r\n     */                                            \r\n    public function __construct($name=\"\", $sex=\"男\", $age=22)\r\n    {   \r\n      $this-&gt;name = $name;\r\n      $this-&gt;sex = $sex;\r\n      $this-&gt;age = $age;\r\n    }\r\n    \r\n    /**\r\n     * say 方法\r\n     */\r\n    public function say()\r\n    { \r\n      echo \"我叫：\" . $this-&gt;name . \"，性别：\" . $this-&gt;sex . \"，年龄：\" . $this-&gt;age;\r\n    }  \r\n                                              \r\n  }\r\n</code></pre>\r\n创建对象$Person1且不带任参数\r\n<pre><code>\r\n\r\n$Person1 = new Person();\r\necho $Person1-&gt;say(); //输出:我叫：，性别：男，年龄：27</code></pre>\r\n创建对象$Person2且带参数“小明”\r\n<pre><code>\r\n\r\n$Person2 = new Person(\"小明\");\r\necho $Person2-&gt;say(); //输出：我叫：张三，性别：男，年龄：27</code></pre>\r\n创建对象$Person3且带三个参数\r\n<pre><code>\r\n\r\n$Person3 = new Person(\"李四\",\"男\",25);\r\necho $Person3-&gt;say(); //输出：我叫：李四，性别：男，年龄：25</code></pre>\r\n<strong>二、__destruct()，类的析构函数</strong><br />\r\n\r\n通过上面的讲解，现在我们已经知道了什么叫构造方法。那么与构造方法对应的就是析构方法。\r\n析构方法允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件、释放结果集等。\r\n析构方法是PHP5才引进的新内容。\r\n析造方法的声明格式与构造方法 __construct() 比较类似，也是以两个下划线开始的方法 __destruct() ，这种析构方法名称也是固定的。\r\n1、 析构方法的声明格式\r\n<pre><code>\r\n\r\nfunction __destruct()\r\n{\r\n //方法体\r\n}</code></pre>\r\n注意：析构函数不能带有任何参数。\r\n2、 析构方法的作用\r\n一般来说，析构方法在PHP中并不是很常用，它属类中可选择的一部分，通常用来完成一些在对象销毁前的清理任务。<br />\r\n举例演示，如下：\r\n<pre><code>\r\n\r\n&lt;&#63;php\r\nclass Person{   \r\n                            \r\n  public $name;     \r\n  public $age;     \r\n  public $sex;     \r\n                                  \r\n  public function __construct($name=\"\", $sex=\"男\", $age=22)\r\n  {  \r\n    $this-&gt;name = $name;\r\n    $this-&gt;sex = $sex;\r\n    $this-&gt;age = $age;\r\n  }\r\n  \r\n  /**\r\n   * say 说话方法\r\n   */\r\n  public function say()\r\n  { \r\n    echo \"我叫：\".$this-&gt;name.\"，性别：\".$this-&gt;sex.\"，年龄：\".$this-&gt;age;\r\n  }  \r\n  \r\n  /**\r\n   * 声明一个析构方法\r\n   */\r\n  public function __destruct()\r\n  {\r\n      echo \"我觉得我还可以再抢救一下，我的名字叫\".$this-&gt;name;\r\n  }\r\n}\r\n\r\n$Person = new Person(\"小明\");\r\nunset($Person); //销毁上面创建的对象$Person\r\n\r\n</code></pre>\r\n上面的程序运行时输出：\r\n我觉得我还可以再抢救一下，我的名字叫小明<br />\r\n\r\n<strong>三、 __call()，在对象中调用一个不可访问方法时调用。</strong><br />\r\n\r\n该方法有两个参数，第一个参数 $function_name 会自动接收不存在的方法名，第二个 $arguments 则以数组的方式接收不存在方法的多个参数。\r\n1、 __call() 方法的格式：\r\n<pre><code>\r\n\r\nfunction __call(string $function_name, array $arguments)\r\n{\r\n  // 方法体\r\n}</code></pre>\r\n2、 __call() 方法的作用：\r\n为了避免当调用的方法不存在时产生错误，而意外的导致程序中止，可以使用 __call() 方法来避免。\r\n该方法在调用的方法不存在时会自动调用，程序仍会继续执行下去。<br />\r\n\r\n请参考如下代码：\r\n<pre><code>\r\n\r\n&lt;&#63;php\r\nclass Person\r\n{               \r\n  function say()\r\n  { \r\n               \r\n      echo \"Hello, world!&lt;br&gt;\"; \r\n  }   \r\n    \r\n  /**\r\n   * 声明此方法用来处理调用对象中不存在的方法\r\n   */\r\n  function __call($funName, $arguments)\r\n  { \r\n     echo \"你所调用的函数：\" . $funName . \"(参数：\" ; // 输出调用不存在的方法名\r\n     print_r($arguments); // 输出调用不存在的方法时的参数列表\r\n     echo \")不存在！&lt;br&gt;\\n\"; // 结束换行           \r\n  }                     \r\n}\r\n$Person = new Person();      \r\n$Person-&gt;run(\"teacher\"); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法\r\n$Person-&gt;eat(\"小明\", \"苹果\");       \r\n$Person-&gt;say();  </code></pre>\r\n运行结果：\r\n你所调用的函数：run(参数：Array ( [0] =&gt; teacher ) )不存在！\r\n你所调用的函数：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！\r\nHello, world!<br />\r\n\r\n<strong>四、 __callStatic()，用静态方式中调用一个不可访问方法时调用</strong><br />\r\n\r\n此方法与上面所说的 __call() 功能除了 __callStatic() 是未静态方法准备的之外，其它都是一样的。\r\n请看下面代码：\r\n<pre><code>\r\n\r\n&lt;&#63;php\r\nclass Person\r\n{\r\n  function say()\r\n  {\r\n\r\n    echo \"Hello, world!&lt;br&gt;\";\r\n  }\r\n\r\n  /**\r\n   * 声明此方法用来处理调用对象中不存在的方法\r\n   */\r\n  public static function __callStatic($funName, $arguments)\r\n  {\r\n    echo \"你所调用的静态方法：\" . $funName . \"(参数：\" ; // 输出调用不存在的方法名\r\n    print_r($arguments); // 输出调用不存在的方法时的参数列表\r\n    echo \")不存在！&lt;br&gt;\\n\"; // 结束换行\r\n  }\r\n}\r\n$Person = new Person();\r\n$Person::run(\"teacher\"); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法\r\n$Person::eat(\"小明\", \"苹果\");\r\n$Person-&gt;say();\r\n\r\n</code></pre>\r\n运行结果如下：\r\n你所调用的静态方法：run(参数：Array ( [0] =&gt; teacher ) )不存在！<br />\r\n你所调用的静态方法：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！<br />\r\nHello, world!<br />\r\n\r\n<strong>五、 __get()，获得一个类的成员变量时调用</strong><br />\r\n\r\n在 php 面向对象编程中，类的成员属性被设定为 private 后，如果我们试图在外面调用它则会出现“不能访问某个私有属性”的错误。那么为了解决这个问题，我们可以使用魔术方法 __get()。\r\n魔术方法__get()的作用<br />\r\n\r\n在程序运行过程中，通过它可以在对象的外部获取私有成员属性的值。<br />\r\n\r\n我们通过下面的 __get() 的实例来更进一步的连接它吧：<br />\r\n\r\n<pre><code>\r\n\r\n&lt;&#63;php\r\nclass Person\r\n{\r\n  private $name;\r\n  private $age;\r\n\r\n  function __construct($name=\"\", $age=1)\r\n  {\r\n    $this-&gt;name = $name;\r\n    $this-&gt;age = $age;\r\n  }\r\n\r\n  /**\r\n   * 在类中添加__get()方法，在直接获取属性值时自动调用一次，以属性名作为参数传入并处理\r\n   * @param $propertyName\r\n   *\r\n   * @return int\r\n   */\r\n  public function __get($propertyName)\r\n  {  \r\n    if ($propertyName == \"age\") {\r\n      if ($this-&gt;age &gt; 30) {\r\n        return $this-&gt;age - 10;\r\n      } else {\r\n        return $this-&gt;$propertyName;\r\n      }\r\n    } else {\r\n      return $this-&gt;$propertyName;\r\n    }\r\n  }\r\n}\r\n$Person = new Person(\"小明\", 60);  // 通过Person类实例化的对象，并通过构造方法为属性赋初值\r\necho \"姓名：\" . $Person-&gt;name . \"&lt;br&gt;\";  // 直接访问私有属性name，自动调用了__get()方法可以间接获取\r\necho \"年龄：\" . $Person-&gt;age . \"&lt;br&gt;\";  // 自动调用了__get()方法，根据对象本身的情况会返回不同的值\r\n\r\n</code></pre>\r\n运行结果：\r\n姓名：小明<br />\r\n年龄：50<br />\r\n\r\n<strong>六、 __set()，设置一个类的成员变量时调用</strong><br />\r\n\r\n__set() 的作用：<br />\r\n\r\n__set( $property, $value )` 方法用来设置私有属性， 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值。\r\n请看下面的演示代码：\r\n<pre><code>\r\n\r\n&lt;&#63;php\r\nclass Person\r\n{\r\n  private $name;\r\n  private $age;\r\n\r\n  public function __construct($name=\"\", $age=25)\r\n  {\r\n    $this-&gt;name = $name;\r\n    $this-&gt;age = $age;\r\n  }\r\n\r\n  /**\r\n   * 声明魔术方法需要两个参数，真接为私有属性赋值时自动调用，并可以屏蔽一些非法赋值\r\n   * @param $property\r\n   * @param $value\r\n   */\r\n  public function __set($property, $value) {\r\n    if ($property==\"age\")\r\n    {\r\n      if ($value &gt; 150 || $value &lt; 0) {\r\n        return;\r\n      }\r\n    }\r\n    $this-&gt;$property = $value;\r\n  }\r\n\r\n  /**\r\n   * 在类中声明说话的方法，将所有的私有属性说出\r\n   */\r\n  public function say(){\r\n    echo \"我叫\".$this-&gt;name.\"，今年\".$this-&gt;age.\"岁了\";\r\n  }\r\n}\r\n\r\n$Person=new Person(\"小明\", 25); //注意，初始值将被下面所改变\r\n//自动调用了__set()函数，将属性名name传给第一个参数，将属性值”李四”传给第二个参数\r\n$Person-&gt;name = \"小红\";   //赋值成功。如果没有__set()，则出错。\r\n//自动调用了__set()函数，将属性名age传给第一个参数，将属性值26传给第二个参数\r\n$Person-&gt;age = 16; //赋值成功\r\n$Person-&gt;age = 160; //160是一个非法值，赋值失效\r\n$Person-&gt;say(); //输出：我叫小红，今年16岁了\r\n\r\n</code></pre>\r\n运行结果：\r\n我叫小红，今年16岁了<br />\r\n\r\n<strong>七、 __isset()，当对不可访问属性调用isset()或empty()时调用</strong><br />\r\n\r\n在看这个方法之前我们看一下isset()函数的应用，isset()是测定变量是否设定用的函数，传入一个变量作为参数，如果传入的变量存在则传回true，否则传回false。\r\n那么如果在一个对象外面使用isset()这个函数去测定对象里面的成员是否被设定可不可以用它呢？\r\n分两种情况，如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性，如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。那么我们就不可以在对象的外部使用isset()函数来测定私有成员属性是否被设定了呢？当然是可以的，但不是一成不变。你只要在类里面加上一个__isset()方法就可以了，当在类外部使用isset()函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的__isset()方法了帮我们完成这样的操作。\r\n__isset()的作用：当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。<br />\r\n\r\n请看下面代码演示：\r\n<pre><code>\r\n\r\n&lt;&#63;php\r\nclass Person\r\n{\r\n  public $sex;\r\n  private $name;\r\n  private $age;\r\n\r\n  public function __construct($name=\"\", $age=25, $sex=\'男\')\r\n  {\r\n    $this-&gt;name = $name;\r\n    $this-&gt;age = $age;\r\n    $this-&gt;sex = $sex;\r\n  }\r\n\r\n  /**\r\n   * @param $content\r\n   *\r\n   * @return bool\r\n   */\r\n  public function __isset($content) {\r\n    echo \"当在类外部使用isset()函数测定私有成员{$content}时，自动调用&lt;br&gt;\";\r\n    echo isset($this-&gt;$content);\r\n  }\r\n}\r\n\r\n$person = new Person(\"小明\", 25); // 初始赋值\r\necho isset($person-&gt;sex),\"&lt;br&gt;\";\r\necho isset($person-&gt;name),\"&lt;br&gt;\";\r\necho isset($person-&gt;age),\"&lt;br&gt;\";\r\n\r\n</code></pre>\r\n运行结果如下：\r\n1 // public 可以 isset()<br />\r\n当在类外部使用isset()函数测定私有成员name时，自动调用 // __isset() 内 第一个echo<br />\r\n1 // __isset() 内第二个echo<br />\r\n当在类外部使用isset()函数测定私有成员age时，自动调用 // __isset() 内 第一个echo<br />\r\n1 // __isset() 内第二个echo<br />\r\n\r\n<strong>八、 __unset()，当对不可访问属性调用unset()时被调用。</strong><br />\r\n\r\n看这个方法之前呢，我们也先来看一下 unset() 函数，unset()这个函数的作用是删除指定的变量且传回true，参数为要删除的变量。\r\n那么如果在一个对象外部去删除对象内部的成员属性用unset()函数可以吗？\r\n这里自然也是分两种情况：\r\n1、 如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性。\r\n2、 如果对象的成员属性是私有的，我使用这个函数就没有权限去删除。\r\n虽然有以上两种情况，但我想说的是同样如果你在一个对象里面加上__unset()这个方法，就可以在对象的外部去删除对象的私有成员属性了。在对象里面加上了__unset()这个方法之后，在对象外部使用“unset()”函数删除对象内部的私有成员属性时，对象会自动调用__unset()函数来帮我们删除对象内部的私有成员属性。\r\n请看如下代码：\r\n<pre><code>\r\n\r\n&lt;&#63;php\r\nclass Person\r\n{\r\n  public $sex;\r\n  private $name;\r\n  private $age;\r\n\r\n  public function __construct($name=\"\", $age=25, $sex=\'男\')\r\n  {\r\n    $this-&gt;name = $name;\r\n    $this-&gt;age = $age;\r\n    $this-&gt;sex = $sex;\r\n  }\r\n\r\n  /**\r\n   * @param $content\r\n   *\r\n   * @return bool\r\n   */\r\n  public function __unset($content) {\r\n    echo \"当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;\";\r\n    echo isset($this-&gt;$content);\r\n  }\r\n}\r\n\r\n$person = new Person(\"小明\", 25); // 初始赋值\r\nunset($person-&gt;sex);\r\nunset($person-&gt;name);\r\nunset($person-&gt;age);\r\n\r\n</code></pre>\r\n运行结果：\r\n当在类外部使用unset()函数来删除私有成员时自动调用的<br />\r\n1当在类外部使用unset()函数来删除私有成员时自动调用的<br />\r\n\r\n<strong>九、 __sleep()，执行serialize()时，先会调用这个函数</strong><br />\r\n\r\nserialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，则该方法会优先被调用，然后才执行序列化操作。\r\n此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。\r\n如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。\r\n<strong>注意：</strong>\r\n__sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。<br />\r\n作用：\r\n__sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。<br />\r\n\r\n具体请参考如下代码：\r\n<pre><code>\r\n\r\n&lt;&#63;php\r\nclass Person\r\n{\r\n  public $sex;\r\n  public $name;\r\n  public $age;\r\n\r\n  public function __construct($name=\"\", $age=25, $sex=\'男\')\r\n  {\r\n    $this-&gt;name = $name;\r\n    $this-&gt;age = $age;\r\n    $this-&gt;sex = $sex;\r\n  }\r\n\r\n  /**\r\n   * @return array\r\n   */\r\n  public function __sleep() {\r\n    echo \"当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;\";\r\n    $this-&gt;name = base64_encode($this-&gt;name);\r\n    return array(\'name\', \'age\'); // 这里必须返回一个数值，里边的元素表示返回的属性名称\r\n  }\r\n}\r\n\r\n$person = new Person(\'小明\'); // 初始赋值\r\necho serialize($person);\r\necho \'&lt;br/&gt;\';\r\n\r\n</code></pre>\r\n代码运行结果：\r\n当在类外部使用serialize()时会调用这里的__sleep()方法<br />\r\nO:6:\"Person\":2:{s:4:\"name\";s:8:\"5bCP5piO\";s:3:\"age\";i:25;}<br />\r\n\r\n<strong>十、 __wakeup()，执行unserialize()时，先会调用这个函数</strong><br />\r\n\r\n如果说 __sleep() 是白的，那么 __wakeup() 就是黑的了。\r\n那么为什么呢？\r\n因为：\r\n与之相反，`unserialize()` 会检查是否存在一个 `__wakeup()` 方法。如果存在，则会先调用 `__wakeup` 方法，预先准备对象需要的资源。<br />\r\n\r\n作用：<br />\r\n\r\n__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。<br />\r\n\r\n还是看代码：\r\n<pre><code>\r\n\r\n&lt;&#63;php\r\nclass Person\r\n{\r\n  public $sex;\r\n  public $name;\r\n  public $age;\r\n\r\n  public function __construct($name=\"\", $age=25, $sex=\'男\')\r\n  {\r\n    $this-&gt;name = $name;\r\n    $this-&gt;age = $age;\r\n    $this-&gt;sex = $sex;\r\n  }\r\n\r\n  /**\r\n   * @return array\r\n   */\r\n  public function __sleep() {\r\n    echo \"当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;\";\r\n    $this-&gt;name = base64_encode($this-&gt;name);\r\n    return array(\'name\', \'age\'); // 这里必须返回一个数值，里边的元素表示返回的属性名称\r\n  }\r\n\r\n  /**\r\n   * __wakeup\r\n   */\r\n  public function __wakeup() {\r\n    echo \"当在类外部使用unserialize()时会调用这里的__wakeup()方法&lt;br&gt;\";\r\n    $this-&gt;name = 2;\r\n    $this-&gt;sex = \'男\';\r\n    // 这里不需要返回数组\r\n  }\r\n}\r\n\r\n$person = new Person(\'小明\'); // 初始赋值\r\nvar_dump(serialize($person));\r\nvar_dump(unserialize(serialize($person)));\r\n\r\n</code></pre>\r\n运行结果：\r\n当在类外部使用serialize()时会调用这里的__sleep()方法<br />\r\nstring(58) \"O:6:\"Person\":2:{s:4:\"name\";s:8:\"5bCP5piO\";s:3:\"age\";i:25;}\" 当在类外部使用serialize()时会调用这里的__sleep()方法<br />\r\n当在类外部使用unserialize()时会调用这里的__wakeup()方法<br />\r\nobject(Person)#2 (3) { [\"sex\"]=&gt; string(3) \"男\" [\"name\"]=&gt; int(2) [\"age\"]=&gt; int(25) }<br />\r\n\r\n<strong>十一、 __toString()，类被当成字符串时的回应方法</strong><br />\r\n\r\n作用：\r\n__toString() 方法用于一个类被当成字符串时应怎样回应。例如 `echo $obj;` 应该显示些什么。<br />\r\n\r\n注意：\r\n此方法必须返回一个字符串，否则将发出一条 `E_RECOVERABLE_ERROR` 级别的致命错误。<br />\r\n\r\n警告：\r\n不能在 __toString() 方法中抛出异常。这么做会导致致命错误。<br />\r\n\r\n代码：\r\n<pre><code>\r\n\r\n&lt;&#63;php\r\nclass Person\r\n{\r\n  public $sex;\r\n  public $name;\r\n  public $age;\r\n\r\n  public function __construct($name=\"\", $age=25, $sex=\'男\')\r\n  {\r\n    $this-&gt;name = $name;\r\n    $this-&gt;age = $age;\r\n    $this-&gt;sex = $sex;\r\n  }\r\n\r\n  public function __toString()\r\n  {\r\n    return \'go go go\';\r\n  }\r\n}\r\n\r\n$person = new Person(\'小明\'); // 初始赋值\r\necho $person;\r\n\r\n</code></pre>\r\n结果：\r\ngo go go<br />\r\n\r\n那么如果类中没有 __toString() 这个魔术方法运行会发生什么呢？让我们来测试下：\r\n代码：\r\n<pre><code>\r\n\r\n&lt;&#63;php\r\nclass Person\r\n{\r\n  public $sex;\r\n  public $name;\r\n  public $age;\r\n\r\n  public function __construct($name=\"\", $age=25, $sex=\'男\')\r\n  {\r\n    $this-&gt;name = $name;\r\n    $this-&gt;age = $age;\r\n    $this-&gt;sex = $sex;\r\n  }\r\n  \r\n}\r\n\r\n$person = new Person(\'小明\'); // 初始赋值\r\necho $person;\r\n\r\n</code></pre>\r\n结果：\r\nCatchable fatal error: Object of class Person could not be converted to string in D:\\phpStudy\\WWW\\test\\index.php on line 18<br />\r\n很明显，页面报了一个致命错误，这是语法所不允许的。\r\n<strong>十二、 __invoke()，调用函数的方式调用一个对象时的回应方法<br />\r\n</strong>\r\n作用：\r\n当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。<br />\r\n\r\n注意：\r\n本特性只在 PHP 5.3.0 及以上版本有效。<br />\r\n\r\n直接上代码：\r\n<pre><code>\r\n\r\n&lt;&#63;php\r\nclass Person\r\n{\r\n  public $sex;\r\n  public $name;\r\n  public $age;\r\n\r\n  public function __construct($name=\"\", $age=25, $sex=\'男\')\r\n  {\r\n    $this-&gt;name = $name;\r\n    $this-&gt;age = $age;\r\n    $this-&gt;sex = $sex;\r\n  }\r\n\r\n  public function __invoke() {\r\n    echo \'这可是一个对象哦\';\r\n  }\r\n\r\n}\r\n\r\n$person = new Person(\'小明\'); // 初始赋值\r\n$person();\r\n\r\n</code></pre>\r\n查看运行结果：\r\n这可是一个对象哦<br />\r\n\r\n当然，如果你执意要将对象当函数方法使用，那么会得到下面结果：\r\nFatal error: Function name must be a string in D:\\phpStudy\\WWW\\test\\index.php on line 18<br />\r\n\r\n<strong>十三、 __set_state()，调用var_export()导出类时，此静态方法会被调用。<br />\r\n</strong>\r\n作用：\r\n自 PHP 5.1.0 起，当调用 var_export() 导出类时，此静态方法会被自动调用。<br />\r\n\r\n参数：\r\n本方法的唯一参数是一个数组，其中包含按 array(\'property\' =&gt; value, ...) 格式排列的类属性。<br />\r\n\r\n下面我们先来看看在没有加 __set_state() 情况按下，代码及运行结果如何：\r\n上代码：\r\n<pre><code>\r\n\r\n&lt;&#63;php\r\nclass Person\r\n{\r\n  public $sex;\r\n  public $name;\r\n  public $age;\r\n\r\n  public function __construct($name=\"\", $age=25, $sex=\'男\')\r\n  {\r\n    $this-&gt;name = $name;\r\n    $this-&gt;age = $age;\r\n    $this-&gt;sex = $sex;\r\n  }\r\n\r\n}\r\n\r\n$person = new Person(\'小明\'); // 初始赋值\r\nvar_export($person);\r\n\r\n</code></pre>\r\n看结果：\r\nPerson::__set_state(array( \'sex\' =&gt; \'男\', \'name\' =&gt; \'小明\', \'age\' =&gt; 25, ))<br />\r\n\r\n很明显，将对象中的属性都打印出来了\r\n加了 __set_state() 之后：\r\n继续上代码：\r\n<pre><code>\r\n\r\n&lt;&#63;php\r\nclass Person\r\n{\r\n  public $sex;\r\n  public $name;\r\n  public $age;\r\n\r\n  public function __construct($name=\"\", $age=25, $sex=\'男\')\r\n  {\r\n    $this-&gt;name = $name;\r\n    $this-&gt;age = $age;\r\n    $this-&gt;sex = $sex;\r\n  }\r\n\r\n  public static function __set_state($an_array)\r\n  {\r\n    $a = new Person();\r\n    $a-&gt;name = $an_array[\'name\'];\r\n    return $a;\r\n  }\r\n\r\n}\r\n\r\n$person = new Person(\'小明\'); // 初始赋值\r\n$person-&gt;name = \'小红\';\r\nvar_export($person);\r\n\r\n</code></pre>\r\n继续看结果：\r\nPerson::__set_state(array( \'sex\' =&gt; \'男\', \'name\' =&gt; \'小红\', \'age\' =&gt; 25, ))<br />\r\n\r\n<strong>十四、 __clone()，当对象复制完成时调用</strong><br />\r\n\r\n在多数情况下，我们并不需要完全复制一个对象来获得其中属性。但有一个情况下确实需要：如果你有一个 GTK 窗口对象，该对象持有窗口相关的资源。你可能会想复制一个新的窗口，保持所有属性与原来的窗口相同，但必须是一个新的对象（因为如果不是新的对象，那么一个窗口中的改变就会影响到另一个窗口）。还有一种情况：如果对象 A 中保存着对象 B 的引用，当你复制对象 A 时，你想其中使用的对象不再是对象 B 而是 B 的一个副本，那么你必须得到对象 A 的一个副本。\r\n作用：\r\n对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法）。对象中的 __clone() 方法不能被直接调用。\r\n语法：\r\n$copy_of_object = clone $object;<br />\r\n\r\n注意：\r\n当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。\r\n当复制完成时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的 __clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。<br />\r\n看代码：\r\n<pre><code>\r\n\r\n&lt;&#63;php\r\nclass Person\r\n{\r\n  public $sex;\r\n  public $name;\r\n  public $age;\r\n\r\n  public function __construct($name=\"\", $age=25, $sex=\'男\')\r\n  {\r\n    $this-&gt;name = $name;\r\n    $this-&gt;age = $age;\r\n    $this-&gt;sex = $sex;\r\n  }\r\n\r\n  public function __clone()\r\n  {\r\n    echo __METHOD__.\"你正在克隆对象&lt;br&gt;\";\r\n  }\r\n\r\n}\r\n\r\n$person = new Person(\'小明\'); // 初始赋值\r\n$person2 = clone $person;\r\n\r\nvar_dump(\'persion1:\');\r\nvar_dump($person);\r\necho \'&lt;br&gt;\';\r\nvar_dump(\'persion2:\');\r\nvar_dump($person2);\r\n\r\n</code></pre>\r\n看结果：\r\nPerson::__clone你正在克隆对象<br />\r\nstring(9) \"persion1:\" object(Person)#1 (3) { [\"sex\"]=&gt; string(3) \"男\" [\"name\"]=&gt; string(6) \"小明\" [\"age\"]=&gt; int(25) } <br />\r\nstring(9) \"persion2:\" object(Person)#2 (3) { [\"sex\"]=&gt; string(3) \"男\" [\"name\"]=&gt; string(6) \"小明\" [\"age\"]=&gt; int(25) }<br />\r\n\r\n克隆成功。\r\n<strong>十五、__autoload()，尝试加载未定义的类</strong><br />\r\n\r\n作用：\r\n你可以通过定义这个函数来启用类的自动加载。<br />\r\n\r\n在魔术函数 __autoload() 方法出现以前，如果你要在一个程序文件中实例化100个对象，那么你必须用include或者require包含进来100个类文件，或者你把这100个类定义在同一个类文件中 —— 相信这个文件一定会非常大，然后你就痛苦了。\r\n但是有了 __autoload() 方法，以后就不必为此大伤脑筋了，这个类会在你实例化对象之前自动加载制定的文件。\r\n还是通过例子来看看吧：\r\n先看看以往的方式：\r\n<pre><code>\r\n\r\n/** \r\n * 文件non_autoload.php \r\n */ \r\n  \r\nrequire_once(\'project/class/A.php\'); \r\nrequire_once(\'project/class/B.php\'); \r\nrequire_once(\'project/class/C.php\'); \r\n  \r\nif (条件A) { \r\n  $a = new A(); \r\n  $b = new B(); \r\n  $c = new C(); \r\n  // … 业务逻辑 \r\n} else if (条件B) { \r\n  $a = newA(); \r\n  $b = new B(); \r\n  // … 业务逻辑 \r\n}\r\n</code></pre>\r\n看到了吗？不用100个，只是3个看起来就有点烦了。而且这样就会有一个问题：如果脚本执行“条件B”这个分支时，C.php这个文件其实没有必要包含。因为，任何一个被包含的文件，无论是否使用，均会被php引擎编译。如果不使用，却被编译，这样可以被视作一种资源浪费。更进一步，如果C.php包含了D.php，D.php包含了E.php。并且大部分情况都执行“条件B”分支，那么就会浪费一部分资源去编译C.php,D.php,E.php三个“无用”的文件。\r\n那么如果使用 __autoload() 方式呢？\r\n<pre><code>\r\n\r\n/** \r\n * 文件autoload_demo.php \r\n */ \r\nfunction __autoload($className) { \r\n  $filePath = “project/class/{$className}.php”; \r\n  if (is_readable($filePath)) { \r\n    require($filePath); \r\n  } \r\n} \r\n  \r\nif (条件A) { \r\n  $a = new A(); \r\n  $b = new B(); \r\n  $c = new C(); \r\n  // … 业务逻辑 \r\n} else if (条件B) { \r\n  $a = newA(); \r\n  $b = new B(); \r\n  // … 业务逻辑 \r\n}\r\n</code></pre>\r\nok,不论效率怎么用，最起码界面看起来舒服多了，没有太多冗余的代。\r\n再来看看这里的效率如何，我们分析下：\r\n当php引擎第一次使用类A，但是找不到时，会自动调用 __autoload 方法，并将类名“A”作为参数传入。所以，我们在 __autoload() 中需要的做的就是根据类名，找到相应的文件，并包含进来，如果我们的方法也找不到，那么php引擎就会报错了。\r\n注意：\r\n这里可以只用require，因为一旦包含进来后，php引擎再遇到类A时，将不会调用__autoload，而是直接使用内存中的类A，不会导致多次包含。<br />\r\n\r\n扩展：\r\n其实php发展到今天，已经有将 `spl_autoload_register` — 注册给定的函数作为 __autoload 的实现了，但是这个不在啊本文讲解之内，有兴趣可以自行看手册。<br />\r\n\r\n<strong>十六、__debugInfo()，打印所需调试信息<br />\r\n</strong>\r\n注意：\r\n该方法在PHP 5.6.0及其以上版本才可以用，如果你发现使用无效或者报错，请查看啊你的版本。<br />\r\n\r\n看代码：\r\n<pre><code>\r\n\r\n&lt;&#63;php\r\nclass C {\r\n  private $prop;\r\n\r\n  public function __construct($val) {\r\n    $this-&gt;prop = $val;\r\n  }\r\n\r\n  /**\r\n   * @return array\r\n   */\r\n  public function __debugInfo() {\r\n    return [\r\n      \'propSquared\' =&gt; $this-&gt;prop ** 2,\r\n    ];\r\n  }\r\n}\r\n\r\nvar_dump(new C(42));\r\n\r\n</code></pre>\r\n结果：\r\nobject(C)#1 (1) { [\"propSquared\"]=&gt; int(1764) }<br />\r\n\r\n再次注意：\r\n这里的 `**` 是乘方的意思，也是在PHP5.6.0及其以上才可以使用，详情请查看PHP手册', '2018-03-25 14:55:00', '脚本之家', 'http://www.jb51.net/article/96167.htm'),
(127, 'sqlserver查询数据的所有表名和行数', '錒飛', 'SQL', '<pre><code>//查询所有表明 select name from sysobjects where xtype=\'u\'\r\n\r\nselect * from sys.tables\r\n //查询数据库中所有的表名及行数\r\n\r\nSELECT a.name, b.rows\r\n\r\nFROM sysobjects AS a INNER JOIN sysindexes AS b ON a.id = b.id\r\n\r\nWHERE (a.type = \'u\') AND (b.indid IN (0, 1))\r\n\r\nORDER BY a.name,b.rows DESC\r\n\r\n //查询所有的标明及空间占用量\\行数\r\n\r\nselect\r\n\r\nobject_name(id) tablename,\r\n\r\n8*reserved/1024 reserved,\r\n\r\nrtrim(8*dpages)+\'kb\' used,\r\n\r\n8*(reserved-dpages)/1024 unused,\r\n\r\n8*dpages/1024-rows/1024*minlen/1024 free,\r\n\r\nrows\r\n\r\n--,*\r\n\r\nfrom sysindexes\r\n\r\nwhere indid=1\r\n\r\norder by tablename,reserved desc</code></pre>', '2018-03-26 09:49:00', '博客园', 'https://www.cnblogs.com/aflyfly/p/5822199.html'),
(128, '收购 Github，微软的又一次大转变', '36氪', 'news', '微软斥资75亿美元全面收购代码托管和协作网站GitHub，背后并不只是投入资金那么简单：如果微软把这件事搞砸了，它就有可能失去近年来与开发者建立起来的良好关系。 \r\n当然，任何收购都是有风险的。GitHub不仅仅是另一个编程工具。它是开源社区的核心，某种程度上是社交网络和项目管理工具之间的交叉点。它是迄今为止同类网站中最大的。无数公司和组织在它上面托管了开源软件项目，包括苹果、亚马逊、Facebook、谷歌、沃尔玛和美国政府。据微软称，GitHub拥有2800万用户，8500万个代码库。它还为许多付费使用其私人托管服务的公司提供专有代码和内部通信服务。 \r\n这项交易，是微软将自己定位为开放源代码拥护者的一系列举措中的最新一项。近年来，它发布了自己的开源编程语言和工具，帮助将开源软件引入到Windows平台上，并开始在其云平台Azure上支持、甚至使用Linux。所有这些都是为了帮助吸引开发者到Azure，收购GitHub的决定正好符合这种模式。交易达成后，微软可以将GitHub和Azure更紧密地联系在一起，以鼓励开发者在公司的云服务上运行他们的应用程序。 \r\n“这是为了更好地接触2600万名开发者，了解他们在关注什么，”编程教育网站Freecodecamp的创始人昆西·拉尔森（Quincy Larson）说。 \r\n与此同时，如果将GitHub与Azure联系得太紧密，可能会疏远与来自谷歌、亚马逊等竞争对手云平台合作的开发者。 \r\n微软还有其他潜在优势。RedMonk分析师斯蒂芬·奥格雷迪（Stephen O\'Grady）指出，GitHub拥有大量关于开发人员及其项目的数据。拉尔森建议，微软可以挖掘GitHub，找到精通特定语言或技术的程序员，并将这些数据与微软2016年收购的LinkedIn整合，以帮助LinkedIn的招聘客户发掘编程人才。 \r\n微软对GitHub的兴趣，反映了该公司和行业的巨大变化。开源不再是边缘的了，它是任何科技公司做生意的核心部分。一些开发者还记得微软的前首席执行官史蒂夫·鲍尔默（Steve Ballmer）在2001年称Linux为“癌症”，2007年微软威胁要起诉Red Hat等Linux公司。如果微软疏远了GitHub用户，使其更难使用竞争对手的产品，可能会让微软的形象重新回到黑暗时代。 \r\n开源开发者已经看到，当一个流行的托管平台易手时会发生什么糟糕的事情。在GitHub之前，Sourceforge是最著名的开源项目托管平台。2012年，Sourceforge被职业服务公司DHI Holdings收购，DHI Holdings是求职网站Dice.com的所有者。用户很快就开始抱怨，网站上贴满了广告，其中有许多广告都在试图欺骗用户下载他们不想要的软件。2015年，该公司更进一步，开始将一些用户称之为广告软件或恶意软件的内容，捆绑到该公司认为“已放弃”的托管项目的下载中。虽然DHI很快停止了这种做法，但是伤害已经造成了；许多优质的项目离开了这个网站。2016年，DHI将Sourceforge卖给了Bizx。 \r\n一些GitHub用户并没有等待微软要怎么做。芬兰的开源软件开发者安德烈·麦迪罗斯（Andre Medeiros）目前正在帮助建立一个名为“ScuttleButt”的P2P社交网络，他说，他已经开始将自己的一些代码从GitHub转移到竞争对手GitLab上了。最后，麦迪罗斯说，他希望转向P2P解决方案，比如 ScuttleButt 或 Dat。 \r\n“GitHub一直是中立的平台，只与类似的服务进行竞争，例如BitBucket和GitLab，”他说。但他指出，微软与云计算公司、网络浏览器制造商和许多其他公司都存在竞争。“我担心GitHub不会再保持中立了。” \r\nGitLab表示，在传出微软将收购GitHub的消息后，在周日的时候，项目输入增加了10倍。但似乎大多数公司都愿意给微软一个不确定的好处，至少目前是这样的。 \r\n捷克开发者工具公司JetBrains销售的产品与微软自己的编程工具系列存在竞争关系，但其不打算将其开源项目从GitHub转移出去。“通过这项收购行动，微软宣布将继续担任 GitHub 社区的管理者，并将继续支持开放和协作，”JetBrains的副总裁开发者哈迪·哈里里(Hadi Hariri)说，“只要他们尊重这一点，我们就不会预见到任何问题，不管JetBrains和微软是否在其他领域有竞争。” \r\n微软则声称GitHub将继续独立运作。首席执行官萨蒂亚·纳德拉（Satya Nadella）在关于收购的博客文章中写道:“我们认识到我们对这项协议所承担的责任。我们致力于成为GitHub社区的管理者，它将保持开发者至上的精神，独立运作，并保持开放。我们将始终听取开发者的反馈，并在基础设施和新功能方面进行投资。” \r\n奥格雷迪说，克制的反应与纳德拉有很大关系。纳德拉自2014年接手以来，一直帮助微软将自己定位为一家不太关心Windows销售最大化的公司，更关心的是在各种不同平台上运行的产品。 \r\nFreecodecamp的创始人拉尔森表示，他打算留下来，因为离开GitHub，将意味着失去让GitHub如此有用的网络效应，并迫使他公布代码和其他文件的新位置，并培训开发者使用新的工作流程。他认为，在可预见的将来，这将使大多数开发者留在GitHub上。 \r\n但如果他们不满意，他们最终就会离开。看看Sourceforge发生了什么，就知道了。 \r\n附萨蒂亚·纳德拉发表在微软官方博客的文章： 微软+GitHub=为开发者赋能\r\n<img src=\"http://5b0988e595225.cdn.sohucs.com/images/20180605/728d72c411be4a10a8763005678a48a4.jpeg\" /> \r\n今天，我们宣布了收购全球领先的软件开发平台GitHub的协议。我想与大家分享这次收购对我们的行业和开发者意味着什么。\r\n智能云和智能边缘的时代即将来临。计算正在嵌入世界的每一个角落，我们日常生活和工作的每一部分，以及我们社会和经济的各个方面，都在被数字技术改变。 \r\n开发者是这个新时代的建设者，他们正在编写这个世界的代码。而GitHub就是他们的家。 \r\n由于每个行业——从精准医学到精细农业、从个性化教育到个性化银行——都会受到技术的影响，开发者社区将会变得更多，更重要。开发者的工作流程将推动并影响到整个组织的业务流程与功能，从营销、销售和服务到IT和人力资源。每个行业的价值创造和增长，将越来越多地取决于开发者的选择。 \r\n简而言之，开发者将成为解决世界上最紧迫的挑战的中坚力量。不过，真正的力量来自于每个开发者能够一起创建、协作、共享代码并在彼此工作的基础上进行构建。在各行各业中，我们都看到了社区的力量，对于软件开发和开发者来说也是如此。 \r\n这就是我们对今天的宣布如此激动的原因。已经有超过2800万开发人员在GitHub上进行协作，这里拥有超过8500万个代码库，几乎在每个国家都有人在使用。从最大的公司到最小的创业公司，GitHub都是开发者学习、共享和协作创建软件的目的地。这也是微软的目的地。我们是GitHub上最活跃的组织，对相关的项目进行了200多万次的“提交”或更新。 \r\n从我们创建的第一个产品到我们今天提供的平台和工具，微软一直是一家以开发者为中心的公司。构建技术方案以帮助他人打造技术成果是我们的核心使命，我们也会立足于此，帮助世界上的每一个人和每个组织取得更多的成就。 \r\n微软还致力于赋予社区权力，从世界上的专业人士到IT专业人士再到游戏玩家。我们相信社区的力量远远超过其成员自己所能做到的。正是我们的共同努力，帮助我们的梦想成为现实，我们致力于培养和发展社区来实现这一目标。 \r\n微软是开源的。我们已经开始了开源之旅。今天，我们在开源生态系统中非常活跃，我们为开源项目做出了很多贡献，我们最有活力的开发工具和框架是开源的。谈到我们对开源的承诺，大家可以从我们的过去、今天和未来的行动来一起见证。 \r\n基于这一切，加上GitHub，我们看到了三个明显的机遇。 \r\n首先，我们将在开发生命周期的每个阶段增强开发者的能力，从构思到协作，再到部署到云。接下来，GitHub 仍将是一个开放的平台，任何开发人员都可以插入和扩展。开发者将能够继续为他们的项目使用自己选择的编程语言、工具和操作系统，并且仍然能够在任何云和任何设备上部署他们的代码。 \r\n其次，我们将通过我们的直销和合作伙伴渠道，以及对微软全球云基础设施和服务的访问，加快企业开发者对GitHub的使用。 \r\n最后，我们将把微软的开发工具和服务带给新的用户。 \r\n最重要的是，我们认识到我们对这项协议所承担的责任。我们致力于成为GitHub社区的管理者，它将保持开发者至上的精神，独立运作，并保持开放。我们将始终听取开发人员的反馈，并在基础设施和新功能方面进行投资。 \r\n一旦收购在今年晚些时候结束，GitHub将由开源资深人士、Xamarin创始人兼首席执行官纳特?弗里德曼（Nat Friedman）领导，他将继续向微软云+人工智能集团执行副总裁斯科特·格思里（Scott Guthrie）汇报；GitHub首席执行官兼联合创始人克里斯·万斯特拉奇（Chris Wanstrath）将是微软的技术人员，也向斯科特汇报工作。你可以在这个公开演讲（点击查看，内有24张PPT）中看到克里斯、纳特和我如何展望未来的机遇。 \r\n我们将共同推动GitHub成为一个深受开发者喜爱和组织信任的平台。 ', '2018-06-05 15:00:00', '搜狐', 'http://www.sohu.com/a/234124621_114778'),
(129, '网站安全的重要性', '墨迹', 'baike', '安全问题一直是企业网站建设及IDC行业的梦魇，一方面网站主机黑链及被挂马问题屡禁不止，另一方面很多大型的IDC服务商的域名DNS解析服务器也屡遭攻击，每次都带来数以万计的域名无法正常使用。\r\n　\r\n但作为网站营销转化的基础保障，网站的安全运行绝对不容忽视。对于那些大规模开展网络营销的企业，每一分钟都会有人不断的访问浏览网站，哪怕是中断一两分钟，其造成的损失都是巨大的。用个例子就可以轻松感知网站安全运行的重要性，如果在网站的访问高峰期，哪怕是几分钟的中断，都会带来数以千万计的损失。中小公司的网站访问量当然没有那么大，但是如果网站经常出现运行故障，其也会带来一定损失的。\r\n\r\n一个网站不能安全稳定运行，对用户体验和网站建设营销转化是一个障碍，对于搜索引擎认知也是一种障碍。当搜索蜘蛛每次过来爬行的时候，网站页面都无法打开或者打开速度非常慢的话，久而久之网站在搜索引擎上的权重和质量都会带来不同程度的下滑，而且这也会影响网站流量以及营销转换。由此可见，企业网站建设的安全稳定运行是多么重要。\r\n\r\n那么，怎样才能提升网站的安全性呢?除去不断通过技术方法增强网站主机的安全性能之外，从思想上予以重视是确保网站安全运行不可或缺的条件之一。\r\n\r\n广告联盟评测现在很多网站建设制作都是采用开源的CMS，因为开源程序不用花钱购买，而且性能也不错。开源系统本身是没有什么过错的，问题就在于开源产品代码思路都是公开的，如果不加修改的直接应用无疑将安全问题曝之于众。而且有些看似开源的网站程序，其实已经被二次修改植入后门程序。这样的代码程序应用在企业网站建设中，其安全性能可想而知。之所以如此表述，其目的在于表达网站程序也是构成网站安全运行的一个很重要的因素。在实践操作过程中，我们也发现大部分网站程序安全问题出现在上传组件上，攻击者遍历网站程序后，上传ASP或者PHP等后门程序，进行篡改网站信息或者挂马挂黑链。如果不是必须，建议直接关闭或者删除网站程序中的上传组件，这样等于斩断了攻击的后路。', '2018-03-26 20:28:00', '新浪博客', 'http://blog.sina.com.cn/s/blog_62a275f80102ws5b.html');
INSERT INTO `wu_blog` (`id`, `post_title`, `post_author`, `post_type`, `post_content`, `post_date`, `post_from`, `post_link`) VALUES
(130, 'Js获取当前日期时间及其它操作', 'Jacklovely', 'JS', 'Js获取当前日期时间及其它操作\r\nvar myDate = new Date();<br />myDate.getYear();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取当前年份(2位)<br />myDate.getFullYear();&nbsp;&nbsp;&nbsp;&nbsp;//获取完整的年份(4位,1970-????)<br />myDate.getMonth();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取当前月份(0-11,0代表1月)<br />myDate.getDate();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取当前日(1-31)<br />myDate.getDay();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取当前星期X(0-6,0代表星期天)<br />myDate.getTime();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取当前时间(从1970.1.1开始的毫秒数)<br />myDate.getHours();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取当前小时数(0-23)<br />myDate.getMinutes();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取当前分钟数(0-59)<br />myDate.getSeconds();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取当前秒数(0-59)<br />myDate.getMilliseconds();&nbsp;&nbsp;&nbsp;&nbsp;//获取当前毫秒数(0-999)<br />myDate.toLocaleDateString();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取当前日期<br />var mytime=myDate.toLocaleTimeString();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取当前时间<br />myDate.toLocaleString( );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取日期与时间\r\n&nbsp;\r\n<a href=\"http://www.cnblogs.com/carekee/admin/file::;\" target=\"_blank\"><span style=\"text-decoration: underline;\"><strong><span style=\"color: #6d5887;\">日期时间</span></strong></span></a>脚本库方法列表\r\n<a href=\"http://www.cnblogs.com/carekee/admin/file::;\" target=\"_blank\"><span style=\"text-decoration: underline;\"><strong><span style=\"color: #6d5887;\">Date</span></strong></span></a>.prototype.isLeapYear 判断闰年<br />Date.prototype.Format 日期格式化<br />Date.prototype.DateAdd 日期计算<br />Date.prototype.DateDiff 比较日期差<br />Date.prototype.toString 日期转字符串<br />Date.prototype.toArray 日期分割为数组<br />Date.prototype.DatePart 取日期的部分信息<br />Date.prototype.MaxDayOfDate 取日期所在月的最大<a href=\"http://www.cnblogs.com/carekee/admin/file::;\" target=\"_blank\"><span style=\"text-decoration: underline;\"><strong><span style=\"color: #6d5887;\">天数</span></strong></span></a><br />Date.prototype.WeekNumOfYear 判断日期所在年的第几周<br />StringToDate 字符串转日期型<br />IsValidDate 验证日期有效性<br />CheckDateTime 完整日期时间检查<br />daysBetween 日期天数差\r\njs代码：\r\n//---------------------------------------------------&nbsp;&nbsp;<br />// 判断闰年&nbsp;&nbsp;<br />//---------------------------------------------------&nbsp;&nbsp;<br />Date.prototype.isLeapYear = function()&nbsp;&nbsp;&nbsp;<br />{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return (0==this.getYear()%4&amp;&amp;((this.getYear()%100!=0)||(this.getYear()%400==0)));&nbsp;&nbsp;&nbsp;<br />}&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />//---------------------------------------------------&nbsp;&nbsp;<br />// 日期格式化&nbsp;&nbsp;<br />// 格式 YYYY/yyyy/YY/yy 表示年份&nbsp;&nbsp;<br />// MM/M 月份&nbsp;&nbsp;<br />// W/w 星期&nbsp;&nbsp;<br />// dd/DD/d/D 日期&nbsp;&nbsp;<br />// hh/HH/h/H 时间&nbsp;&nbsp;<br />// mm/m 分钟&nbsp;&nbsp;<br />// ss/SS/s/S 秒&nbsp;&nbsp;<br />//---------------------------------------------------&nbsp;&nbsp;<br />Date.prototype.Format = function(formatStr)&nbsp;&nbsp;&nbsp;<br />{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var str = formatStr;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var Week = [\'日\',\'一\',\'二\',\'三\',\'四\',\'五\',\'六\'];&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;str=str.replace(/yyyy|YYYY/,this.getFullYear());&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;str=str.replace(/yy|YY/,(this.getYear() % 100)&gt;9?(this.getYear() % 100).toString():\'0\' + (this.getYear() % 100));&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;str=str.replace(/MM/,this.getMonth()&gt;9?this.getMonth().toString():\'0\' + this.getMonth());&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;str=str.replace(/M/g,this.getMonth());&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;str=str.replace(/w|W/g,Week[this.getDay()]);&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;str=str.replace(/dd|DD/,this.getDate()&gt;9?this.getDate().toString():\'0\' + this.getDate());&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;str=str.replace(/d|D/g,this.getDate());&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;str=str.replace(/hh|HH/,this.getHours()&gt;9?this.getHours().toString():\'0\' + this.getHours());&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;str=str.replace(/h|H/g,this.getHours());&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;str=str.replace(/mm/,this.getMinutes()&gt;9?this.getMinutes().toString():\'0\' + this.getMinutes());&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;str=str.replace(/m/g,this.getMinutes());&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;str=str.replace(/ss|SS/,this.getSeconds()&gt;9?this.getSeconds().toString():\'0\' + this.getSeconds());&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;str=str.replace(/s|S/g,this.getSeconds());&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return str;&nbsp;&nbsp;&nbsp;<br />}&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />//| 求两个时间的天数差 日期格式为 YYYY-MM-dd&nbsp;&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />function daysBetween(DateOne,DateTwo)&nbsp;&nbsp;<br />{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var OneMonth = DateOne.substring(5,DateOne.lastIndexOf (\'-\'));&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var OneDay = DateOne.substring(DateOne.length,DateOne.lastIndexOf (\'-\')+1);&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var OneYear = DateOne.substring(0,DateOne.indexOf (\'-\'));&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var TwoMonth = DateTwo.substring(5,DateTwo.lastIndexOf (\'-\'));&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var TwoDay = DateTwo.substring(DateTwo.length,DateTwo.lastIndexOf (\'-\')+1);&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var TwoYear = DateTwo.substring(0,DateTwo.indexOf (\'-\'));&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var cha=((Date.parse(OneMonth+\'/\'+OneDay+\'/\'+OneYear)- Date.parse(TwoMonth+\'/\'+TwoDay+\'/\'+TwoYear))/86400000);&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return Math.abs(cha);&nbsp;&nbsp;<br />}&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />//| 日期计算&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />Date.prototype.DateAdd = function(strInterval, Number) {&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var dtTmp = this;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;switch (strInterval) {&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'s\' :return new Date(Date.parse(dtTmp) + (1000 * Number));&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'n\' :return new Date(Date.parse(dtTmp) + (60000 * Number));&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'h\' :return new Date(Date.parse(dtTmp) + (3600000 * Number));&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'d\' :return new Date(Date.parse(dtTmp) + (86400000 * Number));&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'w\' :return new Date(Date.parse(dtTmp) + ((86400000 * 7) * Number));&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'q\' :return new Date(dtTmp.getFullYear(), (dtTmp.getMonth()) + Number*3, dtTmp.getDate(), dtTmp.getHours(), dtTmp.getMinutes(), dtTmp.getSeconds());&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'m\' :return new Date(dtTmp.getFullYear(), (dtTmp.getMonth()) + Number, dtTmp.getDate(), dtTmp.getHours(), dtTmp.getMinutes(), dtTmp.getSeconds());&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'y\' :return new Date((dtTmp.getFullYear() + Number), dtTmp.getMonth(), dtTmp.getDate(), dtTmp.getHours(), dtTmp.getMinutes(), dtTmp.getSeconds());&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br />}&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />//| 比较日期差 dtEnd 格式为日期型或者有效日期格式字符串&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />Date.prototype.DateDiff = function(strInterval, dtEnd) {&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var dtStart = this;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;if (typeof dtEnd == \'string\' )//如果是字符串转换为日期型&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtEnd = StringToDate(dtEnd);&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;switch (strInterval) {&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'s\' :return parseInt((dtEnd - dtStart) / 1000);&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'n\' :return parseInt((dtEnd - dtStart) / 60000);&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'h\' :return parseInt((dtEnd - dtStart) / 3600000);&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'d\' :return parseInt((dtEnd - dtStart) / 86400000);&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'w\' :return parseInt((dtEnd - dtStart) / (86400000 * 7));&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'m\' :return (dtEnd.getMonth()+1)+((dtEnd.getFullYear()-dtStart.getFullYear())*12) - (dtStart.getMonth()+1);&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'y\' :return dtEnd.getFullYear() - dtStart.getFullYear();&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br />}&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />//| 日期输出字符串，重载了系统的toString方法&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />Date.prototype.toString = function(showWeek)&nbsp;&nbsp;<br />{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var myDate= this;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var str = myDate.toLocaleDateString();&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;if (showWeek)&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var Week = [\'日\',\'一\',\'二\',\'三\',\'四\',\'五\',\'六\'];&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str += \' 星期\' + Week[myDate.getDay()];&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return str;&nbsp;&nbsp;<br />}&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />//| 日期合法性验证&nbsp;&nbsp;<br />//| 格式为：YYYY-MM-DD或YYYY/MM/DD&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />function IsValidDate(DateStr)&nbsp;&nbsp;&nbsp;<br />{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var sDate=DateStr.replace(/(^\\s+|\\s+$)/g,\'\'); //去两边空格;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;if(sDate==\'\') return true;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//如果格式满足YYYY-(/)MM-(/)DD或YYYY-(/)M-(/)DD或YYYY-(/)M-(/)D或YYYY-(/)MM-(/)D就替换为\'\'&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;//数据库中，合法日期可以是:YYYY-MM/DD(2003-3/21),数据库会自动转换为YYYY-MM-DD格式&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var s = sDate.replace(/[\\d]{ 4,4 }[\\-/]{ 1 }[\\d]{ 1,2 }[\\-/]{ 1 }[\\d]{ 1,2 }/g,\'\');&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;if (s==\'\') //说明格式满足YYYY-MM-DD或YYYY-M-DD或YYYY-M-D或YYYY-MM-D&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var t=new Date(sDate.replace(/\\-/g,\'/\'));&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var ar = sDate.split(/[-/:]/);&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ar[0] != t.getYear() || ar[1] != t.getMonth()+1 || ar[2] != t.getDate())&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//alert(\'错误的日期格式！格式为：YYYY-MM-DD或YYYY/MM/DD。注意闰年。\');&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//alert(\'错误的日期格式！格式为：YYYY-MM-DD或YYYY/MM/DD。注意闰年。\');&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return true;&nbsp;&nbsp;&nbsp;<br />}&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />//| 日期时间检查&nbsp;&nbsp;<br />//| 格式为：YYYY-MM-DD HH:MM:SS&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />function CheckDateTime(str)&nbsp;&nbsp;<br />{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var reg = /^(\\d+)-(\\d{ 1,2 })-(\\d{ 1,2 }) (\\d{ 1,2 }):(\\d{ 1,2 }):(\\d{ 1,2 })$/;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var r = str.match(reg);&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;if(r==null)return false;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;r[2]=r[2]-1;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var d= new Date(r[1],r[2],r[3],r[4],r[5],r[6]);&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;if(d.getFullYear()!=r[1])return false;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;if(d.getMonth()!=r[2])return false;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;if(d.getDate()!=r[3])return false;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;if(d.getHours()!=r[4])return false;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;if(d.getMinutes()!=r[5])return false;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;if(d.getSeconds()!=r[6])return false;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return true;&nbsp;&nbsp;&nbsp;<br />}&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />//| 把日期分割成数组&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />Date.prototype.toArray = function()&nbsp;&nbsp;<br />{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var myDate = this;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var myArray = Array();&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;myArray[0] = myDate.getFullYear();&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;myArray[1] = myDate.getMonth();&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;myArray[2] = myDate.getDate();&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;myArray[3] = myDate.getHours();&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;myArray[4] = myDate.getMinutes();&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;myArray[5] = myDate.getSeconds();&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return myArray;&nbsp;&nbsp;<br />}&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />//| 取得日期数据信息&nbsp;&nbsp;<br />//| 参数 interval 表示数据类型&nbsp;&nbsp;<br />//| y 年 m月 d日 w星期 ww周 h时 n分 s秒&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />Date.prototype.DatePart = function(interval)&nbsp;&nbsp;<br />{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var myDate = this;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var partStr=\'\';&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var Week = [\'日\',\'一\',\'二\',\'三\',\'四\',\'五\',\'六\'];&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;switch (interval)&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'y\' :partStr = myDate.getFullYear();break;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'m\' :partStr = myDate.getMonth()+1;break;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'d\' :partStr = myDate.getDate();break;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'w\' :partStr = Week[myDate.getDay()];break;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'ww\' :partStr = myDate.WeekNumOfYear();break;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'h\' :partStr = myDate.getHours();break;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'n\' :partStr = myDate.getMinutes();break;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case \'s\' :partStr = myDate.getSeconds();break;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return partStr;&nbsp;&nbsp;<br />}&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />//| 取得当前日期所在月的最大天数&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />Date.prototype.MaxDayOfDate = function()&nbsp;&nbsp;<br />{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var myDate = this;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var ary = myDate.toArray();&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var date1 = (new Date(ary[0],ary[1]+1,1));&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var date2 = date1.dateAdd(1,\'m\',1);&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var result = dateDiff(date1.Format(\'yyyy-MM-dd\'),date2.Format(\'yyyy-MM-dd\'));&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return result;&nbsp;&nbsp;<br />}&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />//| 取得当前日期所在周是一年中的第几周&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />Date.prototype.WeekNumOfYear = function()&nbsp;&nbsp;<br />{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var myDate = this;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var ary = myDate.toArray();&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var year = ary[0];&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var month = ary[1]+1;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var day = ary[2];&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;document.write(\'&lt; script language=VBScript\\&gt; \\n\');&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;document.write(\'myDate = Datue(\'\'+month+\'-\'+day+\'-\'+year+\'\') \\n\');&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;document.write(\'result = DatePart(\'ww\', myDate) \\n\');&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;document.write(\' \\n\');&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return result;&nbsp;&nbsp;<br />}&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />//| 字符串转成日期类型&nbsp;&nbsp;&nbsp;<br />//| 格式 MM/dd/YYYY MM-dd-YYYY YYYY/MM/dd YYYY-MM-dd&nbsp;&nbsp;<br />//+---------------------------------------------------&nbsp;&nbsp;<br />function StringToDate(DateStr)&nbsp;&nbsp;<br />{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var converted = Date.parse(DateStr);&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;var myDate = new Date(converted);&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;if (isNaN(myDate))&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//var delimCahar = DateStr.indexOf(\'/\')!=-1?\'/\':\'-\';&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var arys= DateStr.split(\'-\');&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myDate = new Date(arys[0],--arys[1],arys[2]);&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;return myDate;&nbsp;&nbsp;<br />}&nbsp;&nbsp;\r\n&nbsp;\r\n<span style=\"color: #cc0000;\">若要显示:当前日期加时间(如:2009-06-12 12:00)</span>\r\n<span style=\"color: #cc0000;\">function CurentTime()<br />&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var now = new Date();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var year = now.getFullYear();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//年<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var month = now.getMonth() + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//月<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var day = now.getDate();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//日<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var hh = now.getHours();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//时<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var mm = now.getMinutes();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//分<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var clock = year + \"-\";<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(month &lt; 10)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clock += \"0\";<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clock += month + \"-\";<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(day &lt; 10)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clock += \"0\";<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clock += day + \" \";<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(hh &lt; 10)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clock += \"0\";<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clock += hh + \":\";<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mm &lt; 10) clock += \'0\';&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clock += mm;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(clock);&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;}</span>&nbsp;</div>', '2018-03-27 13:16:00', '博客园', 'https://www.cnblogs.com/Jacklovely/p/5888281.html'),
(131, 'sizzle引擎研究', 'foio', 'baike', '什么是sizzle？下面时官方的一段解释。\n<pre><code class=\"language-\" data-lang=\"\">A pure-javascript CSS selector engine\n× Standalone(no dependencies)\n× Competitive performance\n× Only 4kB with gzipped\n× Easy to use\n× Css3 support\n× Bla bla ……\n</code></pre>\n其实说白了，sizzle就是一个很给力的选择器解析引擎。\n\n我们为什么需要sizzle呢？其实对现代浏览器来说，document.querySelectorAll就可以解决一切。比如zeptoJs就是用querySelectorAll进行选择器解析的，因为移动端所有浏览器都支撑querySelectorAll。但是对于低版本的IE(&lt;=8)浏览器，不仅不支持querySelectorAll，连getElementById都有bug，因此自己用浏览器原生API解析选择器简直难上加难。好在sizzle引擎帮我们处理了一切。知其然，更要知其所以然。下面让我们看看sizzle引擎内部时如何实现的。\n\nsizzle解析器的主要有以下几个工作步骤。\n\n<figure>\n        <img src=\"http://foio.github.io/images/sizzle-step.jpg\"/>\n</figure>\n\n接下来我们就依次解析。为了简单，我们在接下来的文章中都使用选择器<code>div input[name=ttt]</code>作为例子。\n\n<h3 id=\"1\">1.词法分析</h3>\n\n<hr>\n\n词法分析是指我们将文本代码解析为一个个记号(token)，以便后续语法分析使用。\n\n<h4 id=\"1-sizzle-token\">(1) sizzle的token种类</h4>\n\ncss选择器的词法分析相对较为简单，不用通过lex等专业工具，简单的正则表达式就搞定了。下面依次是用于切分分组，层级关系，以及单个元素的正则表达式。\n<pre><code class=\"language-\" data-lang=\"\">分组(,):/^[\\x20\\t\\r\\n\\f]*,[\\x20\\t\\r\\n\\f]*/\n\n层级关系( &gt;+~):/^[\\x20\\t\\r\\n\\f]*([&gt;+~]|[\\x20\\t\\r\\n\\f])[\\x20\\t\\r\\n\\f]*/\n\n单个元素处理:\n        var characterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\"\n        var ID = new RegExp(\"^#(\" + characterEncoding + \")\")\n        var TAG = new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" )\n        var Class = new RegExp( \"^\\\\.(\" + characterEncoding + \")\" )\n</code></pre>\n<h4 id=\"2-token\">(2)从左到右扫描生产token集合</h4>\n\n用正则表达式切分出token的过程，如下代码所示。基本原理就是从左到右扫描，用正则切分。\n<pre><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"c1\">//分组</span>\n  <span class=\"kd\">var</span> <span class=\"nx\">rcomma</span> <span class=\"o\">=</span> <span class=\"sr\">/^</span><span class=\"se\">[\\x</span><span class=\"sr\">20</span><span class=\"se\">\\t\\r\\n\\f]</span><span class=\"sr\">*,</span><span class=\"se\">[\\x</span><span class=\"sr\">20</span><span class=\"se\">\\t\\r\\n\\f]</span><span class=\"sr\">*/</span><span class=\"p\">;</span>\n  <span class=\"c1\">//层级</span>\n  <span class=\"kd\">var</span> <span class=\"nx\">rcombinators</span> <span class=\"o\">=</span>           \n <span class=\"sr\">/^</span><span class=\"se\">[\\x</span><span class=\"sr\">20</span><span class=\"se\">\\t\\r\\n\\f]</span><span class=\"sr\">*</span><span class=\"se\">([</span><span class=\"sr\">&gt;+~</span><span class=\"se\">]</span><span class=\"sr\">|</span><span class=\"se\">[\\x</span><span class=\"sr\">20</span><span class=\"se\">\\t\\r\\n\\f])[\\x</span><span class=\"sr\">20</span><span class=\"se\">\\t\\r\\n\\f]</span><span class=\"sr\">*/</span>\n  <span class=\"c1\">//选择器</span>\n  <span class=\"kd\">var</span> <span class=\"nx\">TAG</span> <span class=\"o\">=</span> <span class=\"sr\">/^</span><span class=\"se\">((?:\\\\</span><span class=\"sr\">.|</span><span class=\"se\">[\\w</span><span class=\"sr\">*-</span><span class=\"se\">]</span><span class=\"sr\">|</span><span class=\"se\">[^\\x</span><span class=\"sr\">00-</span><span class=\"se\">\\x</span><span class=\"sr\">a0</span><span class=\"se\">])</span><span class=\"sr\">+</span><span class=\"se\">)</span><span class=\"sr\">/</span><span class=\"p\">;</span>\n  <span class=\"kd\">var</span> <span class=\"nx\">matchExpr</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n      <span class=\"na\">CLASS</span><span class=\"p\">:</span> <span class=\"sr\">/^</span><span class=\"se\">\\.((?:\\\\</span><span class=\"sr\">.|</span><span class=\"se\">[\\w</span><span class=\"sr\">-</span><span class=\"se\">]</span><span class=\"sr\">|</span><span class=\"se\">[^\\x</span><span class=\"sr\">00-</span><span class=\"se\">\\x</span><span class=\"sr\">a0</span><span class=\"se\">])</span><span class=\"sr\">+</span><span class=\"se\">)</span><span class=\"sr\">/</span><span class=\"p\">,</span>\n      <span class=\"na\">TAG</span><span class=\"p\">:</span> <span class=\"sr\">/^</span><span class=\"se\">((?:\\\\</span><span class=\"sr\">.|</span><span class=\"se\">[\\w</span><span class=\"sr\">*-</span><span class=\"se\">]</span><span class=\"sr\">|</span><span class=\"se\">[^\\x</span><span class=\"sr\">00-</span><span class=\"se\">\\x</span><span class=\"sr\">a0</span><span class=\"se\">])</span><span class=\"sr\">+</span><span class=\"se\">)</span><span class=\"sr\">/</span>\n  <span class=\"p\">};</span>\n  <span class=\"c1\">//扫描</span>\n  <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"nx\">selector</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"c1\">//分组</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">match</span> <span class=\"o\">=</span> <span class=\"nx\">rcomma</span><span class=\"p\">.</span><span class=\"nx\">exec</span><span class=\"p\">(</span><span class=\"nx\">selector</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n          <span class=\"nx\">selector</span> <span class=\"o\">=</span> <span class=\"nx\">selector</span><span class=\"p\">.</span><span class=\"nx\">slice</span><span class=\"p\">(</span><span class=\"nx\">match</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"nx\">length</span><span class=\"p\">)</span>\n          <span class=\"nx\">groups</span><span class=\"p\">.</span><span class=\"nx\">push</span><span class=\"p\">((</span><span class=\"nx\">tokens</span> <span class=\"o\">=</span> <span class=\"p\">[]));</span>\n      <span class=\"p\">}</span>\n      <span class=\"c1\">//层级关系</span>\n      <span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"nx\">match</span> <span class=\"o\">=</span> <span class=\"nx\">rcombinators</span><span class=\"p\">.</span><span class=\"nx\">exec</span><span class=\"p\">(</span><span class=\"nx\">selector</span><span class=\"p\">)))</span> <span class=\"p\">{</span>\n          <span class=\"nx\">matched</span> <span class=\"o\">=</span> <span class=\"nx\">match</span><span class=\"p\">.</span><span class=\"nx\">shift</span><span class=\"p\">();</span>\n          <span class=\"nx\">tokens</span><span class=\"p\">.</span><span class=\"nx\">push</span><span class=\"p\">({</span>\n              <span class=\"na\">value</span><span class=\"p\">:</span> <span class=\"nx\">matched</span><span class=\"p\">,</span>\n              <span class=\"na\">type</span><span class=\"p\">:</span> <span class=\"nx\">match</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"nx\">replace</span><span class=\"p\">(</span><span class=\"nx\">rtrim</span><span class=\"p\">,</span> <span class=\"s2\">\" \"</span><span class=\"p\">)</span>\n          <span class=\"p\">});</span>\n          <span class=\"nx\">selector</span> <span class=\"o\">=</span> <span class=\"nx\">selector</span><span class=\"p\">.</span><span class=\"nx\">slice</span><span class=\"p\">(</span><span class=\"nx\">matched</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">);</span>\n      <span class=\"p\">}</span>\n      <span class=\"c1\">//选择器</span>\n      <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"nx\">type</span> <span class=\"k\">in</span> <span class=\"nx\">matchExpr</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n          <span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"nx\">match</span> <span class=\"o\">=</span> <span class=\"nx\">matchExpr</span><span class=\"p\">[</span><span class=\"nx\">type</span><span class=\"p\">].</span><span class=\"nx\">exec</span><span class=\"p\">(</span><span class=\"nx\">selector</span><span class=\"p\">)))</span> <span class=\"p\">{</span>\n              <span class=\"nx\">matched</span> <span class=\"o\">=</span> <span class=\"nx\">match</span><span class=\"p\">.</span><span class=\"nx\">shift</span><span class=\"p\">();</span>\n              <span class=\"nx\">tokens</span><span class=\"p\">.</span><span class=\"nx\">push</span><span class=\"p\">({</span>\n                  <span class=\"na\">value</span><span class=\"p\">:</span> <span class=\"nx\">matched</span><span class=\"p\">,</span>\n                  <span class=\"na\">type</span><span class=\"p\">:</span> <span class=\"nx\">type</span><span class=\"p\">,</span>\n                  <span class=\"na\">matches</span><span class=\"p\">:</span> <span class=\"nx\">match</span>\n              <span class=\"p\">});</span>\n              <span class=\"nx\">selector</span> <span class=\"o\">=</span> <span class=\"nx\">selector</span><span class=\"p\">.</span><span class=\"nx\">slice</span><span class=\"p\">(</span><span class=\"nx\">matched</span><span class=\"p\">.</span><span class=\"nx\">length</span><span class=\"p\">);</span>\n          <span class=\"p\">}</span>\n      <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n</code></pre>\n最终生成的token集合如下:\n<pre><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"p\">{</span><span class=\"nl\">matches</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">\"div\"</span><span class=\"p\">],</span><span class=\"nx\">type</span><span class=\"err\">:</span> <span class=\"s2\">\"TAG\"</span><span class=\"p\">,</span><span class=\"nx\">value</span><span class=\"err\">:</span> <span class=\"s2\">\"div“ }, \n{matches:[“”], type: \"</span> <span class=\"s2\">\", value: \"</span> <span class=\"s2\">\"},\n{matches: [\"</span><span class=\"nx\">input</span><span class=\"s2\">\"], type: \"</span><span class=\"nx\">TAG</span><span class=\"s2\">\", value: \"</span><span class=\"nx\">input</span><span class=\"s2\">\"}, \n{matches: [\"</span><span class=\"nx\">name</span><span class=\"s2\">\"], type: \"</span><span class=\"nx\">ATTR</span><span class=\"s2\">\", value: \"</span><span class=\"p\">[</span><span class=\"nx\">name</span><span class=\"o\">=</span><span class=\"nx\">ttt</span><span class=\"p\">]</span><span class=\"err\">\"</span><span class=\"p\">}</span>\n</code></pre>\n<h3 id=\"2\">2.过滤函数</h3>\n\n<hr>\n\n过滤函数用于从浏览器dom模型中找到基本符合css选择器的种子集，sizzle针对每一种token都实现一个过滤函数，如下代码所示：\n<pre><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"c1\">//各种类型的token的过滤器，全部返回闭包函数</span>\n<span class=\"nx\">Expr</span><span class=\"p\">.</span><span class=\"nx\">filter</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"na\">ATTR</span>   <span class=\"p\">:</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">,</span> <span class=\"nx\">operator</span><span class=\"p\">,</span> <span class=\"nx\">check</span><span class=\"p\">)</span> <span class=\"p\">{</span><span class=\"k\">return</span> <span class=\"nx\">closure</span><span class=\"p\">}</span>\n    <span class=\"nl\">CHILD</span>  <span class=\"p\">:</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">type</span><span class=\"p\">,</span> <span class=\"nx\">what</span><span class=\"p\">,</span> <span class=\"nx\">argument</span><span class=\"p\">,</span> <span class=\"nx\">first</span><span class=\"p\">,</span> <span class=\"nx\">last</span><span class=\"p\">)</span> <span class=\"p\">{</span><span class=\"k\">return</span> <span class=\"nx\">closure</span><span class=\"p\">}</span>\n    <span class=\"nl\">CLASS</span>  <span class=\"p\">:</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">className</span><span class=\"p\">)</span> <span class=\"p\">{</span><span class=\"k\">return</span> <span class=\"nx\">closure</span><span class=\"p\">}</span>\n    <span class=\"nl\">ID</span>     <span class=\"p\">:</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">id</span><span class=\"p\">)</span> <span class=\"p\">{</span><span class=\"k\">return</span> <span class=\"nx\">closure</span><span class=\"p\">}</span>\n    <span class=\"nl\">PSEUDO</span> <span class=\"p\">:</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">pseudo</span><span class=\"p\">,</span> <span class=\"nx\">argument</span><span class=\"p\">)</span> <span class=\"p\">{</span><span class=\"k\">return</span> <span class=\"nx\">closure</span><span class=\"p\">}</span>\n    <span class=\"nl\">TAG</span>    <span class=\"p\">:</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">nodeNameSelector</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">elem</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">elem</span><span class=\"p\">.</span><span class=\"nx\">nodeName</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">elem</span><span class=\"p\">.</span><span class=\"nx\">nodeName</span><span class=\"p\">.</span><span class=\"nx\">toLowerCase</span><span class=\"p\">()</span> <span class=\"o\">===</span> <span class=\"nx\">nodeNameSelector</span><span class=\"p\">;</span>\n              <span class=\"p\">};</span>\n     <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre>\n通过部分过滤函数，我们可以初步得到符合条件的种子集合。如下图\n\n<figure>\n        <img src=\"http://foio.github.io/images/sizzle-seed.png\"/>\n</figure>\n\n<h3 id=\"3\">3.编译函数</h3>\n\n其实sizzle引擎最难的地方就在编译函数。为什么叫做编译呢？抽象的讲，把高级规则转换成底层实现就叫编译；比如高级语言到机器语言的过程就是编译。同样把抽象的css选择语法转变成具体的匹配函数的过程也是编译。\n<figure>\n        <img src=\"http://foio.github.io/images/sizzle-compile-step.png\"/>\n</figure>\n\n编译的过程还是比较复杂的，其实就是从左到右扫描css选择表达式，并使用与当前token对应的过滤函组合成最终的超级匹配函数。扫描编译的核心步骤是：\n<pre><code class=\"language-\" data-lang=\"\">(1)遇到关系token(+&gt; ~)则依次出栈并根据层级规则合并栈中函数\n(2)其他情况将当前token对应的处理函数压入栈中\n(3)选择器表达式结束后依次出栈并合并栈中函数\n</code></pre>\n很难说清楚，高手常常说一图胜千言，我也把扫描编译css选择表达式<code>div [name=ttt]</code>的过程做成图，希望能够讲清楚。\n\n<figure>\n        <img src=\"http://foio.github.io/images/sizzle-compile-process.png\"/>\n</figure>\n\n现在假设我们已经通过编译获得了最终的超级匹配函数。那么从种子集中找到结果集就比较简单了。\n<pre><code class=\"language-javascript\" data-lang=\"javascript\"><span class=\"k\">for</span> <span class=\"nx\">item</span> <span class=\"k\">in</span> <span class=\"nx\">seed</span>\n      <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nx\">superMatcher</span><span class=\"p\">(</span><span class=\"nx\">item</span> <span class=\"p\">)){</span>\n               <span class=\"nx\">resultSet</span><span class=\"p\">.</span><span class=\"nx\">push</span><span class=\"p\">(</span><span class=\"nx\">item</span><span class=\"p\">);</span>\n      <span class=\"p\">}</span>\n<span class=\"k\">return</span> <span class=\"nx\">resultSet</span><span class=\"p\">;</span>\n</code></pre>', '2018-03-27 14:29:00', '个人博客', 'http://foio.github.io/sizzle-research/'),
(132, 'equals和==的区别', '趙小赵', 'JAVA', '<h3>==：</h3>\r\n== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。\r\n\r\n1、比较的是操作符两端的操作数是否是同一个对象。\r\n2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。\r\n3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：\r\nint a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。\r\n\r\n<h3>equals：</h3>\r\n　　equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。\r\n\r\n　　String s=\"abce\"是一种非常特殊的形式,和new 有本质的区别。它是java中唯一不需要new 就可以产生对象的途径。以String s=\"abce\";形式赋值在java中叫直接量,它是在常量池中而不是象new一样放在压缩堆中。这种形式的字符串，在JVM内部发生字符串拘留，即当声明这样的一个字符串后，JVM会在常量池中先查找有有没有一个值为\"abcd\"的对象,如果有,就会把它赋给当前引用.即原来那个引用和现在这个引用指点向了同一对象,如果没有,则在常量池中新创建一个\"abcd\",下一次如果有String s1 = \"abcd\";又会将s1指向\"abcd\"这个对象,即以这形式声明的字符串,只要值相等,任何多个引用都指向同一对象.\r\n　　而String s = new String(\"abcd\");和其它任何对象一样.每调用一次就产生一个对象，只要它们调用。\r\n\r\n　　也可以这么理解: String str = \"hello\"; 先在内存中找是不是有\"hello\"这个对象,如果有，就让str指向那个\"hello\".如果内存里没有\"hello\"，就创建一个新的对象保存\"hello\". String str=new String (\"hello\") 就是不管内存里是不是已经有\"hello\"这个对象，都新建一个对象保存\"hello\"。\r\n\r\n具体可以看下面的代码：<pre><code>public class test1 {\r\n    public static void main(String[] args) {\r\n        String a = new String(&quot;ab&quot;); // a 为一个引用\r\n        String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样\r\n        String aa = &quot;ab&quot;; // 放在常量池中\r\n        String bb = &quot;ab&quot;; // 从常量池中查找\r\n        if (aa == bb) // true\r\n            System.out.println(&quot;aa==bb&quot;);\r\n        if (a == b) // false，非同一对象\r\n            System.out.println(&quot;a==b&quot;);\r\n        if (a.equals(b)) // true\r\n            System.out.println(&quot;aEQb&quot;);\r\n        if (42 == 42.0) { // true\r\n            System.out.println(&quot;true&quot;);\r\n        }\r\n    }\r\n}</code></pre>\r\n<h3>equals和==的区别</h3>\r\nequals方法最初是在所有类的基类Object中进行定义的，源码是\r\n<pre><code>public boolean equals(Object obj) {\r\n    return (this == obj);\r\n}</code></pre>\r\n　　由equals的源码可以看出这里定义的equals与==是等效的（Object类中的equals没什么区别），不同的原因就在于有些类（像String、Integer等类）对equals进行了重写，但是没有对equals进行重写的类（比如我们自己写的类）就只能从Object类中继承equals方法，其equals方法与==就也是等效的，除非我们在此类中重写equals。\r\n\r\n　　对equals重新需要注意五点：\r\n\r\n　　1   自反性：对任意引用值X，x.equals(x)的返回值一定为true；\r\n　　2   对称性：对于任何引用值x,y,当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true；\r\n　　3   传递性：如果x.equals(y)=true, y.equals(z)=true,则x.equals(z)=true ；\r\n　　4   一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变；\r\n　　5   非空性：任何非空的引用值X，x.equals(null)的返回值一定为false 。\r\n\r\n \r\n\r\nString类对equals的重写如下：<pre><code>public boolean equals(Object anObject) {\r\n    if (this == anObject) {\r\n        return true;\r\n    }\r\n    if (anObject instanceof String) {\r\n        String anotherString = (String)anObject;\r\n        int n = count;\r\n        if (n == anotherString.count) {\r\n        char v1[] = value;\r\n        char v2[] = anotherString.value;\r\n        int i = offset;\r\n        int j = anotherString.offset;\r\n        while (n-- != 0) {\r\n            if (v1[i++] != v2[j++])\r\n            return false;\r\n        }\r\n        return true;\r\n        }\r\n    }\r\n    return false;\r\n    }</code></pre>　另外，\"==\"比\"equals\"运行速度快,因为\"==\"只是比较引用。', '2018-03-27 16:11:00', '博客园', 'https://www.cnblogs.com/zjc950516/p/7877511.html'),
(133, 'java的基本数据类型有八种：', 'Snny Bill', 'JAVA', '1）四种整数类型(byte、short、int、long)：    byte：8 位，用于表示最小数据单位，如文件中数据，-128~127    short：16 位，很少用，-32768 ~ 32767    int：32 位、最常用，-2^31-1~2^31  （21 亿）    long：64 位、次常用    注意事项：    int i=5; // 5 叫直接量（或字面量），即 直接写出的常数。    整数字面量默认都为 int 类型，所以在定义的 long 型数据后面加 L或 l。    小于 32 位数的变量，都按 int 结果计算。    强转符比数学运算符优先级高。见常量与变量中的例子。\r\n\r\n \r\n\r\n2）两种浮点数类型(float、double)：    float：32 位，后缀 F 或 f，1 位符号位，8 位指数，23 位有效尾数。    double：64 位，最常用，后缀 D 或 d，1 位符号位，11 位指数，52 位有效尾    注意事项：    二 进 制 浮 点 数 ： 1010100010=101010001.0*2=10101000.10*2^10（2次方)=1010100.010*2^11(3次方)= . 1010100010*2^1010(10次方)    尾数：  . 1010100010   指数：1010   基数：2    浮点数字面量默认都为 double 类型，所以在定义的 float 型数据后面加F 或 f；double 类型可不写后缀，但在小数计算中一定要写 D 或 X.X    float  的精度没有 long 高，有效位数（尾数）短。    float  的范围大于 long  指数可以很大。    浮点数是不精确的，不能对浮点数进行精确比较。\r\n\r\n \r\n\r\n3）一种字符类型(char)：    char：16 位，是整数类型，用单引号括起来的 1 个字符（可以是一个中文字符），使用 Unicode 码代表字符，0~2^16-1（65535） 。    注意事项：    不能为 0个字符。    转义字符：\\n  换行  \\r  回车  \\t Tab 字符  \\\" 双引号  \\\\ 表示一个\\    两字符 char 中间用“+”连接，内部先把字符转成 int 类型，再进行加法运算，char 本质就是个数！二进制的，显示的时候，经过“处理”显示为字符。\r\n\r\n \r\n\r\n4）一种布尔类型(boolean)：true 真  和 false 假。\r\n\r\n \r\n\r\n5）类型转换：       char-->    自动转换：byte-->short-->int-->long-->float-->double                   强制转换：①会损失精度，产生误差，小数点以后的数字全部舍弃。②容易超过取值范围。\r\n\r\n \r\n\r\n6）记忆：8位：Byte（字节型）          16位：short（短整型）、char（字符型）          32位：int（整型）、float（单精度型/浮点型）          64位：long（长整型）、double（双精度型）          最后一个：boolean(布尔类型', '2018-03-27 16:15:00', '博客园', 'https://www.cnblogs.com/123hll/p/5805040.html');
INSERT INTO `wu_blog` (`id`, `post_title`, `post_author`, `post_type`, `post_content`, `post_date`, `post_from`, `post_link`) VALUES
(134, 'MVC简介', '底云飞', 'baike', '<span style=\"color: red; font-family: simsun; font-size: 12pt\">MVC的全名<span style=\"color: black\">是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，是一种软件设计典范。它是用一种业务逻辑、数据与界面显示分离的方法来组织代码，将众多的业务逻辑聚集到一个部件里面，在需要改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑，达到减少编码的时间。\r\n</span></span><span style=\"color: black; font-family: simsun; font-size: 12pt\">MVC开始是存在于桌面程序中的，<span style=\"color: red\">M是指业务模型，V是指用户界面，C则是控制器<span style=\"color: black\">。\r\n</span></span></span><span style=\"color: red; font-family: simsun; font-size: 12pt\">使用的MVC的目的<span style=\"color: black\">：在于将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。比如Windows系统资源管理器文件夹内容的显示方式，下面两张图中左边为详细信息显示方式，右边为中等图标显示方式，文件的内容并没有改变，改变的是显示的方式。不管用户使用何种类型的显示方式，文件的内容并没有改变，达到M和V分离的目的。\r\n</span></span><img src=\"https://images2015.cnblogs.com/blog/811883/201704/811883-20170423150016288-1962165230.png\" alt=\"\"><img src=\"https://images2015.cnblogs.com/blog/811883/201704/811883-20170423150018179-1077791219.png\" alt=\"\">\r\n	<span style=\"color: black; font-family: simsun; font-size: 12pt\">在网页当中，\r\n</span><span style=\"color: red; font-family: simsun; font-size: 12pt\">V即View视图<span style=\"color: black\">是指用户看到并与之交互的界面。比如由html元素组成的网页界面，或者软件的客户端界面。MVC的好处之一在于它能为应用程序处理很多不同的视图。在视图中其实没有真正的处理发生，它只是作为一种输出数据并允许用户操纵的方式。\r\n</span></span><p style=\"text-align: justify\"><span style=\"color: red; font-family: simsun; font-size: 12pt\">M即model模型<span style=\"color: black\">是指模型表示业务规则。在MVC的三个部件中，模型拥有最多的处理任务。被模型返回的数据是中立的，模型与数据格式无关，这样一个模型能为多个视图提供数据，由于应用于模型的代码只需写一次就可以被多个视图重用，所以减少了代码的重复性。\r\n</span></span><span style=\"color: red; font-family: simsun; font-size: 12pt\">C即controller控制器<span style=\"color: black\">是指控制器接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。\r\n</span></span><span style=\"color: black; font-family: simsun; font-size: 12pt\">下图说明了三者之间的调用关系。\r\n</span><img src=\"https://images2015.cnblogs.com/blog/811883/201704/811883-20170423150019101-1710764799.jpg\" alt=\"\">\r\n	<span style=\"color: black; font-family: simsun; font-size: 12pt\">用户首先在界面中进行人机交互，然后请求发送到控制器，控制器根据请求类型和请求的指令发送到相应的模型，模型可以与数据库进行交互，进行增删改查操作，完成之后，根据业务的逻辑选择相应的视图进行显示，此时用户获得此次交互的反馈信息，用户可以进行下一步交互，如此循环。\r\n</span><span style=\"color: red; font-family: simsun; font-size: 14pt\"><strong>MVC举例一：\r\n</strong></span><span style=\"color: black; font-family: simsun; font-size: 12pt\">最典型的MVC就是<span style=\"color: red\">jsp+servlet+javabean<span style=\"color: black\">模式。\r\n</span></span></span><span style=\"color: black; font-family: simsun; font-size: 12pt\">JavaBean作为模型，既可以作为数据模型来封装业务数据，又可以作为业务逻辑模型来包含应用的业务操作。其中，数据模型用来存储或传递业务数据，而业务逻辑模型接收到控制器传过来的模型更新请求后，执行特定的业务逻辑处理，然后返回相应的执行结果。\r\n</span><span style=\"color: black; font-family: simsun; font-size: 12pt\">JSP作为表现层，负责提供页面为用户展示数据，提供相应的表单（Form）来用于用户的请求，并在适当的时候（点击按钮）向控制器发出请求来请求模型进行更新。\r\n</span><span style=\"color: black; font-family: simsun; font-size: 12pt\">Serlvet作为控制器，用来接收用户提交的请求，然后获取请求中的数据，将之转换为业务模型需要的数据模型，然后调用业务模型相应的业务方法进行更新，同时根据业务执行结果来选择要返回的视图。\r\n</span><span style=\"color: red; font-family: simsun; font-size: 14pt\"><strong>MVC举例二：\r\n</strong></span><span style=\"color: red; font-family: simsun; font-size: 12pt\"><strong>Struts2框架</strong><span style=\"color: black\">：Struts2是基于MVC的轻量级的web应用框架。Struts2的应用范围是Web应用，注重将Web应用领域的日常工作和常见问题抽象化，提供一个平台帮助快速的完成Web应用开发。基于Struts2开发的Web应用自然就能实现MVC，Struts2着力于在MVC的各个部分为开发提供相应帮助。\r\n</span></span><span style=\"color: black; font-family: simsun; font-size: 12pt\">下面通过代码来简单解释一下：\r\n</span><span style=\"color: red; font-family: simsun; font-size: 12pt\"><strong>Login.html\r\n</strong></span><img src=\"https://images2015.cnblogs.com/blog/811883/201704/811883-20170423150020772-152288202.png\" alt=\"\">\r\n	<span style=\"color: red; font-family: simsun; font-size: 12pt\"><strong>Login.java\r\n</strong></span><img src=\"https://images2015.cnblogs.com/blog/811883/201704/811883-20170423150022585-260102857.png\" alt=\"\">\r\n	<span style=\"color: red; font-family: simsun; font-size: 12pt\"><strong>Struts.xml\r\n</strong></span><img src=\"https://images2015.cnblogs.com/blog/811883/201704/811883-20170423150024054-862649928.png\" alt=\"\">\r\n	<span style=\"color: black; font-family: simsun; font-size: 12pt\">用户首先在Login.html中输入用户名和密码，点击登陆，此时根据action的路径，在struts.xml中找到对应的Login，然后根据对应的class的路径进入相应的login.Java，在这里判断之后，返回success或error，然后根据struts.xml中的result值，指向相应的jsp页面。\r\n</span><img src=\"https://images2015.cnblogs.com/blog/811883/201704/811883-20170423150024694-1439613206.jpg\" alt=\"\"><span style=\"color: black\">\r\n		</span><span style=\"color: red; font-family: simsun; font-size: 12pt\"><strong>控制器——filterdispatcher\r\n</strong></span><span style=\"color: black; font-family: simsun; font-size: 12pt\">从上面这张图来看，用户请求首先到达前端控制器FilterDispatcher。FilterDispatcher负责根据用户提交的URL和struts.xml中的配置，来选择合适的动作(Action)，让这个Action来处理用户的请求。FilterDispatcher其实是一个过滤器（Filter，servlet规范中的一种web组件），它是Struts2核心包里已经做好的类，不需要我们去开发，只是要在项目的web.xml中配置一下即可。FilterDispatcher体现了J2EE核心设计模式中的前端控制器模式。\r\n</span><span style=\"color: red; font-family: simsun; font-size: 12pt\"><strong>动作——Action\r\n</strong></span><span style=\"font-family: simsun; font-size: 12pt\"><span style=\"color: black\">在用户请求经过FilterDispatcher之后，被分发到了合适的动作Action对象。Action负责把用户请求中的参数组装成合适的数据模型，并调用相应的业务逻辑进行真正的功能处理，获取下一个视图展示所需要的数据。Struts2的Action，相比于别的web框架的动作处理，它实现了与Servlet API的解耦，使得Action里面不需要再直接去引用和使用HttpServletRequest与HttpServletResponse等接口。因而使得Action的单元<a href=\"http://lib.csdn.net/base/softwaretest\" target=\"_blank\" title=\"软件测试知识库\"></a></span><a href=\"http://lib.csdn.net/base/softwaretest\" target=\"_blank\" title=\"软件测试知识库\">测试<span style=\"color: black\">更加简单，而且强大的类型转换也使得我们少做了很多重复的工作。\r\n</span></a></span><a href=\"http://lib.csdn.net/base/softwaretest\" target=\"_blank\" title=\"软件测试知识库\"><span style=\"color: red; font-family: simsun; font-size: 12pt\"><strong>视图——Result\r\n</strong></span></a><a href=\"http://lib.csdn.net/base/softwaretest\" target=\"_blank\" title=\"软件测试知识库\"><span style=\"color: black; font-family: simsun; font-size: 12pt\">视图结果用来把动作中获取到的数据展现给用户。在Struts2中有多种优秀的结果展示方式，常规的jsp，模板freemarker、velocity，还有各种其它专业的展示方式，如图表jfreechart、报表JasperReports、将XML转化为HTML的XSLT等等。而且各种视图结果在同一个工程里面可以混合出现。\r\n</span></a><a href=\"http://lib.csdn.net/base/softwaretest\" target=\"_blank\" title=\"软件测试知识库\"><span style=\"color: red; font-family: simsun; font-size: 14pt\"><strong>MVC举例三：\r\n</strong></span></a><a href=\"http://lib.csdn.net/base/softwaretest\" target=\"_blank\" title=\"软件测试知识库\"><span style=\"color: red; font-family: simsun; font-size: 12pt\"><strong>ASP.NET MVC\r\n</strong></span></a><a href=\"http://lib.csdn.net/base/softwaretest\" target=\"_blank\" title=\"软件测试知识库\"><span style=\"color: black; font-family: simsun; font-size: 12pt\">在visual studio当中新建一个ASP.NET MVC web应用程序，\r\n</span></a><a href=\"http://lib.csdn.net/base/softwaretest\" target=\"_blank\" title=\"软件测试知识库\"><img src=\"https://images2015.cnblogs.com/blog/811883/201704/811883-20170423150026429-418394884.png\" alt=\"\">\r\n	</a><a href=\"http://lib.csdn.net/base/softwaretest\" target=\"_blank\" title=\"软件测试知识库\"><span style=\"color: black; font-family: simsun; font-size: 12pt\">新建完成之后，创建的项目当中即有controllers，models和views，体现了MVC的编程思想。\r\n</span></a><a href=\"http://lib.csdn.net/base/softwaretest\" target=\"_blank\" title=\"软件测试知识库\"><img src=\"https://images2015.cnblogs.com/blog/811883/201704/811883-20170423150028069-1551079684.png\" alt=\"\">\r\n	</a><a href=\"http://lib.csdn.net/base/softwaretest\" target=\"_blank\" title=\"软件测试知识库\"><span style=\"color: red; font-family: simsun; font-size: 16pt\"><strong>MVC的优点：\r\n</strong></span></a><a href=\"http://lib.csdn.net/base/softwaretest\" target=\"_blank\" title=\"软件测试知识库\"><span style=\"color: red; font-family: simsun; font-size: 14pt\"><strong>1.</strong></span></a><strong><a href=\"http://baike.baidu.com/item/%E8%80%A6%E5%90%88%E6%80%A7\">耦合性</a>低\r\n</strong><span style=\"color: black; font-family: simsun; font-size: 12pt\">视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码，同样，一个应用的业务流程或者业务规则的改变只需要改动MVC的模型层即可。因为模型与控制器和视图相分离，所以很容易改变应用程序的数据层和业务规则。\r\n</span><span style=\"color: red; font-family: simsun; font-size: 14pt\"><strong>2.重用性高\r\n</strong></span><a href=\"http://baike.baidu.com/item/MVC%E6%A8%A1%E5%BC%8F\"><span style=\"font-family: simsun; font-size: 12pt\">MVC</span></a><a href=\"http://baike.baidu.com/item/MVC%E6%A8%A1%E5%BC%8F\"><span style=\"font-family: simsun; font-size: 12pt\">模式</span></a><span style=\"color: black; font-family: simsun; font-size: 12pt\">允许使用各种不同样式的视图来访问同一个服务器端的代码，因为多个视图能共享一个模型，它包括任何WEB（HTTP）浏览器或者无线浏览器（wap），比如，用户可以通过电脑也可通过手机来订购某样产品，虽然订购的方式不一样，但处理订购产品的方式是一样的。由于模型返回的数据没有进行格式化，所以同样的构件能被不同的界面使用。\r\n</span><span style=\"color: red; font-family: simsun; font-size: 14pt\"><strong>3.部署快，<a href=\"http://baike.baidu.com/item/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">生命周期</a>成本低\r\n</strong></span><span style=\"color: black; font-family: simsun; font-size: 12pt\">MVC使开发和维护用户<a href=\"http://baike.baidu.com/item/%E6%8E%A5%E5%8F%A3\">接口</a>的技术含量降低。使用MVC模式使开发时间得到相当大的缩减，它使程序员（Java开发人员）集中精力于业务逻辑，界面程序员（HTML和JSP开发人员）集中精力于表现形式上。\r\n</span><span style=\"color: red; font-family: simsun; font-size: 14pt\"><strong>4.可维护性高\r\n</strong></span><span style=\"color: black; font-family: simsun; font-size: 12pt\">分离视图层和业务逻辑层也使得WEB应用更易于维护和修改。\r\n</span><span style=\"color: red; font-family: simsun; font-size: 16pt\"><strong>MVC的缺点：\r\n</strong></span><span style=\"color: red; font-family: simsun; font-size: 14pt\"><strong>1.完全理解MVC比较复杂。\r\n</strong></span><span style=\"color: black; font-family: simsun; font-size: 12pt\">由于MVC模式提出的时间不长，加上同学们的实践经验不足，所以完全理解并掌握MVC不是一个很容易的过程。\r\n</span><span style=\"color: red; font-family: simsun; font-size: 14pt\"><strong>2.调试困难。\r\n</strong></span><span style=\"color: black; font-family: simsun; font-size: 12pt\">因为模型和视图要严格的分离，这样也给调试应用程序带来了一定的困难，每个构件在使用之前都需要经过彻底的测试。\r\n</span><span style=\"color: red; font-family: simsun; font-size: 14pt\"><strong>3.不适合小型，中等规模的应用程序\r\n</strong></span><span style=\"color: black; font-family: simsun; font-size: 12pt\">在一个中小型的应用程序中，强制性的使用MVC进行开发，往往会花费大量时间，并且不能体现MVC的优势，同时会使开发变得繁琐。\r\n</span><span style=\"color: red; font-family: simsun; font-size: 14pt\"><strong>4.增加系统结构和实现的复杂性\r\n</strong></span><span style=\"color: black; font-family: simsun; font-size: 12pt\">对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。\r\n</span><span style=\"color: red; font-family: simsun; font-size: 14pt\"><strong>5.视图与控制器间的过于紧密的连接并且降低了视图对模型数据的访问\r\n</strong></span><span style=\"color: black; font-family: simsun; font-size: 12pt\">视图与控制器是相互分离，但却是联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。\r\n</span><span style=\"color: black; font-family: simsun; font-size: 12pt\">依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</span>', '2018-03-29 11:17:00', '博客园', 'https://www.cnblogs.com/diyunfei/p/6752618.html'),
(135, 'Nosql简介 Redis，Memchche,MongoDb的区别', 'perla', 'SQL,baike', '本篇文章主要介绍Nosql的一些东西，以及Nosql中比较火的三个数据库Redis、Memchache、MongoDb和他们之间的区别。以下是本文章的阅读目录\r\n<hr />\r\nNosql介绍\r\nNosql的全称是Not Only Sql，这个概念早起就有人提出，在09年的时候比较火。Nosql指的是非关系型数据库，而我们常用的都是关系型数据库。就像我们常用的mysql，sqlserver一样，这些数据库一般用来存储重要信息，应对普通的业务是没有问题的。但是，随着互联网的高速发展，传统的关系型数据库在应付超大规模，超大流量以及高并发的时候力不从心。而就在这个时候，Nosql得到的告诉的发展。\r\n\r\n\r\nNosql和关系型数据库的区别\r\n1.存储方式\r\n　　关系型数据库是表格式的，因此存储在表的行和列中。他们之间很容易关联协作存储，提取数据很方便。而Nosql数据库则与其相反，他是大块的组合在一起。通常存储在数据集中，就像文档、键值对或者图结构。\r\n\r\n\r\n2.存储结构\r\n　　关系型数据库对应的是结构化数据，数据表都预先定义了结构（列的定义），结构描述了数据的形式和内容。这一点对数据建模至关重要，虽然预定义结构带来了可靠性和稳定性，但是修改这些数据比较困难。而Nosql数据库基于动态结构，使用与非结构化数据。因为Nosql数据库是动态结构，可以很容易适应数据类型和结构的变化。\r\n\r\n\r\n3.存储规范\r\n　　关系型数据库的数据存储为了更高的规范性，把数据分割为最小的关系表以避免重复，获得精简的空间利用。虽然管理起来很清晰，但是单个操作设计到多张表的时候，数据管理就显得有点麻烦。而Nosql数据存储在平面数据集中，数据经常可能会重复。单个数据库很少被分隔开，而是存储成了一个整体，这样整块数据更加便于读写\r\n\r\n\r\n4.存储扩展\r\n　　这可能是两者之间最大的区别，关系型数据库是纵向扩展，也就是说想要提高处理能力，要使用速度更快的计算机。因为数据存储在关系表中，操作的性能瓶颈可能涉及到多个表，需要通过提升计算机性能来克服。虽然有很大的扩展空间，但是最终会达到纵向扩展的上限。而Nosql数据库是横向扩展的，它的存储天然就是分布式的，可以通过给资源池添加更多的普通数据库服务器来分担负载。\r\n\r\n\r\n5.查询方式\r\n　　关系型数据库通过结构化查询语言来操作数据库（就是我们通常说的SQL）。SQL支持数据库CURD操作的功能非常强大，是业界的标准用法。而Nosql查询以块为单元操作数据，使用的是非结构化查询语言（UnQl），它是没有标准的。关系型数据库表中主键的概念对应Nosql中存储文档的ID。关系型数据库使用预定义优化方式（比如索引）来加快查询操作，而Nosql更简单更精确的数据访问模式。\r\n\r\n\r\n6.事务\r\n　　关系型数据库遵循ACID规则（原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)），而Nosql数据库遵循BASE原则（基本可用（Basically Availble）、软/柔性事务（Soft-state ）、最终一致性（Eventual Consistency））。由于关系型数据库的数据强一致性，所以对事务的支持很好。关系型数据库支持对事务原子性细粒度控制，并且易于回滚事务。而Nosql数据库是在CAP（一致性、可用性、分区容忍度）中任选两项，因为基于节点的分布式系统中，很难全部满足，所以对事务的支持不是很好，虽然也可以使用事务，但是并不是Nosql的闪光点。\r\n\r\n\r\n7.性能\r\n　　关系型数据库为了维护数据的一致性付出了巨大的代价，读写性能比较差。在面对高并发读写性能非常差，面对海量数据的时候效率非常低。而Nosql存储的格式都是key-value类型的，并且存储在内存中，非常容易存储，而且对于数据的 一致性是 弱要求。Nosql无需sql的解析，提高了读写性能。\r\n\r\n\r\n8.授权方式\r\n　　关系型数据库通常有SQL Server，Mysql，Oracle。主流的Nosql数据库有redis，memcache，MongoDb。大多数的关系型数据库都是付费的并且价格昂贵，成本较大，而Nosql数据库通常都是开源的。\r\n\r\n\r\nRedis，Memcache，MongoDb的特点与区别\r\n\r\n\r\nRedis\r\n优点\r\n1.支持多种数据结构，如 string（字符串）、 list(双向链表)、dict(hash表)、set(集合）、zset(排序set)、hyperloglog（基数估算）\r\n2.支持持久化操作，可以进行aof及rdb数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失　　的手段。\r\n3.支持通过Replication进行数据复制，通过master-slave机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave机制是Redis进行HA的重要手段。\r\n4.单线程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。\r\n5.支持pub/sub消息订阅机制，可以用来进行消息订阅与通知。\r\n6.支持简单的事务需求，但业界使用场景很少，并不成熟。\r\n缺点\r\n1.Redis只能使用单线程，性能受限于CPU性能，故单实例CPU最高才可能达到5-6wQPS每秒（取决于数据结构，数据大小以及服务器硬件性能，日常环境中QPS高峰大约在1-2w左右）。\r\n2.支持简单的事务需求，但业界使用场景很少，并不成熟，既是优点也是缺点。\r\n3.Redis在string类型上会消耗较多内存，可以使用dict（hash表）压缩存储以降低内存耗用。\r\n\r\n\r\nMemcache\r\n优点\r\n1.Memcached可以利用多核优势，单实例吞吐量极高，可以达到几十万QPS（取决于key、value的字节大小以及服务器硬件性能，日常环境中QPS高峰大约在4-6w左右）。适用于最大程度扛量。\r\n2.支持直接配置为session handle。\r\n缺点\r\n1只支持简单的key/value数据结构，不像Redis可以支持丰富的数据类型。\r\n2.无法进行持久化，数据不能备份，只能用于缓存使用，且重启后数据全部丢失。\r\n3.无法进行数据同步，不能将MC中的数据迁移到其他MC实例中。\r\n4.Memcached内存分配采用Slab Allocation机制管理内存，value大小分布差异较大时会造成内存利用率降低，并引发低利用率时依然出现踢出等问题。需要用户注重value设计。\r\n\r\n\r\nMongoDB\r\n优点\r\n1.更高的写负载，MongoDB拥有更高的插入速度。\r\n2.处理很大的规模的单表，当数据表太大的时候可以很容易的分割表。\r\n3.高可用性，设置M-S不仅方便而且很快，MongoDB还可以快速、安全及自动化的实现节点（数据中心）故障转移。\r\n4.快速的查询，MongoDB支持二维空间索引，比如管道，因此可以快速及精确的从指定位置获取数据。MongoDB在启动后会将数据库中的数据以文件映射的方式加载到内存中。如果内存资源相当丰富的话，这将极大地提高数据库的查询速度。\r\n5.非结构化数据的爆发增长，增加列在有些情况下可能锁定整个数据库，或者增加负载从而导致性能下降，由于MongoDB的弱数据结构模式，添加1个新字段不会对旧表格有任何影响，整个过程会非常快速。\r\n缺点\r\n1.不支持事务。\r\n2.MongoDB占用空间过大 。\r\n3.MongoDB没有成熟的维护工具。\r\n\r\n\r\nRedis、Memcache和MongoDB的区别\r\n1.性能\r\n三者的性能都比较高，总的来讲：Memcache和Redis差不多，要高于MongoDB。\r\n2.便利性\r\nmemcache数据结构单一。\r\nredis丰富一些，数据操作方面，redis更好一些，较少的网络IO次数。\r\nmongodb支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富。\r\n3,存储空间\r\nredis在2.0版本后增加了自己的VM特性，突破物理内存的限制；可以对key value设置过期时间（类似memcache）。\r\nmemcache可以修改最大可用内存,采用LRU算法。\r\nmongoDB适合大数据量的存储，依赖操作系统VM做内存管理，吃内存也比较厉害，服务不要和别的服务在一起。\r\n4.可用性\r\nredis，依赖客户端来实现分布式读写；主从复制时，每次从节点重新连接主节点都要依赖整个快照,无增量复制，因性能和效率问题，所以单点问题比较复杂；不支持自动sharding,需要依赖程序设定一致hash 机制。一种替代方案是，不用redis本身的复制机制，采用自己做主动复制（多份存储），或者改成增量复制的方式（需要自己实现），一致性问题和性能的权衡。\r\nMemcache本身没有数据冗余机制，也没必要；对于故障预防，采用依赖成熟的hash或者环状的算法，解决单点故障引起的抖动问题。\r\nmongoDB支持master-slave,replicaset（内部采用paxos选举算法，自动故障恢复）,auto sharding机制，对客户端屏蔽了故障转移和切分机制。\r\n5.可靠性\r\nredis支持（快照、AOF）：依赖快照进行持久化，aof增强了可靠性的同时，对性能有所影响。\r\nmemcache不支持，通常用在做缓存,提升性能。\r\nMongoDB从1.8版本开始采用binlog方式支持持久化的可靠性。\r\n6.一致性\r\nMemcache 在并发场景下，用cas保证一致性。\r\nredis事务支持比较弱，只能保证事务中的每个操作连续执行。\r\nmongoDB不支持事务。\r\n7.数据分析\r\nmongoDB内置了数据分析的功能(mapreduce),其他两者不支持。\r\n8.应用场景\r\nredis：数据量较小的更性能操作和运算上。\r\nmemcache：用于在动态系统中减少数据库负载，提升性能;做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用sharding）。\r\nMongoDB:主要解决海量数据的访问效率问题。', '2018-03-29 13:22:00', '博客园', 'https://www.cnblogs.com/lina520/p/7919551.html'),
(136, 'PHP错误级别 error_reporting() 函数详解', '52PHP', 'PHP', '在PHP开发的时候常常会用到error_reporting(report_level)来调试自己的程序，下面列出了report_level可能值：\r\n<table>\r\n<tbody>\r\n<tr><th class=\"td100\">值</th><th>常量</th><th>描述</th></tr>\r\n<tr>\r\n<td>1</td>\r\n<td>E_ERROR</td>\r\n<td>这是一个严重错误，不可恢复，如位置异常，内存不足等</td>\r\n</tr>\r\n<tr>\r\n<td>2</td>\r\n<td>E_WARNING</td>\r\n<td>警告，最一般的错误，如函数的参数错误等</td>\r\n</tr>\r\n<tr>\r\n<td>4</td>\r\n<td>E_PARSE</td>\r\n<td>解析错误，在解析PHP文件时产生，并强制PHP在执行前退出</td>\r\n</tr>\r\n<tr>\r\n<td>8</td>\r\n<td>E_NOTICE</td>\r\n<td>通告表示可能在操作一些未知的变量等。在开发时可开启通告，以保证程序是\"安全通告\"的，瑞在正式系统中，应关闭通告</td>\r\n</tr>\r\n<tr>\r\n<td>16</td>\r\n<td>E_CORE_ERROR</td>\r\n<td>这个内部错误是由于PHP加载扩展失败而导致的，并且会导致PHP停止运行并退出</td>\r\n</tr>\r\n<tr>\r\n<td>32</td>\r\n<td>E_CORE_WARNING</td>\r\n<td>PHP启动时初始化过程中的警告(非致命性错)</td>\r\n</tr>\r\n<tr>\r\n<td>64</td>\r\n<td>E_COMPILE_ERROR</td>\r\n<td>编译错误是在编译时发生，这个错误将导致PHP运行退出</td>\r\n</tr>\r\n<tr>\r\n<td>128</td>\r\n<td>E_COMPILE_WARNING</td>\r\n<td>编译警告用于告诉用户一些不推荐的语法信息</td>\r\n</tr>\r\n<tr>\r\n<td>256</td>\r\n<td>E_USER_ERROR</td>\r\n<td>用户定义的错误将导致辞PHP退出，它对是来自PHP自身，而是来自脚本文件中。</td>\r\n</tr>\r\n<tr>\r\n<td>512</td>\r\n<td>E_USER_WARNING</td>\r\n<td>脚本使用它来通知一个执行失败，同时PHP也会用E_WARNING通知</td>\r\n</tr>\r\n<tr>\r\n<td>1024</td>\r\n<td>E_USER_NOTICE</td>\r\n<td>用户定义的通告用于在脚本中表示可能存在的错误</td>\r\n</tr>\r\n<tr>\r\n<td>2048</td>\r\n<td>E_STRICT</td>\r\n<td>编码标准化警告(建议如何修改以向前兼容)</td>\r\n</tr>\r\n<tr>\r\n<td>4096</td>\r\n<td>E_RECOVERABLE_ERROR</td>\r\n<td>接近致命的运行时错误，若未被捕获则视同E_ERROR</td>\r\n</tr>\r\n<tr>\r\n<td>8191</td>\r\n<td>E_ALL</td>\r\n<td>除E_STRICT外的所有错误(PHP6中为8191,即包含所有)</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n例子：\r\n任意数目的以上选项都可以用&ldquo;或&rdquo;来连接（用 OR 或 |），这样可以报告所有需要的各级别错误。例如，下面的代码关闭了用户自定义的错误和警告，执行了某些操作，然后恢复到原始的报错级别：\r\n<pre><code>&lt;?php\r\n//禁用错误报告\r\nerror_reporting(0);\r\n\r\n//报告运行时错误\r\nerror_reporting(E_ERROR | E_WARNING | E_PARSE);   \r\n\r\n//报告所有错误\r\nerror_reporting(E_ALL);   \r\n\r\nerror_reporting(7);\r\n/*\r\n设置php错误检测级别\r\nE_ERROR - 致命性运行时错 (1)\r\nE_WARNING - 运行时警告（非致命性错）(2)\r\nE_PARSE - 编译时解析错误 (4)\r\n1+2+4 = 7\r\n*/\r\n?&gt;</code></pre>\r\n&nbsp;\r\n<span style=\"color: #0000ff;\">uchome</span>系统中的调试处理：\r\n<code>D_BUG ? error_reporting(7) : error_reporting(0);</code>\r\n', '2018-03-29 15:58:00', '博客园', 'https://www.cnblogs.com/52php/p/5666424.html'),
(137, 'javascript引擎工作原理', '不得不爱xxy', 'JS', '1. 什么是JavaScript解析引擎？\r\n简单地说，JavaScript解析引擎就是能够“读懂”JavaScript代码，并准确地给出代码运行结果的一段程序。比方说，当你写了 var a = 1 + 1; 这样一段代码，JavaScript引擎做的事情就是看懂（解析）你这段代码，并且将a的值变为2。\r\n\r\n学过编译原理的人都知道，对于静态语言来说（如Java、C++、C），处理上述这些事情的叫编译器（Compiler），相应地对于JavaScript这样的动态语言则叫解释器（Interpreter）。这两者的区别用一句话来概括就是：编译器是将源代码编译为另外一种代码（比如机器码，或者字节码），而解释器是直接解析并将代码运行结果输出。 比方说，firebug的console就是一个JavaScript的解释器。\r\n\r\n但是，现在很难去界定说，JavaScript引擎它到底算是个解释器还是个编译器，因为，比如像V8（Chrome的JS引擎），它其实为了提高 JS的运行性能，在运行之前会先将JS编译为本地的机器码（native machine code），然后再去执行机器码（这样速度就快很多），相信大家对JIT（Just In Time Compilation）一定不陌生吧。\r\n\r\n我个人认为，不需要过分去强调JavaScript解析引擎到底是什么，了解它究竟做了什么事情我个人认为就可以了。对于编译器或者解释器究竟是如何看懂代码的，翻出大学编译课的教材就可以了。\r\n\r\n这里还要强调的就是，JavaScript引擎本身也是程序，代码编写而成。比如V8就是用C/C++写的。\r\n\r\n2. JavaScript解析引擎与ECMAScript是什么关系？\r\nJavaScript引擎是一段程序，我们写的JavaScript代码也是程序，如何让程序去读懂程序呢？这就需要定义规则。比如，之前提到的var a = 1 + 1;，它表示：\r\n\r\n左边var代表了这是申明（declaration），它申明了a这个变量\r\n\r\n右边的+表示要将1和1做加法\r\n\r\n中间的等号表示了这是个赋值语句\r\n\r\n最后的分号表示这句语句结束了\r\n\r\n上述这些就是规则，有了它就等于有了衡量的标准，JavaScript引擎就可以根据这个标准去解析JavaScript代码了。那么这里的 ECMAScript就是定义了这些规则。其中ECMAScript 262这份文档，就是对JavaScript这门语言定义了一整套完整的标准。其中包括：\r\n\r\nvar，if，else，break，continue等是JavaScript的关键词\r\n\r\nabstract，int，long等是JavaScript保留词\r\n\r\n怎么样算是数字、怎么样算是字符串等等\r\n\r\n定义了操作符（+，-，>，<等）\r\n\r\n定义了JavaScript的语法\r\n\r\n定义了对表达式，语句等标准的处理算法，比如遇到==该如何处理\r\n\r\n⋯⋯\r\n\r\n标准的JavaScript引擎就会根据这套文档去实现，注意这里强调了标准，因为也有不按照标准来实现的，比如IE的JS引擎。这也是为什么JavaScript会有兼容性的问题。至于为什么IE的JS引擎不按照标准来实现，就要说到浏览器大战了，这里就不赘述了，自行Google之。\r\n\r\n所以，简单的说，ECMAScript定义了语言的标准，JavaScript引擎根据它来实现，这就是两者的关系。\r\n\r\n3. JavaScript解析引擎与浏览器又是什么关系？\r\n简单地说，JavaScript引擎是浏览器的组成部分之一。因为浏览器还要做很多别的事情，比如解析页面、渲染页面、Cookie管理、历史记录 等等。那么，既然是组成部分，因此一般情况下JavaScript引擎都是浏览器开发商自行开发的。比如：IE9的Chakra、Firefox的 TraceMonkey、Chrome的V8等等。\r\n\r\n从而也看出，不同浏览器都采用了不同的JavaScript引擎。因此，我们只能说要深入了解哪个JavaScript引擎。\r\n\r\n4. 深入了解其内部原理的途径有哪些？\r\n搞清楚了前面三个问题，那这个问题就好回答了。个人认为，主要途径有如下几种（依次由浅入深）：\r\n\r\n看讲JavaScript引擎工作原理的书\r\n这种方式最方便，不过我个人了解到的这样的书几乎没有，但是Dmitry A.Soshnikov博客上的文章真的是非常的赞，建议直接看英文，实在英文看起来吃力的，可以看译本\r\n\r\n看ECMAScript的标准文档\r\n这种方式相对直接，原汁原味，因为引擎就是根据标准来实现的。目前来说，可以看第五版和第三版，不过要看懂也是不容易的。\r\n\r\n看JS引擎源代码\r\n这种方式最直接，当然也最难了。因为还牵涉到了如何实现词法分析器，语法分析器等等更加底层的东西了，而且并非所有的引擎代码都是开源的。\r\n\r\n5. 以上几种方式中第一种都很难看明白怎么办？\r\n其实第一种方式中的文章，作者已经将文档中内容提炼出来，用通俗易懂的方式阐述出来了。如果，看起来还觉得吃力，那说明还缺少两块的东西：\r\n\r\n对JavaScript本身还理解的不够深入\r\n如果你刚刚接触JavaScript，或者说以前甚至都没有接触过。那一下子就想要去理解内部工作原理，的确是很吃力的。首先应该多看看书，多实践实践，从知识和实践的方式来了解JavaScript预言特性。这种情况下，你只需要了解现象。比方说，(function(){})() 这样可以直接调用该匿名函数、用闭包可以解决循环中的延迟操作的变量值获取问题等等。要了解这些，都是需要多汲取和实践的。实践这里就不多说了，而知识汲取方面可以多看看书和博客。这个层面的书就相对比较多了，《Professional JavaScript for Web Developers》就是本很好的书（中文版请自行寻找）。\r\n\r\n缺乏相应的领域知识\r\n当JavaScript也达到一定深度了，但是，还是看不大明白，或者没法很深入到内部去一探究竟。那就意味着缺少对 应的领域知识。这里明显的就是编译原理相关的知识。不过，其实对这块了解个大概基本看起来就没问题了。要再继续深入，那需要对编译原理了解的很深入，比如 说词法分析采用什么算法，一般怎么处理。会有什么问题，如何解决，AST生成算法一般有哪几种等等。那要看编译原理方面的书，也有基本经典的书，比如《Compilers: Principles, Techniques, and Tools》这本也是传说中的龙书，还有非常著名的《SICP》和《PLAI》。 不过其实根据个人经验，对于Dmitry的文章，要看懂它，只要你对JavaScript有一定深度的了解，同时你大学计算机的课程都能大致掌握了（尤其 是操作系统），也就是说基础不错，理解起来应该没问题。因为这些文章基本没有涉及底层编译相关的，只是在解释文档的内容，并且其中很多东西都是相通的，比 如：context的切换与CPU的进程切换、函数相关的的局部变量的栈存储、函数退出的操作等等都是一致的。', '2018-03-29 16:05:00', '博客园', 'http://www.cnblogs.com/xinxingyu/p/4928587.html'),
(138, '数据库设计中的14个技巧', 'sirfei', 'SQL,baike', '1. 原始单据与实体之间的关系\r\n　　可以是一对一、一对多、多对多的关系。在一般情况下，它们是一对一的关系：即一张原始单据对\r\n\r\n应且只对应一个实体。在特殊情况下，它们可能是一对多或多对一的关系，即一张原始单证对应多个实\r\n\r\n体，或多张原始单证对应一个实体。这里的实体可以理解为基本表。明确这种对应关系后，对我们设计\r\n\r\n录入界面大有好处。\r\n　　〖例1〗：一份员工履历资料，在人力资源信息系统中，就对应三个基本表：员工基本情况表、社会\r\n\r\n关系表、工作简历表。这就是“一张原始单证对应多个实体”的典型例子。\r\n\r\n　　 2. 主键与外键\r\n　　一般而言，一个实体不能既无主键又无外键。在E—R 图中, 处于叶子部位的实体, 可以定义主键，\r\n\r\n也可以不定义主键(因为它无子孙), 但必须要有外键(因为它有父亲)。\r\n　　主键与外键的设计，在全局数据库的设计中，占有重要地位。当全局数据库的设计完成以后，有个\r\n\r\n美国数据库设计专家说：“键，到处都是键，除了键之外，什么也没有”，这就是他的数据库设计经验\r\n\r\n之谈，也反映了他对信息系统核心(数据模型)的高度抽象思想。因为：主键是实体的高度抽象，主键与\r\n\r\n外键的配对，表示实体之间的连接。\r\n\r\n　　 3. 基本表的性质\r\n　　基本表与中间表、临时表不同，因为它具有如下四个特性：\r\n　　 (1) 原子性。基本表中的字段是不可再分解的。\r\n　　 (2) 原始性。基本表中的记录是原始数据（基础数据）的记录。\r\n　　 (3) 演绎性。由基本表与代码表中的数据，可以派生出所有的输出数据。\r\n　　 (4) 稳定性。基本表的结构是相对稳定的，表中的记录是要长期保存的。\r\n　　理解基本表的性质后，在设计数据库时，就能将基本表与中间表、临时表区分开来。\r\n\r\n　　 4. 范式标准\r\n　　基本表及其字段之间的关系, 应尽量满足第三范式。但是，满足第三范式的数据库设计，往往不是\r\n\r\n最好的设计。为了提高数据库的运行效率，常常需要降低范式标准：适当增加冗余，达到以空间换时间\r\n\r\n的目的。\r\n　　〖例2〗：有一张存放商品的基本表，如表1所示。“金额”这个字段的存在，表明该表的设计不满\r\n\r\n足第三范式，因为“金额”可以由“单价”乘以“数量”得到，说明“金额”是冗余字段。但是，增加\r\n\r\n“金额”这个冗余字段，可以提高查询统计的速度，这就是以空间换时间的作法。\r\n　　在Rose 2002中，规定列有两种类型：数据列和计算列。“金额”这样的列被称为“计算列”，而“\r\n\r\n单价”和“数量”这样的列被称为“数据列”。\r\n　　表1 商品表的表结构\r\n　　商品名称 商品型号 单价 数量 金额\r\n　　电视机 29吋 2,500 40 100,000\r\n　　 \r\n　　 5. 通俗地理解三个范式\r\n　　通俗地理解三个范式，对于数据库设计大有好处。在数据库设计中，为了更好地应用三个范式，就\r\n\r\n必须通俗地理解三个范式(通俗地理解是够用的理解，并不是最科学最准确的理解)：\r\n　　第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；\r\n　　第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；\r\n　　第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余\r\n\r\n。\r\n　　没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运\r\n\r\n行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式\r\n\r\n，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。\r\n\r\n　　 6. 要善于识别与正确处理多对多的关系\r\n　　若两个实体之间存在多对多的关系，则应消除这种关系。消除的办法是，在两者之间增加第三个实\r\n\r\n体。这样，原来一个多对多的关系，现在变为两个一对多的关系。要将原来两个实体的属性合理地分配\r\n\r\n到三个实体中去。这里的第三个实体，实质上是一个较复杂的关系，它对应一张基本表。一般来讲，数\r\n\r\n据库设计工具不能识别多对多的关系，但能处理多对多的关系。\r\n　　〖例3〗：在“图书馆信息系统”中，“图书”是一个实体，“读者”也是一个实体。这两个实体之\r\n\r\n间的关系，是一个典型的多对多关系：一本图书在不同时间可以被多个读者借阅，一个读者又可以借多\r\n\r\n本图书。为此，要在二者之间增加第三个实体，该实体取名为“借还书”，它的属性为：借还时间、借\r\n\r\n还标志(0表示借书，1表示还书)，另外，它还应该有两个外键(“图书”的主键，“读者”的主键)，使\r\n\r\n它能与“图书”和“读者”连接。\r\n\r\n　　 7. 主键PK的取值方法\r\n　　 PK是供程序员使用的表间连接工具，可以是一无物理意义的数字串, 由程序自动加1来实现。也可\r\n\r\n以是有物理意义的字段名或字段名的组合。不过前者比后者好。当PK是字段名的组合时，建议字段的个\r\n\r\n数不要太多，多了不但索引占用空间大，而且速度也慢。\r\n\r\n　　 8. 正确认识数据冗余\r\n　　主键与外键在多表中的重复出现, 不属于数据冗余，这个概念必须清楚，事实上有许多人还不清楚\r\n\r\n。非键字段的重复出现, 才是数据冗余！而且是一种低级冗余，即重复性的冗余。高级冗余不是字段的\r\n\r\n重复出现，而是字段的派生出现。\r\n　　〖例4〗：商品中的“单价、数量、金额”三个字段，“金额”就是由“单价”乘以“数量”派生出\r\n\r\n来的，它就是冗余，而且是一种高级冗余。冗余的目的是为了提高处理速度。只有低级冗余才会增加数\r\n\r\n据的不一致性，因为同一数据，可能从不同时间、地点、角色上多次录入。因此，我们提倡高级冗余(派\r\n\r\n生性冗余)，反对低级冗余(重复性冗余)。\r\n\r\n　　 9. E--R图没有标准答案\r\n　　信息系统的E--R图没有标准答案，因为它的设计与画法不是惟一的，只要它覆盖了系统需求的业务\r\n\r\n范围和功能内容，就是可行的。反之要修改E--R图。尽管它没有惟一的标准答案，并不意味着可以随意\r\n\r\n设计。好的E—R图的标准是：结构清晰、关联简洁、实体个数适中、属性分配合理、没有低级冗余。\r\n\r\n　　 10. 视图技术在数据库设计中很有用\r\n　　与基本表、代码表、中间表不同，视图是一种虚表，它依赖数据源的实表而存在。视图是供程序员\r\n\r\n使用数据库的一个窗口，是基表数据综合的一种形式, 是数据处理的一种方法，是用户数据保密的一种\r\n\r\n手段。为了进行复杂处理、提高运算速度和节省存储空间, 视图的定义深度一般不得超过三层。 若三层\r\n\r\n视图仍不够用, 则应在视图上定义临时表, 在临时表上再定义视图。这样反复交迭定义, 视图的深度就\r\n\r\n不受限制了。\r\n　　对于某些与国家政治、经济、技术、军事和安全利益有关的信息系统，视图的作用更加重要。这些\r\n\r\n系统的基本表完成物理设计之后，立即在基本表上建立第一层视图，这层视图的个数和结构，与基本表\r\n\r\n的个数和结构是完全相同。并且规定，所有的程序员，一律只准在视图上操作。只有数据库管理员，带\r\n\r\n着多个人员共同掌握的“安全钥匙”，才能直接在基本表上操作。请读者想想：这是为什么？\r\n\r\n　　 11. 中间表、报表和临时表\r\n　　中间表是存放统计数据的表，它是为数据仓库、输出报表或查询结果而设计的，有时它没有主键与\r\n\r\n外键(数据仓库除外)。临时表是程序员个人设计的，存放临时记录，为个人所用。基表和中间表由DBA维\r\n\r\n护，临时表由程序员自己用程序自动维护。\r\n\r\n　　 12. 完整性约束表现在三个方面\r\n　　域的完整性：用Check来实现约束，在数据库设计工具中，对字段的取值范围进行定义时，有一个Ch\r\n\r\neck按钮，通过它定义字段的值城。\r\n　　参照完整性：用PK、FK、表级触发器来实现。\r\n　　用户定义完整性：它是一些业务规则，用存储过程和触发器来实现。\r\n\r\n　　 13. 防止数据库设计打补丁的方法是“三少原则”\r\n　　 (1) 一个数据库中表的个数越少越好。只有表的个数少了，才能说明系统的E--R图少而精，去掉了\r\n\r\n重复的多余的实体，形成了对客观世界的高度抽象，进行了系统的数据集成，防止了打补丁式的设计；\r\n　　 (2) 一个表中组合主键的字段个数越少越好。因为主键的作用，一是建主键索引，二是做为子表的\r\n\r\n外键，所以组合主键的字段个数少了，不仅节省了运行时间，而且节省了索引存储空间；\r\n　　 (3) 一个表中的字段个数越少越好。只有字段的个数少了，才能说明在系统中不存在数据重复，且\r\n\r\n很少有数据冗余，更重要的是督促读者学会“列变行”，这样就防止了将子表中的字段拉入到主表中去\r\n\r\n，在主表中留下许多空余的字段。所谓“列变行”，就是将主表中的一部分内容拉出去，另外单独建一\r\n\r\n个子表。这个方法很简单，有的人就是不习惯、不采纳、不执行。\r\n　　数据库设计的实用原则是：在数据冗余和处理速度之间找到合适的平衡点。“三少”是一个整体概\r\n\r\n念，综合观点，不能孤立某一个原则。该原则是相对的，不是绝对的。“三多”原则肯定是错误的。试\r\n\r\n想：若覆盖系统同样的功能，一百个实体(共一千个属性) 的E--R图，肯定比二百个实体(共二千个属性)\r\n\r\n的E--R图，要好得多。\r\n　　提倡“三少”原则，是叫读者学会利用数据库设计技术进行系统的数据集成。数据集成的步骤是将\r\n\r\n文件系统集成为应用数据库，将应用数据库集成为主题数据库，将主题数据库集成为全局综合数据库。\r\n\r\n集成的程度越高，数据共享性就越强，信息孤岛现象就越少，整个企业信息系统的全局E—R图中实体的\r\n\r\n个数、主键的个数、属性的个数就会越少。\r\n　　提倡“三少”原则的目的，是防止读者利用打补丁技术，不断地对数据库进行增删改，使企业数据\r\n\r\n库变成了随意设计数据库表的“垃圾堆”，或数据库表的“大杂院”，最后造成数据库中的基本表、代\r\n\r\n码表、中间表、临时表杂乱无章，不计其数，导致企事业单位的信息系统无法维护而瘫痪。\r\n　　 “三多”原则任何人都可以做到，该原则是“打补丁方法”设计数据库的歪理学说。“三少”原则\r\n\r\n是少而精的原则，它要求有较高的数据库设计技巧与艺术，不是任何人都能做到的，因为该原则是杜绝\r\n\r\n用“打补丁方法”设计数据库的理论依据。\r\n\r\n　　 14. 提高数据库运行效率的办法\r\n　　在给定的系统硬件和系统软件条件下，提高数据库系统的运行效率的办法是：\r\n　　 (1) 在数据库物理设计时，降低范式，增加冗余, 少用触发器, 多用存储过程。\r\n　　 (2) 当计算非常复杂、而且记录条数非常巨大时(例如一千万条)，复杂计算要先在数据库外面，以\r\n\r\n文件系统方式用C++语言计算处理完成之后，最后才入库追加到表中去。这是电信计费系统设计的经验。\r\n　　 (3) 发现某个表的记录太多，例如超过一千万条，则要对该表进行水平分割。水平分割的做法是，\r\n\r\n以该表主键PK的某个值为界线，将该表的记录水平分割为两个表。若发现某个表的字段太多，例如超过\r\n\r\n八十个，则垂直分割该表，将原来的一个表分解为两个表。\r\n　　 (4) 对数据库管理系统DBMS进行系统优化，即优化各种系统参数，如缓冲区个数。\r\n　　 (5) 在使用面向数据的SQL语言进行程序设计时，尽量采取优化算法。\r\n　　总之，要提高数据库的运行效率，必须从数据库系统级优化、数据库设计级优化、程序实现级优化\r\n\r\n，这三个层次上同时下功夫。\r\n\r\n　　上述十四个技巧，是许多人在大量的数据库分析与设计实践中，逐步总结出来的。对于这些经验的\r\n\r\n运用，读者不能生帮硬套，死记硬背，而要消化理解，实事求是，灵活掌握。并逐步做到：在应用中发\r\n\r\n展，在发展中应用。', '2018-04-02 09:24:00', 'CSDN', 'https://blog.csdn.net/sirfei/article/details/434994');
INSERT INTO `wu_blog` (`id`, `post_title`, `post_author`, `post_type`, `post_content`, `post_date`, `post_from`, `post_link`) VALUES
(139, 'ZIP压缩算法详细分析及解压实例解释', 'esingchan', 'baike', '最近自己实现了一个ZIP压缩数据的解压程序，觉得有必要把ZIP压缩格式进行一下详细总结，数据压缩是一门通信原理和计算机科学都会涉及到的学科，在通信原理中，一般称为信源编码，在计算机科学里，一般称为数据压缩，两者本质上没啥区别，在数学家看来，都是映射。一方面在进行通信的时候，有必要将待传输的数据进行压缩，以减少带宽需求；另一方面，计算机存储数据的时候，为了减少磁盘容量需求，也会将文件进行压缩，尽管现在的网络带宽越来越高，压缩已经不像90年代初那个时候那么迫切，但在很多场合下仍然需要，其中一个原因是压缩后的数据容量减小后，磁盘访问IO的时间也缩短，尽管压缩和解压缩过程会消耗CPU资源，但是CPU计算资源增长得很快，但是磁盘IO资源却变化得很慢，比如目前主流的SATA硬盘仍然是7200转，如果把磁盘的IO压力转化到CPU上，总体上能够提升系统运行速度。压缩作为一种非常典型的技术，会应用到很多很多场合下，比如文件系统、数据库、消息传输、网页传输等等各类场合。尽管压缩里面会涉及到很多术语和技术，但无需担心，博主尽量将其描述得通俗易懂。另外，本文涉及的压缩算法非常主流并且十分精巧，理解了ZIP的压缩过程，对理解其它相关的压缩算法应该就比较容易了。\r\n&nbsp;\r\n1、引子\r\n压缩可以分为无损压缩和有损压缩，有损，指的是压缩之后就无法完整还原原始信息，但是压缩率可以很高，主要应用于视频、话音等数据的压缩，因为损失了一点信息，人是很难察觉的，或者说，也没必要那么清晰照样可以看可以听；无损压缩则用于文件等等必须完整还原信息的场合，ZIP自然就是一种无损压缩，在通信原理中介绍数据压缩的时候，往往是从信息论的角度出发，引出香农所定义的熵的概念，这方面的介绍实在太多，这里换一种思路，从最原始的思想出发，为了达到压缩的目的，需要怎么去设计算法。而ZIP为我们提供了相当好的案例。\r\n尽管我们不去探讨信息论里面那些复杂的概念，不过我们首先还是要从两位信息论大牛谈起。因为是他们奠基了今天大多数无损数据压缩的核心，包括ZIP、RAR、GZIP、GIF、PNG等等大部分无损压缩格式。这两位大牛的名字分别是Jacob Ziv和Abraham Lempel，是两位以色列人，在1977年的时候发表了一篇论文《A Universal Algorithm for Sequential Data Compression》，从名字可以看出，这是一种通用压缩算法，所谓通用压缩算法，指的是这种压缩算法没有对数据的类型有什么限定。不过论文我觉得不用仔细看了，因为博主作为一名通信专业的PHD，看起来也焦头烂额，不过我们后面可以看到，它的思想还是很简单的，之所以看起来复杂，主要是因为IEEE的某些杂志就是这个特点，需要从数学上去证明，这种压缩算法到底有多优，比如针对一个各态历经的随机序列（不用追究什么叫各态历经随机序列），经过这样的压缩算法后，是否可以接近信息论里面的极限（也就是前面说的熵的概念）等等，不过在理解其思想之前，个人认为没必要深究这些东西，除非你要发论文。这两位大牛提出的这个算法称为LZ77，两位大牛过了一年又提了一个类似的算法，称为LZ78，思想类似，ZIP这个算法就是基于LZ77的思想演变过来的，但ZIP对LZ77编码之后的结果又继续进行压缩，直到难以压缩为止。除了LZ77、LZ78，还有很多变种的算法，基本都以LZ开头，如LZW、LZO、LZMA、LZSS、LZR、LZB、LZH、LZC、LZT、LZMW、LZJ、LZFG等等，非常多，LZW也比较流行，GIF那个动画格式记得用了LZW。我也写过解码程序，以后有时间可以再写一篇，但感觉跟LZ77这些类似，写的必要性不大。\r\nZIP的作者是一个叫Phil Katz的人，这个人算是开源界的一个具有悲剧色彩的传奇人物。虽然二三十年前，开源这个词还没有现在这样风起云涌，但是总有一些具有黑客精神的牛人，内心里面充满了自由，无论他处于哪个时代。Phil Katz这个人是个牛逼程序员，成名于DOS时代，我个人也没有经历过那个时代，我是从Windows98开始接触电脑的，只是从书籍中得知，那个时代网速很慢，拨号使用的是只有几十Kb（比特不是字节）的猫，56Kb实际上是这种猫的最高速度，在ADSL出现之后，这种技术被迅速淘汰。当时记录文件的也是硬盘，但是在电脑之间拷贝文件的是软盘，这个东西我大一还用过，最高容量记得是1.44MB，这还是200X年的软盘，以前的软盘容量具体多大就不知道了，Phil Katz上网的时候还不到1990年，WWW实际上就没出现，浏览器当然是没有的，当时上网干嘛呢？基本就是类似于网管敲各种命令，这样实际上也可以聊天、上论坛不是吗，传个文件不压缩的话肯定死慢死慢的，所以压缩在那个时代很重要。当时有个商业公司提供了一种称为ARC的压缩软件，可以让你在那个时代聊天更快，当然是要付费的，Phil Katz就感觉到不爽，于是写了一个PKARC，免费的，看名字知道是兼容ARC的，于是网友都用PKARC了，ARC那个公司自然就不爽，把哥们告上了法庭，说牵涉了知识产权等等，结果Phil Katz坐牢了。。。牛人就是牛人， 在牢里面冥思苦想，决定整一个超越ARC的牛逼算法出来，牢里面就是适合思考，用了两周就整出来的，称为PKZIP，不仅免费，而且这次还开源了，直接公布源代码，因为算法都不一样了，也就不涉及到知识产权了，于是ZIP流行开来，不过Phil Katz这个人没有从里面赚到一分钱，还是穷困潦倒，因为喝酒过多等众多原因，2000年的时候死在一个汽车旅馆里。英雄逝去，精神永存，现在我们用UE打开ZIP文件，我们能看到开头的两个字节就是PK两个字符的ASCII码。\r\n&nbsp;\r\n2、一个案例的入门思考\r\n好了，Phil Katz在牢里面到底思考了什么？用什么样的算法来压缩数据呢？我们想一个简单的例子：\r\n生，容易。活，容易。生活，不容易。\r\n上面这句话假如不压缩，如果使用Unicode编码，每个字会用2个字节表示。为什么是两个字节呢？Unicode是一种国际标准，把常见各国的字符，比如英文字符、日文字符、韩文字符、中文字符、拉丁字符等等全部制定了一个标准，显然，用2个字节可以最多表示2^16=65536个字符，那么65536就够了吗？生僻字其实是很多的，比如光康熙字典里面收录的汉字就好几万，所以实际上是不够的，那么是不是扩到4个字节？也可以，这样空间倒是变大了，可以收录更多字符，但一方面扩到4个字节就一定保证够吗？另一方面，4个字节是不是太浪费空间了，就为了那些一般情况都不会出现的生僻字？所以，一般情况下，使用2个字节表示，当出现生僻字的时候，再使用4个字节表示。这实际上就体现了信息论中数据压缩基本思想，出现频繁的那些字符，表示得短一些；出现稀少的，可以表示得长些（反正一般情况下也不会出现），这样整体长度就会减小。除了Unicode，ASCII编码是针对英文字符的编码方案，用1个字节即可，除了这两种编码方案，还有很多地区性的编码方案，比如GB2312可以对中文简体字进行编码，Big5可以对中文繁体字进行编码。两个文件如果都使用一种编码方案，那是没有问题的，不过考虑到国际化，还是尽量使用Unicode这种国际标准吧。不过这个跟ZIP没啥关系，纯属背景介绍。\r\n好了，回到我们前面说的例子，一共有17个字符（包括标点符号），如果用普通Unicode表示，一共是17*2=34字节。可不可以压缩呢？所有人一眼都可以看出里面出现了很多重复的字符，比如里面出现了好多次容易（实际上是容易加句号三个字符）这个词，第一次出现的时候用普通的Unicode，第二次出现的&ldquo;容易。&rdquo;则可以用（距离、长度）表示，距离的意思是接下来的字符离前面重复的字符隔了几个，长度则表示有几个重复字符，上面的例子的第二个&ldquo;容易。&rdquo;就表示为（5,3），就是距离为5个字符，长度是3，在解压缩的时候，解到这个地方的时候，往前跳5个字符，把这个位置的连续3个字符拷贝过来就完成了解压缩，这实际上不就是指针的概念？没有错，跟指针很类似，不过在数据压缩领域，一般称为字典编码，为什么叫字典呢，当我们去查一个字的时候，我们总是先去目录查找这个字在哪一页，再翻到那一页去看，指针不也是这样，指针不就是内存的地址，要对一个内存进行操作，我们先拿到指针，然后去那块内存去操作。所谓的指针、字典、索引、目录等等术语，不同的背景可能称呼不同，但我们要理解他们的本质。如果使用（5,3）这种表示方法，原来需要用6个字节表示，现在只需要记录5和3即可。那么，5和3怎么记录呢？一种方法自然还是可以用Unicode，那么就相当于节省了2个字节，但是有两个问题，第一个问题是解压缩的时候怎么知道是正常的5和3这两个字符，还是这只是一个特殊标记呢？所以前面还得加一个标志来区分一下，到底接下来的Unicode码是指普通字符，还是指距离和长度，如果是普通Unicode，则直接查Unicode码表，如果是距离和长度，则往前面移动一段距离，拷贝即可。第二个问题，还是压缩程度不行，这么一弄，感觉压缩不了多少，如果重复字符比较长那倒是比较划算，因为反正&ldquo;距离+长度&rdquo;就够了，但比如这个例子，如果5和3前面加一个特殊字节，岂不是又是3个字节，那还不如不压缩。咋办呢？能不能对（5,3）这种整数进行再次压缩？这里就利用了我们前面说的一个基本原则：出现的少的整数多编一些比特，出现的多的整数少编一些比特。那么，比如3、4、5、6、7、8、9这些距离谁出现得多？谁出现的少呢？谁知道？\r\n压缩之前当然不知道，不过扫描一遍不就知道了？比如，后面那个重复的字符串&ldquo;容易。&rdquo;按照前面的规则可以表示为（7,3）,即离前面重复的字符串距离为7，长度为3。（7,3）指着前面跟自己一样那个字符串。那么，为什么不指着第一个&ldquo;容易。&rdquo;要指着第二个&ldquo;容易。&rdquo;呢？如果指着第一个，那就不是（7,3）了，就是（12，3）了。当然，表示为（12,3）也可以解压缩，但是有一个问题，就是12这个值比7大，大了又怎么了？我们在生活中会发现一些普遍规律，重复现象往往具有局部性。比如，你跟一个人说话，你说了一句话以后，往往很快会重复一遍，但是你不会隔了5个小时又重复这句话，这种特点在文件里面也存在着，到处都是这种例子，比如你在编程的时候，你定义了一个变量int nCount，这个nCount一般你很快就会用到，不会离得很远。我们前面所说的距离代表了你隔了多久再说这句话，这个距离一般不大，既然如此，应该以离当前字符串距离最近的那个作为记录的依据（也就是指向离自己最近那个重复字符串），这样的话，所有的标记都是一些短距离，比如都是3、4、5、6、7而不会是3、5、78、965等等，如果大多数都是一些短距离，那么这些短距离就可以用短一些的比特表示，长一些的距离不太常见，则用一些长一些的比特表示。这样， 总体的表示长度就会减少。好了，我们前面得到了（5,3）、（7、3）这种记录重复的表示，距离有两种：5、7；长度只有1种：3。咋编码？越短越好。\r\n既然表示的比特越短越好，3表示为0、5表示为10、7表示为11，行不行？这样（5,3）,（7,3）就只需要表示为100、110，这样岂不是很短？貌似可以，貌似很高效。\r\n但解压缩遇到10这两个比特的时候，怎么知道10表示5呢？这种表示方法是一个映射表，称为码表。我们设计的上面这个例子的码表如下：\r\n3--&gt;0\r\n5--&gt;10\r\n7--&gt;11\r\n这个码表也得传过去或者记录在压缩文件里才行啊，否则无法解压缩，但会不会记录了码表以后整体空间又变大了，会不会起不到压缩的作用？而且一个码表怎么记录？码表记录下来也是一堆数据，是不是也需要编码？码表是否可以继续压缩？那岂不是又需要新的码表？压缩会不会是一个永无止境的过程？作为一个入门级的同学，大概想到这儿就不容易想下去了。\r\n&nbsp;\r\n3、ZIP中的LZ编码思想\r\n上面我们说的重复字符串用指针标记记录下来，这种方法就是LZ这两个人提出来的，理解起来比较简单。后面分析（5,3）这种指针标记应该怎么编码的时候，就涉及到一种非常广泛的编码方式，Huffman编码，Huffman大致和香农是一个时代的人，这种编码方式是他在MIT读书的时候提出来的。接下来，我们来看看ZIP是怎么做的。\r\n以上面的例子，一个很简单的示意图如下：\r\n<img src=\"https://images0.cnblogs.com/blog/664058/201409/052301509071245.png\" alt=\"\" width=\"452\" height=\"375\" />\r\n可以看出，ZIP中使用的LZ77算法和前面分析的类似，当然，如果仔细对比的话，ZIP中使用的算法和LZ提出来的LZ77算法其实还是有差异的，不过我建议不用仔细去扣里面的差异，思想基本是相同的，我们后面会简要分析一下两者的差异。LZ77算法一般称为&ldquo;滑动窗口压缩&rdquo;，我们前面说过，该算法的核心是在前面的历史数据中寻找重复字符串，但如果要压缩的文件有100MB，是不是从文件头开始找？不是，这里就涉及前面提过的一个规律，重复现象是具有局部性的，它的基本假设是，如果一个字符串要重复，那么也是在附近重复，远的地方就不用找了，因此设置了一个滑动窗口，ZIP中设置的滑动窗口是32KB，那么就是往前面32KB的数据中去找，这个32KB随着编码不断进行而往前滑动。当然，理论上讲，把滑动窗口设置得很大，那样就有更大的概率找到重复的字符串，压缩率不就更高了？初看起来如此，找的范围越大，重复概率越大，不过仔细想想，可能会有问题，一方面，找的范围越大，计算量会增大，不顾一切地增大滑动窗口，甚至不设置滑动窗口，那样的软件可能不可用，你想想，现在这种方式，我们在压缩一个大文件的时候，速度都已经很慢了，如果增大滑动窗口，速度就更慢，从工程实现角度来说，设置滑动窗口是必须的；另一方面，找的范围越大，距离越远，出现的距离很多，也不利于对距离进行进一步压缩吧，我们前面说过，距离和长度最好出现的值越少越好，那样更好压缩，如果出现的很多，如何记录距离和长度可能也存在问题。不过，我相信滑动窗口设置得越大，最终的结果应该越好一些，不过应该不会起到特别大的作用，比如压缩率提高了5%，但计算量增加了10倍，这显然有些得不偿失。\r\n在第一个图中，&ldquo;容易。&rdquo;是一个重复字符串，距离distance=5，字符串长度length=3。当对这三个字符压缩完毕后，接下来滑动窗口向前移动3个字符，要压缩的是&ldquo;我...&rdquo;这个字符串，但这个串在滑动窗口内没找到，所以无法使用distance+length的方式记录。这种结果称为literal。literal的中文含义是原义的意思，表示没有使用distance+length的方式记录的那些普通字符。literal是不是就用原始的编码方式，比如Unicode方式表示？ZIP里不是这么做的，ZIP把literal认为也是一个数，尽管不能用distance+length表示，但不代表不可以继续压缩。另外，如果&ldquo;我&rdquo;出现在了滑动窗口内，是不是就可以用distance+length的方式表示？也不是，因为一个字出现重复，不值得用这种方式表示，两个字呢？distance+length就是两个整数，看起来也不一定值得，ZIP中确实认为2个字节如果在滑动窗口内找到重复，也不管，只有3个字节以上的重复字符串，才会用distance+length表示，重复字符串的长度越长越好，因为不管多长，都用distance+length表示就行了。\r\n这样的话，一段字符串最终就可以表示成literal、distance+length这两种形式了。LZ系列算法的作用到此为止，下面，Phil Katz考虑使用Huffman对上面的这些LZ压缩后的结果进行二次压缩。个人认为接下来的过程才是ZIP的核心，所以我们要熟悉一下Huffman编码。\r\n&nbsp;\r\n4、ZIP中的Huffman编码思想\r\n上面LZ压缩结果有三类（literal、distance、length），我们拿出distance一类来举例。distance代表重复字符串离前一个一模一样的字符串之间的距离，是一个大于0的整数。如何对一个整数进行编码呢？一种方法是直接用固定长度表示，比如采用计算机里面描述一个4字节整数那样去记录，这也是可以的，主要问题当然是浪费存储空间，在ZIP中，distance这个数表示的是重复字符串之间的距离，显然，一般而言，越小的距离，出现的数量可能越多，而越大的距离，出现的数量可能越少，那么，按照我们前面所说的原则，小的值就用较少比特表示，大的值就用较多比特表示，在我们这个场景里，distance当然也不会无限大，比如不会超过滑动窗口的最大长度，假如对一个文件进行LZ压缩后，得到的distance值为：\r\n3、6、4、3、4、3、4、3、5\r\n这个例子里，3出现了4次，4出现了3次，5出现了1次，6出现了1次。当然，不同的文件得到的结果不同，这里只是举一个典型的例子，因为只有4种值，所以我们没有必要对其它整数编码。只需要对这4个整数进行编码即可。\r\n那么，怎么设计一个算法，符合3的编码长度最短？6的编码长度最长这种直观上可行的原则（我们并没有说这是理论上最优的方式）呢？\r\n看起来似乎很难想出来。我们先来简化一下，用固定长度表示。这里有4个整数，只要使用2个比特表示即可。于是这样表示就很简单：\r\n00--&gt;3； 01--&gt;4； 10--&gt;5;&nbsp; 11--&gt;6。\r\n00、01这种编码结果称为码字，码字的平均长度是2。上面这个对应关系即为码表，在压缩时，需要将码表放在最前面，后面的数字就用码字表示，解码时，先把码表记录在内存里，比如用一个哈希表记录下来，解压缩时，遇到00，就解码为3等等。\r\n因为出现了9个数，所以全部码字总长度为18个比特。（我们暂时不考虑记录码表到底要占多少空间）\r\n想要编码结果更短，因为3出现的最多，所以考虑把3的码字缩短点，比如3是不是可以用1个比特表示，这样才算缩短吧，因为0和1只是二进制的一个标志，所以用0还是1没有本质区别，那么，我们暂定把3用比特0表示。那么，4、5、6还能用0开头的码字表示呢？\r\n这样会存在问题，因为4、5、6的编码结果如果以0开头，那么，在解压缩的时候，遇到比特0，就不知道是表示3还是表示4、5、6了，就无法解码，当然，似乎理论上也不是不可以，比如可以往后解解看，比如假定0表示3的条件下往后解，如果无效则说明这个假设不对，但这种方式很容易出现两个字符串的编码结果是一样的，这个谁来保证？所以，4、5、6都得以1开头才行，那么，按照这个原则，4用1个比特也不行，因为5、6要么以0开头，要么以1开头，就无法编码了，所以我们将4的码字增加至2个比特，比如10，于是我们得到了部分码表:\r\n0--&gt;3；10--&gt;4。\r\n按照这个道理，5、6既不能以0开头，也不能以10开头了，因为同样存在无法解码的问题，所以5应该以11开头，就定为11行不行呢？也不行，因为6就不知道怎么编码了，6也不能以0开头，也不能以10、11开头，那就无法表示了，所以，迫不得已，我们必须把5扩展一位，比如110，那么，6显然就可以用111表示了，反正也没有其他数了。于是我们得到了最终的码表：\r\n0--&gt;3；10--&gt;4；110--&gt;5；111--&gt;6。\r\n看起来，编码结果只能是这样了，我们来算一下，码字的总长度减少了没有，原来的9个数是3、6、4、3、4、3、4、3、5，分别对应的码字是：\r\n0、111、10、0、10、0、10、0、110\r\n算一下，总共16个比特，果然比前面那种方式变短了。我们在前面的设计过程中，是按照这些值出现次数由高到底的顺序去找码字的，比如先确定3，再确定4、5、6等等。按照一个码字不能是另一个码字的前缀这一规则，逐步获得所有的码字。这种编码规则有一个专用术语，称为前缀码。Huffman编码基本上就是这么做的，把出现频率排个序，然后逐个去找，这个逐个去找的过程，就引入了二叉树。不过Huffman的算法一般是从频率由低到高排序，从树的下面依次往上合并，不过本质上没区别，理解思想即可。上面的结果可以用一颗二叉树表示为下图：\r\n<img src=\"https://images0.cnblogs.com/blog/664058/201409/060122501881755.png\" alt=\"\" width=\"266\" height=\"186\" />\r\n这棵树也称为码树，其实就是码表的一种形式化描述，每个节点（除了叶子节点）都会分出两个分支，左分支代表比特0，右边分支代表1，从根节点到叶子节点的一个比特序列就是码字。因为只有叶子节点可以是码字，所以这样也符合一个码字不能是另一个码字的前缀这一原则。说到这里，可以说一下另一个话题，就是一个映射表map在内存中怎么存储，没有相关经验的可以跳过，map实现的是key--&gt;value这样的一个表，map的存储一般有哈希表和树形存储两类，树形存储就可以采用上面这棵树，树的中间节点并没有什么含义，叶子节点的值表示value，从根节点到叶子节点上分支的值就是key，这样比较适合存储那些key由多个不等长字符组成的场合，比如key如果是字符串，那么把二叉树的分支扩展很多，成为多叉树，每个分支就是a,b,c,d这种字符，这棵树也就是Trie树，是一种很好使的数据结构。利用树的遍历算法，就实现了一个有序Map。\r\n好了，我们理解了Huffman编码的思想，我们来看看distance的实际情况。ZIP中滑动窗口大小固定为32KB，也就是说，distance的值范围是1-32768。那么，通过上面的方式，统计频率后，就得到32768个码字，按照上面这种方式可以构建出来。于是我们会遇到一个最大的问题，那就是这棵树太大了，怎么记录呢？\r\n好了，个人认为到了ZIP的核心了，那就是码树应该怎么缩小，以及码树怎么记录的问题。\r\n&nbsp;\r\n5、ZIP中Huffman码树的记录方式\r\n分析上面的例子，看看这个码表：\r\n0--&gt;3；10--&gt;4；110--&gt;5；111--&gt;6。\r\n我们之前提过，0和1就是二进制的一个标志，互换一下其实根本不影响编码长度，所以，下面的码表其实是一样的：\r\n1--&gt;3；00--&gt;4；010--&gt;5；011--&gt;6。\r\n1--&gt;3；01--&gt;4；000--&gt;5；001--&gt;6。\r\n0--&gt;3；11--&gt;4；100--&gt;5；101--&gt;6。\r\n。。。。。\r\n这些都可以，而且编码长度完全一样，只是码字不同而已。\r\n对比一下第一个和第二个例子，对应的码树是这个样子：\r\n<img src=\"https://images0.cnblogs.com/blog/664058/201409/060206060639066.png\" alt=\"\" width=\"520\" height=\"194\" />\r\n也就是说，我们把码树的任意节点的左右分支旋转（0、1互换），也可以称为树的左右互换，其实不影响编码长度，也就是说，这些码表其实都是一样好的，使用哪个都可以。\r\n这个规律暗示了什么信息呢？暗示了码表可以怎么记录呢？Phil Katz当年在牢里也深深地思考了这一问题。\r\n为了体会Phil Katz当时的心情，我们有必要盯着这两棵树思考几分钟：怎么把一颗树用最少的比特记录下来？\r\nPhil Katz当时思考的逻辑我猜是这样的，既然这些树的压缩程度都一样，那干脆使用最特殊的那棵树，反正压缩程度都一样，只要ZIP规定了这棵树的特殊性，那么我记录的信息就可以最少，这种特殊化的思想在后面还会看到。不同的树当然有不同的特点，比如数据结构里面常见的平衡树也是一类特殊的树，他选的树就是左边那棵，这棵树有一个特点，越靠左边越浅，越往右边越深，是这些树中最不平衡的树。ZIP里的压缩算法称为Deflate算法，这棵树也称为Deflate树，对应的解压缩算法称为Inflate，Deflate的大致意思是把轮胎放气了，意为压缩；Inflate是给轮胎打气的意思，意为解压。那么，Deflate树的特殊性又带来什么了？\r\n揭晓答案吧，Phil Katz认为换来换去只有码字长度不变，如果规定了一类特殊的树，那么就只需要记录码字长度即可。比如，一个有效的码表是0--&gt;3；10--&gt;4；110--&gt;5；111--&gt;6。但只需要记录这个对应关系即可：\r\n3　　4　　5　　6\r\n1　　2　　3　　3\r\n也就是说，把1、2、3、3记录下来，解压一边照着左边那棵树的形状构造一颗树，然后只需要1、2、3、3这个信息自然就知道是0、10、110、111。这就是Phil Katz想出来的ZIP最核心的一点：这棵码树用码字长度序列记录下来即可。\r\n当然，只把1、2、3、3这个序列记录下来还不行，比如不知道111对应5还是对应6？\r\n所以，构造出树来只是知道了有哪些码字了，但是这些码字到底对应哪些整数还是不知道。\r\nPhil Katz于是又出现了一个想法：记录1、2、3、3还是记录1、3、2、3，或者3、3、2、1，其实都能构造出这棵树来，那么，为什么不按照一个特殊的顺序记录呢？这个顺序就是整数的大小顺序，比如上面的3、4、5、6是整数大小顺序排列的，那么，记录的顺序就是1、2、3、3。而不是2、3、3、1。\r\n好了，根据1、2、3、3这个信息构造出了码字，这些码字对应的整数一个比一个大，假如我们知道编码前的整数就是3、4、5、6这四个数，那就能对应起来了，不过到底是哪四个还是不知道啊？这个整数可以表示距离啊，距离不知道怎么去解码LZ？\r\nPhil Katz又想了，既然distance的范围是1-32768，那么就按照这个顺序记录。上面的例子1和2没有，那就记录长度0。所以记录下来的码字长度序列为：\r\n0、0、1、2、3、3、0、0、0、0、0、。。。。。。。。。。。。\r\n这样就知道构造出来的码字对应哪个整数了吧，但因为distance可能的值很多（32768个），但实际出现的往往不多，中间会出现很多0（也就是根本就没出现这个距离），不过这个问题倒是可以对连续的0做个特殊标记，这样是不是就行了呢？还有什么问题？\r\n我们还是要站在时代的高度来看待这个问题。我们明白，每个distance肯定对应唯一一个码字，使用Huffman编码可以得到所有码字，但是因为distance可能非常多，虽然一般不会有32768这么多，但对一个大些的文件进行LZ编码，distance上千还是很正常的，所以这棵树很大，计算量、消耗的内存都容易超越了那个时代的硬件条件，那么怎么办呢？这里再次体现了Phil Katz对Huffman编码掌握的深度，他把distance划分成多个区间，每个区间当做一个整数来看，这个整数称为Distance Code。当一个distance落到某个区间，则相当于是出现了那个Code，多个distance对应于一个Distance Code，Distance虽然很多，但Distance Code可以划分得很少，只要我们对Code进行Huffman编码，得到Code的编码后，Distance Code再根据一定规则扩展出来。那么，划分多少个区间？怎么划分区间呢？我们分析过，越小的距离，出现的越多；越大的距离，出现的越少，所以这种区间划分不是等间隔的，而是越来越稀疏的，类似于下面的划分：\r\n<img src=\"https://images0.cnblogs.com/blog/664058/201409/060258556575636.png\" alt=\"\" width=\"644\" height=\"37\" />\r\n1、2、3、4这四个特殊distance不划分，或者说1个Distance就是1个区间；5,6作为一个区间；7、8作为一个区间等等，基本上，区间的大小都是1、2、4、8、16、32这么递增的，越往后，涵盖的距离越多。为什么这么分呢？首先自然是距离越小出现频率越高，所以距离值小的时候，划分密一些，这样相当于一个放大镜，可以对小的距离进行更精细地编码，使得其编码长度与其出现次数尽量匹配；对于距离较大那些，因为出现频率低，所以可以适当放宽一些。另一个原因是，只要知道这个区间Code的码字，那么对于这个区间里面的所有distance，后面追加相应的多个比特即可，比如，17-24这个区间的Huffman码字是110，因为17-24这个区间有8个整数，于是按照下面的规则即可获得其distance对应的码字：\r\n17--&gt;110 000\r\n18--&gt;110 001\r\n19--&gt;110 010\r\n20--&gt;110 011\r\n21--&gt;110 100\r\n22--&gt;110 101\r\n23--&gt;110 110\r\n24--&gt;110 111\r\n这样计算复杂度和内存消耗是不是很小了，因为需要进行Huffman编码的整数一下字变少了，这棵树不会多大，计算起来时间和空间复杂度降低，扩展起来也比较简单。当然，从理论上来说，这样的编码方式实际上将编码过程分为了两级，并不是理论上最优的，把所有distance当作一个大空间去编码才可能得到最优结果，不过还是那句话，工程实现的限制，在压缩软件实现上，我们不能用压缩率作为衡量一个算法优劣的唯一指标，其实耗费的时间和空间同样是指标，所以需要看综合指标。很多其他软件也一样，扩展性、时间空间复杂度、稳定性、移植性、维护的方便性等等是工程上很重要的东西。我没有看过RAR是如何压缩的，有可能是在类似的地方进行了改进，如果如此，那也是站在巨人的肩膀上，而且硬件条件不同，进行一些改进也并不奇怪。\r\n具体来说，Phil Katz把distance划分为30个区间，如下图：\r\n<img src=\"https://images0.cnblogs.com/blog/664058/201409/060320202197696.png\" alt=\"\" width=\"575\" height=\"257\" />\r\n这个图是我从David Salomon的《Data Compression The Complete Reference》这本书（第四版）中拷贝出来的，下面的有些图也是，如果需要对数据压缩进行全面的了解，这本书几乎是最全的了，强烈推荐。\r\n当然，你要问为什么是30个区间，我也没分析过，也许是复杂度和压缩率经过试验之后的一种折中吧。\r\n其中，左边的Code表示区间的编号，是0-29，共30个区间，这只是个编号，没有特别的含义，但Huffman就是对0-29这30个Code进行编码的，得到区间的码字；\r\nbits表示distance的码字需要在Code的码字基础上扩展几位，比如0就表示不扩展，最大的13表示要扩展13位，因此，最大的区间包含的distance数量为8192个。\r\nDistance一列则表示这个区间涵盖的distance范围。\r\n理解了码树如何有效记录，以及如何缩小码树的过程，我觉得就理解了ZIP的精髓。\r\n&nbsp;\r\n6、ZIP中literal和length的压缩方式\r\n说完了distance，LZ编码结果还有两类：literal和length。这两类也利用了类似于distance的方式进行压缩。\r\n前面分析过，literal表示未匹配的字符，我们前面之所以拿汉字来举例，完全是为了便于理解，ZIP之所以是通用压缩，它实际上是针对字节作为基本字符来编码的，所以一个literal至多有256种可能。\r\nlength表示重复字符串长度，length=1当然不会出现，因为一个字符不值得用distance+length去记录，重复字符串当然越长越好，Phil Katz（下面还是简称PK了，拷贝太麻烦）认为，length=2也不值得用这种方式记录，还是太短了，所以PK把length最小值认为是3，必须3个以上字符的字符串出现重复才用distance+length记录。那么，最大的length是多少呢？理论上当然可以很长很长，比如一个文件就是连续的0，这个重复字符串长度其实接近于这个文件的实际长度。但是PK把length的范围做了限制，限定length的个数跟literal一样，也只有256个，因为PK认为，一个重复字符串达到了256个已经很长了，概率非常小；另外，其实哪怕超过了256，我还是认为是一段256再加上另外一段，增加一个distance+length就行了嘛，并不影响结果。而且这样做，我想同样也考虑了硬件条件吧。\r\n初看有点奇怪的在于，将literal和length二者合二为一，什么意思呢？就是对这两种整数（literal本质上是一个字节）共用一个Huffman码表，一会儿解释为什么。PK对Huffman的理解我觉得达到了炉火纯青的地步，前面已经看到，后面还会看到。他认为Huffman编码的输入反正说白了就是一个集合的元素就行，无论这个元素是啥，所以多个集合看做一个集合当作Huffman编码的输入没啥问题。literal用整数0-255表示，256是一个结束标志，解码以后结果是256表示解码结束；从257开始表示length，所以257这个数表示length=3，258这个数表示length=4等等，但PK也不是一直这么一一对应，和distance一样，也是把length（总共256个值）划分为29个区间，其结果如下图：\r\n<img src=\"https://images0.cnblogs.com/blog/664058/201409/060343553448800.png\" alt=\"\" width=\"572\" height=\"283\" />\r\n其中的含义和distance类似，不再赘述，所以literal/length这个Huffman编码的输入元素一共285个，其中256表示解码结束标志。为什么要把二者合二为一呢？因为当解码器接收到一个比特流的时候，首先可以按照literal/length这个码表来解码，如果解出来是0-255，就表示未匹配字符，如果是256，那自然就结束，如果是257-285之间，则表示length，把后面扩展比特加上形成length后，后面的比特流肯定就表示distance，因此，实际上通过一个Huffman码表，对各类情况进行了统一，而不是通过加一个什么标志来区分到底是literal还是重复字符串。\r\n好了，理解了上面的过程，就理解了ZIP压缩的第二步，第一步是LZ编码，第二步是对LZ编码后结果（literal、distance、length）进行的再编码，因为literal/length是一个码表，我称其为Huffman码表1，distance那个码表称为Huffman码表2。前面我们已经分析了，Huffman码树用一个码字长度序列表示，称为CL（Code Length），记录两个码表的码字长度序列分别记为CL1、CL2。码树记录下来，对literal/length的编码比特流称为LIT比特流；对distance的编码比特流称为DIST比特流。\r\n按照上面的方法，LZ的编码结果就变成四块：CL1、CL2、LIT比特流、DIST比特流。CL1、CL2是码字长度的序列，这个序列说白了就是一堆正整数，因此，PK继续深挖，认为这个序列还应该继续压缩，也就是说，对码表进行压缩。\r\n&nbsp;\r\n7、ZIP中对CL进行再次压缩的方法\r\n这里仍然沿用Huffman的想法，因为CL也是一堆整数，那么当然可以再次应用Huffman编码。不过在这之前，PK对CL序列进行了一点处理。这个处理也是很精巧的。\r\nCL序列表示一系列整数对应的码字长度，对于literal/length来说，总共有0-285这么多符号，所以这个序列长度为286，每个符号都有一个码字长度，当然，这里面可能会出现大段连续的0，因为某些字符或长度不存在，尤其是对英文文本编码的时候，非ASCII字符就根本不会出现，length较大的值出现概率也很小，所以出现大段的0是很正常的；对于distance也类似，也可能出现大段的0。PK于是先进行了一下游程编码。在说什么是游程编码之前，我们谈谈PK对CL序列的认识。\r\nliteral/length的编码符号总共286个（回忆：256个Literal+1个结束标志+29个length区间），distance的编码符号总共30个（回忆：30个区间），所以这颗码树不会特别深，Huffman编码后的码字长度不会特别长，PK认为最长不会超过15，也就是树的深度不会超过15，这个是否是理论证明我还没有分析，有兴趣的同学可以分析一下。因此，CL1和CL2这两个序列的任意整数值的范围是0-15。0表示某个整数没有出现（比如literal=0x12, length Code=8, distance Code=15等等）。\r\n什么叫游程呢？就是一段完全相同的数的序列。什么叫游程编码呢？说起来原理更简单，就是对一段连续相同的数，记录这个数一次，紧接着记录出现了多少个即可。David的书中举了这个例子，比如CL序列如下：\r\n4, 4, 4, 4, 4, 3, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2<br />那么，游程编码的结果为：\r\n4, 16, 01（二进制）, 3, 3, 3, 6, 16, 11（二进制）, 16, 00（二进制）, 17,011（二进制）, 2, 16, 00（二进制）<br />这是什么意思呢？因为CL的范围是0-15，PK认为重复出现2次太短就不用游程编码了，所以游程长度从3开始。用16这个特殊的数表示重复出现3、4、5、6个这样一个游程，分别后面跟着00、01、10、11表示（实际存储的时候需要低比特优先存储，需要把比特倒序来存，博文的一些例子有时候会忽略这点，实际写程序的时候一定要注意，否则会得到错误结果）。于是4,4,4,4,4,这段游程记录为4,16,01，也就是说，4这个数，后面还会连续出现了4次。6,16,11,16,00表示6后面还连续跟着6个6，再跟着3个6；因为连续的0出现的可能很多，所以用17、18这两个特殊的数专门表示0游程，17后面跟着3个比特分别记录长度为3-10（总共8种可能）的游程；18后面跟着7个比特表示11-138（总共128种可能）的游程。17,011（二进制）表示连续出现6个0；18,0111110（二进制）表示连续出现62个0。总之记住，0-15是CL可能出现的值，16表示除了0以外的其它游程；17、18表示0游程。因为二进制实际上也是个整数，所以上面的序列用整数表示为：\r\n4, 16, 1, 3, 3, 3, 6, 16, 3, 16, 0, 17, 3, 2, 16, 0\r\n我们又看到了一串整数，这串整数的值的范围是0-18。这个序列称为SQ（Sequence的意思）。因为有两个CL1、CL2，所以对应的有两个SQ1、SQ2。\r\n针对SQ1、SQ2，PK用了第三个Huffman码表来对这两个序列进行编码。通过统计各个整数（0-18范围内）的出现次数，按照相同的思路，对SQ1和SQ2进行了Huffman编码，得到的码流记为SQ1 bits和SQ2 bits。同时，这里又需要记录第三个码表，称为Huffman码表3。同理，这个码表也用相同的方法记录，也等效为一个码长序列，称为CCL，因为至多有0-18个，PK认为树的深度至多为7，于是CCL的范围是0-7。\r\n当得到了CCL序列后，PK决定不再折腾，对这个序列用普通的3比特定长编码记录下来即可，即000代表0,111代表7。但实际上还有一点小折腾，就是最后这个序列如果全部记录，那就需要19*3=57个比特，PK认为CL序列里面CL范围为0-15，特殊的几个值是16、17、18，如果把CCL序列位置置换一下，把16、17、18这些放前面，那么这个CCL序列就很可能最后面跟着一串0（因为CL=14,15这些很可能没有），所以最后还引入了一个置换，其示意图如下，分别表示置换前的CCL序列和置换后的CCL。可以看出，16、17、18对应的CCL被放到了前面，这样如果尾部出现了一些0，就只需要记录CCL长度即可，后面的0不记录。可以继续节省一些比特，不过这个例子尾部置换后只有1个0：\r\n<img src=\"https://images0.cnblogs.com/blog/664058/201409/061527354536186.png\" alt=\"\" width=\"614\" height=\"100\" />\r\n不过粗看起来，这个置换效果并不好，我一开始接触这个置换的时候，我觉得应该按照16、17、18、0、1、2、3、。。。这样的顺序来存储，如果按照我理解的，那么置换后的结果如下：\r\n2、4、0、4、5、5、1、5、0、6、0、0、0、0、0、0、0、0、0\r\n这样后面的一大串0直接截断，比PK的方法更短。但PK却按照上面的顺序。我总是认为，我觉得牛人可能出错了的时候，往往是我自己错了，所以我又仔细想了一下，上面的顺序特点比较明显，直观上看，PK认为CL为0和中间的值出现得比较多（放在了前面），但CL比较小的和比较大的出现得比较少（1、15、2、14这些放在了后面，你看，后面交叉着放），在文件比较小的时候，这种方法效果不算好，上面就是一个典型的例子，但文件比较大了以后，CL1、CL2码树比较大，码字长度普遍比较长，大部分很可能接近于中间值，那么这个时候PK的方法可能就体现出优势了。不得不说，对一个算法或者数据结构的优化程度，简直完全取决于程序员对那个东西细节的理解的深度。当我仔细研究了ZIP压缩算法的过程之后，我对PK这种深夜埋头冥思苦想的大牛佩服得五体投地。\r\n到此为止，ZIP压缩算法的结果已经完毕。这个算法命名为Deflate算法。总结一下其编码流程为：<br /><img src=\"https://images0.cnblogs.com/blog/664058/201409/060435217505419.png\" alt=\"\" width=\"599\" height=\"305\" />\r\n&nbsp;\r\n8、Deflate压缩数据格式\r\nZIP的格式实际上就是Deflate压缩码流外面套了一层文件相关的信息，这里先介绍Deflate压缩码流格式。其格式为：\r\n<img src=\"https://images0.cnblogs.com/blog/664058/201409/060437425949657.png\" alt=\"\" width=\"527\" height=\"238\" />\r\nHeader：3个比特，第一个比特如果是1，表示此部分为最后一个压缩数据块；否则表示这是.ZIP文件的某个中间压缩数据块，但后面还有其他数据块。这是ZIP中使用分块压缩的标志之一；第2、3比特表示3个选择：压缩数据中没有使用Huffman、使用静态Huffman、使用动态Huffman，这是对LZ77编码后的literal/length/distance进行进一步编码的标志。我们前面分析的都是动态Huffman，其实Deflate也支持静态Huffman编码，静态Huffman编码原理更为简单，无需记录码表（因为PK自己定义了一个固定的码表），但压缩率不高，所以大多数情况下都是动态Huffman。\r\nHLIT：5比特，记录literal/length码树中码长序列（CL1）个数的一个变量。后面CL1个数等于HLIT+257（因为至少有0-255总共256个literal，还有一个256表示解码结束，但length的个数不定）。\r\nHDIST：5比特，记录distance码树中码长序列（CL2）个数的一个变量。后面CL2个数等于HDIST+1。哪怕没有1个重复字符串，distance都为0也是一个CL。\r\nHCLEN：4比特，记录Huffman码表3中码长序列（CCL）个数的一个变量。后面CCL个数等于HCLEN+4。PK认为CCL个数不会低于4个，即使对于整个文件只有1个字符的情况。\r\n接下来是3比特编码的CCL，一共HCLEN+4个，用以构造Huffman码表3；\r\n接下来是对CL1（码长）序列经过游程编码（SQ1：缩短的整数序列）后，并对SQ1继续用Huffman编码后的比特流。包含HLIT+257个CL1，其解码码表为Huffman码表3，用以构造Huffman码表1；\r\n接下来是对CL2（码长）序列经过游程编码（SQ2：缩短的整数序列）后，并对SQ2继续用Huffman编码后的比特流。包含HDIST+1个CL2，其解码码表为Huffman码表3，用于构造Huffman码表2；\r\n总之，上面的数据都是为了构造LZ解码需要的2个Huffman码表。\r\n接下来才是经过Huffman编码的压缩数据，解码码表为Huffman码表1和码表2。<br />最后是数据块结束标志，即literal/length这个码表输入符号位256的编码比特。<br />对倒数第1、2内容块进行解码时，首先利用Huffman码表1进行解码，如果解码所得整数位于0-255之间，表示literal未匹配字符，接下来仍然利用Huffman码表1解码；如果位于257-285之间，表示length匹配长度，之后需要利用Huffman码表2进行解码得到distance偏移距离；如果等于256，表示数据块解码结束。\r\n&nbsp;\r\n9、ZIP文件格式解析\r\n&nbsp;上面各节对ZIP的原理进行了分析，这一节我们来看一个实际的例子，为了更好地描述，我们尽量把这个例子举得简单一些。下面是我随便从一本书拷贝出来的一段较短的待压缩的英文文本数据：\r\nAs mentioned above,there are many kinds of wireless systems other than cellular.\r\n这段英文文本长度为80字节。经过ZIP压缩后，其内容如下：\r\n<img src=\"https://images0.cnblogs.com/blog/664058/201409/061434435788044.png\" alt=\"\" width=\"603\" height=\"194\" />\r\n可以看到，第1、2字节就是PK。看着怎么比原文还长，这怎么叫压缩？实际上，这里面大部分内容是ZIP的文件标记开销，真正压缩的内容（也就是我们前面提到的Deflate数据，划线部分都是ZIP文件开销）其实肯定要比原文短（否则ZIP不会启用压缩），我们这个例子是个短文本，但对于更长的文本而言，那ZIP文件总体长度肯定是要短于原始文本的。上面的这个ZIP文件，可以看到好几个以PK开头的区域，也就是不同颜色的划线区域，这些其实都是ZIP文件本身的开销。\r\n所以，我们首先来看一看ZIP的格式，其格式定义为：\r\n[local file header 1]<br />[file data 1]<br />[data descriptor 1]<br />..........<br />[local file header n]<br />[file data n]<br />[data descriptor n]<br />[archive decryption header] <br />[archive extra data record] <br />[central directory]<br />[zip64 end of central directory record]<br />[zip64 end of central directory locator] <br />[end of central directory record]<br />local file header+file data+data descriptor这是一段ZIP压缩数据，在一个ZIP文件里，至少有一段，至多那就不好说了，假如你要压缩的文件一共有10个，那这个地方至少会有10段，ZIP对每个文件进行了独立压缩，RAR在此进行了改进，将多个文件联合起来进行压缩，提高了压缩率。local file header的格式如下：\r\n<img src=\"https://images0.cnblogs.com/blog/664058/201409/061359166257241.png\" alt=\"\" width=\"502\" height=\"319\" />\r\n可见，起始的4个字节就是0x50（P）、0x4B（K）、0x03、0x04，因为是低字节优先，所以Signature=0x03044B50.接下来的内容按照上面的格式解析，十分简单，这个区域在上面ZIP数据的那个图里面是红色划线区域，之后则是压缩后的Deflate数据。在文件的尾部，还有ZIP尾部数据，上面这个例子包含了central directory和end of central directory record，一般这两部分也是必须的。central directory以0x50、0x4B、0x01、0x02开头；end of central directory record以0x50、0x4B、0x05、0x06开头，其含义比较简单，分别对应于上面ZIP数据那个图的蓝色和绿色部分，下面是两者的格式：\r\n<img src=\"https://images0.cnblogs.com/blog/664058/201409/061423162666357.png\" alt=\"\" width=\"737\" height=\"399\" />\r\nend of central directory record格式：\r\n<img src=\"https://images0.cnblogs.com/blog/664058/201409/061423440169079.png\" alt=\"\" width=\"515\" height=\"307\" />\r\n这几张图是我从网上找的，写得比较清晰。对于其中的含义，解释起来也比较简单，我分析的结果如下：注意ZIP采用的低字节优先，在一个字节里面低位优先，需要反过来看。\r\nLocal File Header: (38B,304b)<br />00001010110100101100000000100000 (signature)<br />0000000000010100 (version:20)<br />0000000000000000 (generalBitFlag)<br />0000000000001000 (compressionMethod:8)<br />0100110110001110 (lastModTime:19854)<br />0100010100100101 (lastModDate:17701)<br />01010100101011010100001100111100 (CRC32)<br />00000000000000000000000001001000 (compressedSize:72)<br />00000000000000000000000001010000 (uncompressedSize:80)<br />0000000000001000 (filenameLength:8)<br />0000000000000000 (extraFieldLength:0)<br />0010101010100110110011100010111001110100001011100001111000101110 (fileName:Test.txt)<br />&nbsp;(extraField)<br /><br /><br />Central File Header: (54B,432b)<br />00001010110100101000000001000000 (signature)<br />0000000000010100 (versionMadeBy:20)<br />0000000000010100 (versionNeeded:20)<br />0000000000000000 (generalBitFlag)<br />0000000000001000 (compressionMethod:8)<br />0100110110001110 (lastModTime:19854)<br />0100010100100101 (lastModDate:17701)<br />01010100101011010100001100111100 (CRC32)<br />00000000000000000000000001001000 (compressedSize:72)<br />00000000000000000000000001010000 (uncompressedSize:80)<br />0000000000001000 (filenameLength:8)<br />0000000000000000 (extraFieldLength:0)<br />0000000000000000 (fileCommenLength:0)<br />0000000000000000 (diskNumberStart)<br />0000000000000001 (internalFileAttr)<br />10000001100000000000000000100000 (externalFileAttr)<br />00000000000000000000000000000000 (relativeOffsetLocalHeader)<br />0010101010100110110011100010111001110100001011100001111000101110 (fileName:Test.txt)<br />&nbsp;(extraField)<br />&nbsp;(fileComment)<br /><br /><br />end of Central Directory Record: (22B,176b)<br />00001010110100101010000001100000 (signature)<br />0000000000000000 (numberOfThisDisk:0)<br />0000000000000000 (numberDiskCentralDirectory:0)<br />0000000000000001 (EntriesCentralDirectDisk:1)<br />0000000000000001 (EntriesCentralDirect:1)<br />00000000000000000000000000110110 (sizeCentralDirectory:54)<br />00000000000000000000000001101110 (offsetStartCentralDirectory:110)<br />0000000000000000 (fileCommentLength:0)<br />&nbsp;(fileComment)<br /><br />Local File Header Length:304<br />Central File Header Length:432<br />End Central Directory Record Length:176\r\n可见，开销总的长度为38+54+22=114字节，整个文件长度为186字节，因此Deflate压缩数据长度为72字节（576比特）。尽管这里看起来只是从80字节压缩到72字节，那是因为这是一段短文本，重复字符串出现较少，但如果文本较长，那压缩率就会增加，这里只是举个例子。\r\n下面对其中的关键部分，也就是Deflate压缩数据进行解析。\r\n&nbsp;\r\n10，Deflate解码过程实例分析\r\n我们按照ZIP格式把Deflate压缩数据（72字节）提取出来，如下（每行8字节）：\r\n1010100001010011100010111011000000000001000001000011000010100010<br />1000101110101010011110110000000001100011101110000011100010100101<br />0101001111001100000010001101001010010010000101101010101100001101<br />1011110100011111100011101111111001110010011101110110011100010101<br />0010110100010100101100110001100100000100110111101101111000011101<br />0010001001100110111001000010011001101010101000110110000001110101<br />0100011010010011100010110111001000111101101001011100101010010111<br />0111000011111000011110000011010111001011011111111100100010001001<br />1010001100001110000010101010111101101010100101111101011111100000\r\nDeflate格式除了上面的介绍，也可以参考RFC1951，解析如下：\r\nHeader:101, 第一个比特是1，表示此部分为最后一个压缩数据块；后面的两个比特01表示采用动态哈夫曼、静态哈夫曼、或者没有编码的标志，01表示采用动态Huffman；在RFC1951里面是这么说明的：\r\n00 - no compression \r\n01 - compressed with fixed Huffman codes \r\n10 - compressed with dynamic Huffman codes \r\n11 - reserved (error)\r\n注意，这里需要按照低比特在先的方式去看，否则会误以为是静态Huffman。\r\n接下来：<br />HLIT:01000,记录literal/length码树中码长序列个数的一个变量，表示HLIT=2（低位在前），说明后面存在HLIT + 257=259个CL1，CL1即0-258被编码后的长度，其中0-255表示Literal，256表示无效符号，257、258分别表示Length=3、4（length从3开始）。因此，这里实际上只出现了两种重复字符串的长度，即3和4。回顾这个图可以更清楚：\r\n<img src=\"https://images0.cnblogs.com/blog/664058/201409/061456224852421.png\" alt=\"\" width=\"422\" height=\"208\" />\r\n继续：<br />HDIST:01010,记录distance码树中码长序列个数的一个变量，表示HDIST=10，说明后面存在HDIST+1=11个CL2，CL2即Distance Code=0-10被编码的长度。\r\n继续：\r\nHCLEN:0111,记录Huffman码树3中码长序列个数的一个变量，表示HCLEN=14（1110二进制），即说明紧接着跟着HCLEN+4=18个CCL，前面已经分析过，CCL记录了一个Huffman码表，这个码表可以用一个码长序列表示，根据这个码长序列可以得到码表。于是接下来我们把后面的18*3=54个比特拷贝出来，上面的码流目前解析为下面的结果：\r\n101(Header) 01000(HLIT) 01010(HDIST) 0111(HCLEN) <br />000 101 110 110 000 000 000 010 000 010 000 110 000 101 000 101 000 101 (CCL)<br />110101010011110110000000001100011101110000011100010100101<br />0101001111001100000010001101001010010010000101101010101100001101<br />1011110100011111100011101111111001110010011101110110011100010101<br />0010110100010100101100110001100100000100110111101101111000011101<br />0010001001100110111001000010011001101010101000110110000001110101<br />0100011010010011100010110111001000111101101001011100101010010111<br />0111000011111000011110000011010111001011011111111100100010001001<br />1010001100001110000010101010111101101010100101111101011111100000\r\n标准的CCL长度为19（回忆一下：CCL范围为0-18，按照整数大小排序记录各自的码字长度），因此最后一个补0。得到序列：\r\n000 101 110 110 000 000 000 010 000 010 000 110 000 101 000 101 000 101 000\r\n其长度分别为（低位在前）：<br />0、5、3、3、0、0、0、2、0、2、0、3、0、5、0、5、0、5、0<br />前面已经分析过，这个CCL序列实际上是经过一次置换操作得到的，需要进行相反的置换，置换后为：\r\n3、5、5、5、3、2、2、0、0、0、0、0、0、0、0、0、0、5、3<br />这个就是对应于0-18的码字长度序列。<br />根据Deflate树的构造方式，得到下面的码表（Huffman码表3）：\r\n00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;--&gt;&nbsp;&nbsp; 5<br />01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;--&gt;&nbsp;&nbsp; 6<br />100&nbsp;&nbsp;&nbsp;&nbsp; &lt;--&gt;&nbsp; 0<br />101&nbsp;&nbsp;&nbsp;&nbsp; &lt;--&gt;&nbsp; 4<br />110&nbsp;&nbsp;&nbsp;&nbsp; &lt;--&gt;&nbsp; 18<br />11100&nbsp;&nbsp; &lt;--&gt;1<br />11101&nbsp;&nbsp; &lt;--&gt;2<br />11110&nbsp;&nbsp; &lt;--&gt;3<br />11111&nbsp;&nbsp; &lt;--&gt;17\r\n接下来就是CL1序列，按照前面的指示，一共有259个，分别对应于literal/length：0-258对应的码字长度序列，我们队跟着CCL后面的比特按照上面获得的码表进行逐步解码，在解码之前，实际上并不知道CL1的比特流长度有多少，需要根据259这个数字来判定，解完了259个整数，表明解析CL1完毕：\r\n101(Header) 01000(HLIT) 01010(HDIST) 0111(HCLEN) <br />000 101 110 110 000 000 000 010 000 010 000 110 000 101 000 101 000 101 (CCL)\r\n110（18）1010100（7比特，记录连续的11-138个0，此处一共0010101b=21，即记录21+11=32个0）\r\n11110（3）110（18）0000000（7比特，记录连续的11-138个0，此处为全0，即记录0+11=11个0）\r\n01（6）100（0）01（6）110（18）1110000（7比特，记录连续的11-138个0，此处为111b=7，即记录7+11=18个0）\r\n01（6）110（18）0010100（7比特，记录连续的11-138个0，此处为10100b=20，即记录20+11=31个0）\r\n101（4）01（6）01（6）00（5）11110（3）01（6）100（0）00（5）00（5）100（0）01（6）101（4）\r\n00（5）101（4）00（5）100（0）100（0）00（5）101（4）101（4）01（6）01（6）01（6）100（0）\r\n00（5）110（18）1101111（7比特，记录连续的11-138个0，此处为1111011b=123，即记录123+11=134个0）\r\n统计一下，上面已经解了32+11+18+31+134+30=256个数了，因为总共259个，还差三个：\r\n01（6）00（5）01（6）\r\n好了，CL1比特流解析完毕了，得到的CL1码长序列为：\r\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 <strong><span style=\"color: #0000ff;\">3</span></strong> 0 0 0 0 0 0 0 <br />0 0 0 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 <br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 6 6 5 3 6 0 5 5 0 6 4 5 4 5 0 0 5 4 4 6 6 6 <br />0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 <br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 <br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 <br />0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<strong><span style=\"color: #ff0000;\"> 6 5 6 </span></strong>\r\n总共259个，每行40个。根据这个序列，同样按照Deflate树构造方法，得到literal/length码表（Huffman码表1）为：\r\n<span style=\"color: #0000ff;\">000&nbsp;&nbsp;&nbsp;&nbsp; --&gt; (System.Char)（看前面的CL1序列，空格对应的ASCII为0x20=32，码字长度3，即上面序列中第一个3）</span><br />001&nbsp;&nbsp;&nbsp;&nbsp; --&gt;e(System.Char)<br />0100&nbsp;&nbsp;&nbsp; --&gt;a(System.Char)<br />0101&nbsp;&nbsp;&nbsp; --&gt;l(System.Char)<br />0110&nbsp;&nbsp;&nbsp; --&gt;n(System.Char)<br />0111&nbsp;&nbsp;&nbsp; --&gt;s(System.Char)<br />1000&nbsp;&nbsp;&nbsp; --&gt;t(System.Char)<br />10010&nbsp;&nbsp; --&gt;d(System.Char)<br />10011&nbsp;&nbsp; --&gt;h(System.Char)<br />10100&nbsp;&nbsp; --&gt;i(System.Char)<br />10101&nbsp;&nbsp; --&gt;m(System.Char)<br />10110&nbsp;&nbsp; --&gt;o(System.Char)<br />10111&nbsp;&nbsp; --&gt;r(System.Char)<br />11000&nbsp;&nbsp; --&gt;y(System.Char)<br /><span style=\"color: #ff0000;\"><strong>11001&nbsp;&nbsp; --&gt;3(System.Int32)（看前面的CL1序列，对应257，码字长度5）</strong></span><br />110100&nbsp; --&gt;,(System.Char)<br />110101&nbsp; --&gt;.(System.Char)<br />110110&nbsp; --&gt;A(System.Char)<br />110111&nbsp; --&gt;b(System.Char)<br />111000&nbsp; --&gt;c(System.Char)<br />111001&nbsp; --&gt;f(System.Char)<br />111010&nbsp; --&gt;k(System.Char)<br />111011&nbsp; --&gt;u(System.Char)<br />111100&nbsp; --&gt;v(System.Char)<br />111101&nbsp; --&gt;w(System.Char)<br /><strong><span style=\"color: #ff0000;\">111110&nbsp; --&gt;-1(System.Int32)（看前面的CL1序列，对应256，码字长度6）</span></strong><br /><span style=\"color: #ff0000;\"><strong>111111&nbsp; --&gt;4(System.Int32)<span style=\"color: #ff0000;\">（看前面的CL1序列，对应258，码字长度6）</span></strong></span>\r\n可以看出，码表里存在两个重复字符串长度3和4，当解码结果为-1（上面进行了处理，即256），或者说遇到111110的时候，表示Deflate码流结束。\r\n按照同样的道理，对CL2序列进行解析，前面已经知道HDIST=10，即有11个CL2整数序列：\r\n11111（17）000（3比特，记录连续的3-10个0，此处为0，即记录3个0）\r\n11101（2）11111（17）100（3比特，记录连续的3-10个0，此处为001b=1，即记录4个0）\r\n11100（1）100（0）11101（2）\r\n已经结束，总共11个。\r\n于是CL2序列为：\r\n0 0 0 2 0 0 0 0 1 0 2\r\n分别记录的是distance码为0-10的码字长度，根据下面的对应关系，需要进行扩展：\r\n<img src=\"https://images0.cnblogs.com/blog/664058/201409/061458263447816.png\" alt=\"\" width=\"499\" height=\"223\" />\r\n比如，第1个码长2记录的是Code=3的长度，即Distance=4对应的码字为：\r\n10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --&gt;4(System.Int32)\r\n第1个码长1记录的是Code=8的长度（码字为0，扩展三位000-111），即Distance=17-24对应的码字为（注意，低比特优先）：\r\n0 000&nbsp;&nbsp;&nbsp; --&gt;17(System.Int32)<br />0 100&nbsp;&nbsp;&nbsp; --&gt;18(System.Int32)<br />0 010&nbsp;&nbsp;&nbsp; --&gt;19(System.Int32)<br />0 110&nbsp;&nbsp;&nbsp; --&gt;20(System.Int32)<br />0 001&nbsp;&nbsp;&nbsp; --&gt;21(System.Int32)<br />0 101&nbsp;&nbsp;&nbsp; --&gt;22(System.Int32)<br />0 011&nbsp;&nbsp;&nbsp; --&gt;23(System.Int32)<br />0 111&nbsp;&nbsp;&nbsp; --&gt;24(System.Int32)\r\n注意，扩展的时候还是低比特优先。\r\n最后1个码长2记录的是Code=10的长度（其实是码字：11，扩展四位0000-1111），即Distance=33-48对应的码字为：\r\n11 0000&nbsp; --&gt;33(System.Int32)<br />11 1000&nbsp; --&gt;34(System.Int32)<br />11 0100&nbsp; --&gt;35(System.Int32)<br />11 1100&nbsp; --&gt;36(System.Int32)<br />11 0010&nbsp; --&gt;37(System.Int32)<br />11 1010&nbsp; --&gt;38(System.Int32)<br />11 0110&nbsp; --&gt;39(System.Int32)<br />11 1110&nbsp; --&gt;40(System.Int32)<br />11 0001&nbsp; --&gt;41(System.Int32)<br />11 1001&nbsp; --&gt;42(System.Int32)<br />11 0101&nbsp; --&gt;43(System.Int32)<br />11 1101&nbsp; --&gt;44(System.Int32)<br />11 0011&nbsp; --&gt;45(System.Int32)<br />11 1011&nbsp; --&gt;46(System.Int32)<br />11 0111&nbsp; --&gt;47(System.Int32)<br />11 1111&nbsp; --&gt;48(System.Int32)\r\n至此为止，Huffman码表1、Huffman码表2已经还原出来，接下来是对LZ压缩所得到的literal、distance、length进行解码，目前剩余的比特流如下，先按照Huffman码表1解码，如果解码结果是长度（&gt;256），则接下来按照Huffman码表2解码，逐步解码即可：\r\n[As ]：110110（A）0111（s）000（空格）\r\n[mentioned ]：10101（m）001（e）0110（n）1000（t）10100（i）10110（o）0110（n）001（e）10010（d）000（空格）\r\n[above,]：0100（a）110111（b）10110（o）111100（v）001（e）110100（,）\r\n[there ]：1000（t）10011（h）001（e）10111（r）001（e）000（空格）\r\n[are ]：0100（a）11001（长度3，表示下一个需要用Huffman解码）10（Distance=4，即重复字符串为re空格）\r\n[many ]：10101（m）0100（a）0110（n）11000（y）000（空格）\r\n[kinds ]：111010（k）10100（i）0110（n）10010（d）0111（s）000（空格）\r\n[of ]：10110（o）111001（f）000（空格）\r\n[wireless ]：111101（w）10100（i）10111（r）001（e）0101（l）001（e）0111（s）0111（s）000（空格）\r\n[systems o]：0111（s）11000（y）0111（s）1000（t）001（e）10101（m）11001（长度指示=3，接下来根据distance解码）0110（Distance=20,即重复字符串为s o）\r\n[ther ]：111111（长度指示=4，接下来根据distance解码）111001（Distance=42,即重复字符串为ther）000（空格）\r\n[than ]：1000（t）10011（h）0100（a）0110（n）000（空格）\r\n[cellular.]：111000（c）001（e）0101（l）0101（l）111011（u）0101（l）0100（a）10111（r）110101（.）\r\n[256，结束标志]111110（结束标志）0000（字节补齐的0）\r\n于是解压缩结果为：\r\nAs mentioned above,there are many kinds of wireless systems other than cellular.\r\n再来回顾我们的解码过程：\r\n译码过程：<br />1、根据HCLEN得到截尾信息，并参照固定置换表，根据CCL比特流得到CCL整数序列；<br />2、根据CCL整数序列构造出等价于CCL的二级Huffman码表3；<br />3、根据二级Huffman码表3对CL1、CL2比特流进行解码，得到SQ1整数序列,SQ2整数序列；<br />4、根据SQ1整数序列,SQ2整数序列,利用游程编码规则得到等价的CL1整数序列、CL2整数序列；<br />5、根据CL1整数序列、CL2整数序列分别构造两个一级Huffman码表：literal/length码表、distance码表；<br />6、根据两个一级Huffman码表对后面的LZ压缩数据进行解码得到literal/length/distance流；<br />7、根据literal/length/distance流按照LZ规则进行解码。\r\nDeflate码流长度总共为72字节=576比特，其中：\r\n3比特Header；\r\n5比特HLIT；\r\n5比特HDIST；\r\n4比特HCLEN；\r\n54比特CCL序列码流；\r\n133比特CL1序列码流；\r\n34比特CL2序列码流；\r\n338比特LZ压缩后的literal/length/distance码流。\r\n11、ZIP的其它说明\r\n上面各个环节已经详细分析了ZIP压缩的过程以及解码流程，通过对一个实例的解压缩过程分析，可以彻底地掌握ZIP压缩和解压缩的原理和过程。还有一些情况需要说明：\r\n（1）上面的算法复杂度主要在于压缩一端，因为需要统计literal/length/distance，创建动态Huffman码表，相反解压只需要还原码表后，逐比特解析即可，这也是压缩软件的一个典型特点，解压速度远快于压缩速度。\r\n（2）上面我们分析了动态Huffman，对于LZ压缩后的literal/length/distance，也可以采用静态Huffman编码，这主要取决于ZIP在压缩中看哪种方式更节省空间，静态Huffman编码不需要记录码表，因为这个码表是固定的，在RFC1951里面也有说明。对于literal/length码表来说，需要对0-285进行编码，其码表为：\r\n<img src=\"https://images0.cnblogs.com/blog/664058/201409/061716127827338.png\" alt=\"\" width=\"313\" height=\"109\" />\r\n对于Distance来说，需要对Code=0-29的数进行编码，则直接采用5比特表示。Distance和动态Huffman一样，在此基础上进行扩展。\r\n（3）ZIP中使用的LZ77算法是一种改进的LZ77。主要区别有两点：\r\n1）标准LZ77在找到重复字符串时输出三元组(length, distance, 下一个未匹配的字符)（有兴趣可以关注LZ77那篇论文）；Deflate在找到重复字符串时仅输出双元组(length, distance)。<br />2）标准LZ77使用&rdquo;贪婪&ldquo;的方式解析，寻找的都是最长匹配字符串。Deflate中不完全如此。David Salomon的书里给了一个例子：\r\n<img src=\"https://images0.cnblogs.com/blog/664058/201409/061723147822682.png\" alt=\"\" />\r\n对于上面这个例子，标准LZ77在滑动窗口中查找最长匹配字符串，找到的是\"the\"与前面的there的前三个字符匹配，这种贪婪解析方式逻辑简单，但编码效率不一定最高。Deflate则不急于输出，跳过t继续往后查看，发现\"th ne\"这5个字符存在重复字符串，因此，Deflate算法会选择将t作为未匹配字符输出，而对后面的匹配字符串用(length, distance)编码输出。显然，这样就提高了压缩效率，因为标准的LZ77找到的重复字符串长度为3，而Deflate找到的是5。换句话说，Deflate算法并不是简单的寻找最长匹配后输出，而是会权衡几种可行的编码方式，用其中最高效的方式输出。\r\n&nbsp;\r\n12、总结\r\n本篇博文对ZIP中使用的压缩算法进行了详细分析，从一个简单地例子出发，一步步地分析了PK设计Deflate算法的思路。最后，通过一个实际例子，分析了其解压缩流程。总的来看，ZIP的核心在于如何对LZ压缩后的literal、length、distance进行Huffman编码，以及如何以最小空间记录Huffman码表。整个过程充满了对数据结构尤其是树的深入优化利用。按照上面的分析，如果要对ZIP进行进一步改进，可以考虑的地方也有不少，典型的有：\r\n（1）扩大LZ编码的滑动窗口的大小；\r\n（2）将Huffman编码改进为算术编码等压缩率更高的方法，毕竟，Huffman的码字长度必须为整数，这就从理论上限制了它的压缩率只能接近于理论极限，但难以达到。我记得在JPEG图像编码领域，以前的JPEG采用了DCT变换编码+Huffman的方式，现在JPEG2000将其改为小波变换+算数编码，所以数据压缩也可以尝试类似的思路；\r\n（3）将多个文件进行合并压缩，ZIP中，不同的文件压缩过程没有关系，独立进行，如果将它们合并起来一起进行压缩，压缩率可以得到进一步提高。\r\n&nbsp;\r\n描述分析有误的地方，敬请指正。针对数据压缩相关的话题，后续会对HBase列压缩等等进行分析，看看ZIP这种文件压缩和HBase这种数据库数据压缩的区别和联系。', '2018-04-02 09:33:00', '博客园', 'http://www.cnblogs.com/esingchan/p/3958962.html'),
(140, '数据库中多对多的关系设计', '英男', 'SQL', '数据库设计多对多关系的几种形态  \r\n前言：多对多关系至少需要3个表，我们把一个表叫做主表，一个叫做关系表，另外一个叫做字典表或者副表（字典表是纪录比较少，而且基本稳定的，例如：版块名称；副表是内容比较多，内容变化的，例如）。  \r\n按照数据库的增删查改操作，多对多关系的查找都可以用inner join或者select * from 主表 where id in (select 主表id from 关系表)  \r\n\r\n1，角色任命型\r\n\r\n特点：关系表两外键组合无重复纪录，关系表一般不需要时间字段和主键，有一个表是字典类型的表。  \r\n界面特点：显示主表，用checkbox或多选select设置多选关系。  \r\n例如：任命版主（用户表-关系表-版块名称表），角色权限控制等，用户是5个版块版主，只要关系表5行纪录就可以确立，关系表的两个外键具有联合主键性质。  \r\n增加关系：如果没有组合纪录，insert之。  \r\n删除关系：如果有组合纪录，删除之。  \r\n\r\n2，集合分组型\r\n\r\n特点：同角色任命型类似，关系表两外键组合无重复纪录，关系表一般不需要时间字段和主键。区别是主副表都不是字典表，可能都很大不固定。  \r\n界面特点：显示主表，用搜索代替简单的checkbox或多选select，或者一条一条的添加。  \r\n例如：歌曲专集（专集表-关系表-歌曲表）。手机分组（分组表-关系表-手机表）。用户圈子（圈子表-关系表-用户表）。文章标签（文章表-关系表-标签表）  \r\n增加关系：同版主任命型。  \r\n删除关系：同版主任命型。  \r\n\r\n3，明细帐型\r\n\r\n特点：关系表可以有重复纪录，关系表一般有时间字段，有主键，可能还有文字型的字段用来说明每次发生关系的原因（消费）。  \r\n界面特点：显示关系表，用radio或下拉设置单选关系。  \r\n例如：现金消费明细帐或订单（用户表-订单表-消费原因表），用户可能多次在同一事情上重复消费。积分变化纪录也属于这类。  \r\n增加关系：不管有没有组合纪录，insert之，纪录时间。  \r\n删除关系：根据关系表PK删除。  \r\n\r\n4，评论回复型\r\n\r\n特点：同明细帐型关系表一般有时间字段，有主键，区别是重点在文字型的字段用来说明每次发生关系的内容（评论回复）。  \r\n界面特点：回复文本框。  \r\n例如：论坛回复（用户表-回复表-帖子表），用户可能多次在不同帖子上评论回复费。  \r\n增加关系：不管有没有组合纪录，insert之，纪录时间和文字。  \r\n删除关系：根据关系表（回复表）PK删除。  \r\n\r\n5，站内短信型\r\n\r\n特点：主副表是同一个，关系表一般有时间字段，有主键，重点在关系表文字型的字段用来说明每次发生关系的内容（消息）或者其他标记位来表示文字已读状态时间等。  \r\n界面特点：回复文本框。  \r\n例如：站内短信（用户表-短信表-用户表），用户可能给用户群发或者单发，有标记位来表示文字已读状态时间等。  \r\n增加关系：不管有没有组合纪录，insert之，纪录时间和文字。  \r\n删除关系：根据关系表（回复表）PK删除。  \r\n\r\n6，用户好友型\r\n\r\n特点：主副表是同一个，同集合分组型，关系表两外键组合无重复纪录，关系表一般不需要时间字段和主键。  \r\n界面特点：同集合分组型，显示主表，用搜索代替简单的checkbox或多选select，或者一条一条的添加。  \r\n例如：下载站点的文件，（文件表-关系表-文件表）可以被软件工具打开，软件工具本身也是一种文件，可以被下载。用户的好友，也是用户（用户表-好友关系表-用户表）  \r\n增加关系：同版主任命型。  \r\n删除关系：同版主任命型。  \r\n\r\n7，未知属性型\r\n\r\n特点：在设计初期，主表的某些字段类型和名称是不确定的时候，关系表实际上是主表的可扩展字段，  \r\n一个[主表]（ID），  \r\n一个[属性名称表]（属性ID.属性名称)，  \r\n一个[属性值表]，包括3个字段：  \r\n  属性值(属性Value varchar(500))  \r\n  主表ID  \r\n  属性ID  \r\n这样可以作到最小冗余度。  \r\n（和常见的多对多关系不同的是：值统一用varchar来存储，因为这类型的值一般不会用来计算）。  \r\n比如：  \r\n军队的数据库设计中有种物资叫做“战缴物资”，就是打仗的时候缴获的，军队自己都不知道这些物资有什么属性。  \r\n比如缴获的化学品有化学名，通用名，是否有辐射，计量单位，包装规格，数量等等，或者不是化学品是其他任何未知的东西。  \r\n这样东西就可以  \r\n某奇怪东西.属性集合[\"某某奇怪属性名\"]=\"某某奇怪值\"；   \r\n某变态东西.属性集合[\"某某变态属性名\"]=\"某某变态值\"；   \r\n这样存储。  \r\n再比如：  \r\n手机型号有几千种，除了共同属性外还有不同属性有几百个，属性名和值类型都不一样，有的手机有这属性，有的没有。  \r\n对于这样的“多态”，我们就采用上面的设计结构。  \r\n其效果相当于：  \r\n某奇怪手机.属性集合[\"某某奇怪属性名\"]=\"某某奇怪值\"；  \r\n某变态手机.属性集合[\"某某变态属性名\"]=\"某某变态值\"；  \r\n界面特点：设置主表一行纪录的属性时候，要列出所有可能的属性名称，每个对应一个文本框。', '2018-04-02 10:29:00', 'CSDN', 'https://blog.csdn.net/aaron_lyn1985/article/details/54617273'),
(141, 'XML和JSON的区别', '关键我是你力哥', 'JS', '1.XML\r\n扩展标记语言 (Extensible Markup Language, XML) ，用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 XML使用DTD(document type definition)文档类型定义来组织数据;格式统一，跨平台和语言，早已成为业界公认的标准。\r\nXML是标准通用标记语言 (SGML) 的子集，非常适合 Web 传输。XML 提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。\r\n\r\n2.JSON\r\nJSON(JavaScript Object Notation)一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性。可在不同平台之间进行数据交换。JSON采用兼容性很高的、完全独立于语言文本格式，同时也具备类似于C语言的习惯(包括C, C++, C#, Java, JavaScript, Perl, Python等)体系的行为。这些特性使JSON成为理想的数据交换语言。\r\nJSON基于JavaScript Programming Language , Standard ECMA-262 3rd Edition - December 1999 的一个子集。\r\n\r\n \r\n\r\n \r\n\r\n3.XML和JSON优缺点\r\n\r\n \r\n\r\n(1).XML的优缺点\r\n&lt;1&gt;.XML的优点\r\n　　A.格式统一，符合标准；\r\n　　B.容易与其他系统进行远程交互，数据共享比较方便。\r\n&lt;2&gt;.XML的缺点\r\n　　A.XML文件庞大，文件格式复杂，传输占带宽；\r\n　　B.服务器端和客户端都需要花费大量代码来解析XML，导致服务器端和客户端代码变得异常复杂且不易维护；\r\n　　C.客户端不同浏览器之间解析XML的方式不一致，需要重复编写很多代码；\r\n　　D.服务器端和客户端解析XML花费较多的资源和时间。\r\n\r\n\r\n(2).JSON的优缺点\r\n&lt;1&gt;.JSON的优点：\r\n　　A.数据格式比较简单，易于读写，格式都是压缩的，占用带宽小；\r\n　　B.易于解析，客户端JavaScript可以简单的通过eval()进行JSON数据的读取；\r\n　　C.支持多种语言，包括ActionScript, C, C#, ColdFusion, Java, JavaScript, Perl, PHP, Python, Ruby等服务器端语言，便于服务器端的解析；\r\n　　D.在PHP世界，已经有PHP-JSON和JSON-PHP出现了，偏于PHP序列化后的程序直接调用，PHP服务器端的对象、数组等能直接生成JSON格式，便于客户端的访问提取；\r\n　　E.因为JSON格式能直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量，且完成任务不变，并且易于维护。\r\n&lt;2&gt;.JSON的缺点\r\n　　A.没有XML格式这么推广的深入人心和喜用广泛，没有XML那么通用性；\r\n　　B.JSON格式目前在Web Service中推广还属于初级阶段。', '2018-04-09 14:34:22', '博客', 'https://www.cnblogs.com/gslblog/p/6664641.html'),
(142, 'AngularJS 中启动多个 ng-app 的问题', '赵小吉', 'JS', '最近正在学习 AngularJS，在编写一个小 Demo 程序时遇到一个问题，就是当在单个页面上加载了多个 ng-app 时，只有第一个会起作用。\r\n\r\n查询后找到答案：在 angular 页面中，每一个 HTML 页面只有一个 ng-app 会被自动装载。\r\n\r\n所以我们有几种方案来解决这个问题。\r\n\r\n　　1. 可以简单的将多个 ng-app 合并成为一个根模块。\r\n\r\n　　2. 可以手动装载除了第一个以外的多个 ng-app。\r\n\r\nng-app 是 angular 中的一个十分重要的标签。一个 ng-app 应当对应一块业务逻辑，所以一个页面是可能需要使用多个模块的。为了避免不同模块间代码的耦合，我个人更偏向于第二种做法。代码如下：<pre><code>&lt;div id=&quot;app1div&quot; ng-app=&quot;myApp1&quot; ng-controller=&quot;personCtrl&quot;&gt;\r\n        &lt;p&gt;personCtrl&lt;/p&gt;\r\n        First name: &lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt;&lt;br&gt;\r\n        Last Name: &lt;input type=&quot;text&quot; ng-model=&quot;lastName&quot;&gt;&lt;br&gt;\r\n        Full Name: {{fullName()}}\r\n    &lt;/div&gt;\r\n\r\n    &lt;br&gt;&lt;br&gt;\r\n    &lt;div id=&quot;app2div&quot; ng-app=&quot;myApp2&quot; ng-controller=&quot;personCtrl&quot;&gt;\r\n        &lt;p&gt;personCtrl&lt;/p&gt;\r\n        First name: &lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt;&lt;br&gt;\r\n        Last Name: &lt;input type=&quot;text&quot; ng-model=&quot;lastName&quot;&gt;&lt;br&gt;\r\n        Full Name: {{fullName()}}\r\n    &lt;/div&gt;\r\n\r\n    &lt;script&gt;\r\n        var app1 = angular.module(&#x27;myApp1&#x27;, []);\r\n        var app2 = angular.module(&#x27;myApp2&#x27;, []);\r\n\r\n        app1.controller(&#x27;personCtrl&#x27;, function($scope){\r\n            $scope.firstName = &#x27;Aaron&#x27;;\r\n            $scope.lastName = &#x27;S&#x27;;\r\n            $scope.fullName = function(){ return $scope.firstName + $scope.lastName; }\r\n        });\r\n\r\n        app2.controller(&#x27;personCtrl&#x27;, function($scope){\r\n            $scope.firstName = &#x27;Andy&#x27;;\r\n            $scope.lastName = &#x27;W&#x27;;\r\n            $scope.fullName = function(){ return $scope.firstName + $scope.lastName; }\r\n        });\r\n        angular.bootstrap(document.getElementById(&quot;app2div&quot;), [&#x27;myApp2&#x27;]);\r\n    &lt;/script&gt;</code></pre>', '2018-04-12 16:29:00', '博客园', 'https://www.cnblogs.com/zhaoxiaoji/p/5155599.html'),
(143, 'js只保留整数，向上取整，四舍五入，向下取整等函数', '返回主页 chuquan.ou', 'JS', '1.丢弃小数部分,保留整数部分<br />parseInt(5/2)\r\n2.向上取整,有小数就整数部分加1\r\nMath.ceil(5/2)\r\n3,四舍五入.\r\nMath.round(5/2)\r\n4,向下取整\r\nMath.floor(5/2)\r\n<h2>Math 对象的方法</h2>\r\n&nbsp;\r\n<table>\r\n<tbody>\r\n<tr><th>方法</th><th>描述</th></tr>\r\n<tr>\r\n<td>abs(x)</td>\r\n<td>返回数的绝对值</td>\r\n</tr>\r\n<tr>\r\n<td>acos(x)</td>\r\n<td>返回数的反余弦值</td>\r\n</tr>\r\n<tr>\r\n<td>asin(x)</td>\r\n<td>返回数的反正弦值</td>\r\n</tr>\r\n<tr>\r\n<td>atan(x)</td>\r\n<td>以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值</td>\r\n</tr>\r\n<tr>\r\n<td>atan2(y,x)</td>\r\n<td>返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）</td>\r\n</tr>\r\n<tr>\r\n<td>ceil(x)</td>\r\n<td>对一个数进行上舍入。</td>\r\n</tr>\r\n<tr>\r\n<td>cos(x)</td>\r\n<td>返回数的余弦</td>\r\n</tr>\r\n<tr>\r\n<td>exp(x)</td>\r\n<td>返回 e 的指数。</td>\r\n</tr>\r\n<tr>\r\n<td>floor(x)</td>\r\n<td>对一个数进行下舍入。</td>\r\n</tr>\r\n<tr>\r\n<td>log(x)</td>\r\n<td>返回数的自然对数（底为e）</td>\r\n</tr>\r\n<tr>\r\n<td>max(x,y)</td>\r\n<td>返回 x 和 y 中的最高值</td>\r\n</tr>\r\n<tr>\r\n<td>min(x,y)</td>\r\n<td>返回 x 和 y 中的最低值</td>\r\n</tr>\r\n<tr>\r\n<td>pow(x,y)</td>\r\n<td>返回 x 的 y 次幂</td>\r\n</tr>\r\n<tr>\r\n<td>random()</td>\r\n<td>返回 0 ~ 1 之间的随机数</td>\r\n</tr>\r\n<tr>\r\n<td>round(x)</td>\r\n<td>把一个数四舍五入为最接近的整数</td>\r\n</tr>\r\n<tr>\r\n<td>sin(x)</td>\r\n<td>返回数的正弦</td>\r\n</tr>\r\n<tr>\r\n<td>sqrt(x)</td>\r\n<td>返回数的平方根</td>\r\n</tr>\r\n<tr>\r\n<td>tan(x)</td>\r\n<td>返回一个角的正切</td>\r\n</tr>\r\n<tr>\r\n<td>toSource()</td>\r\n<td>代表对象的源代码</td>\r\n</tr>\r\n<tr>\r\n<td>valueOf()</td>\r\n<td>返回一个 Math 对象的原始值</td>\r\n</tr>\r\n</tbody></table>\r\n&nbsp;\r\n&nbsp;\r\njs&nbsp;四舍五入函数&nbsp;toFixed（），里面的参数 就是保留小数的位数。', '2018-04-13 11:25:00', '博客园', 'https://www.cnblogs.com/langtianya/p/6321911.html'),
(144, 'script放置最佳位置以及html执行顺序', '王叙鹏', 'JS', '　　看到知乎上有很多讨论关于javascript位置的文章。所以特意留意了这方面的问题。\n\n　　首先要了解到的是：\n\n　　　　html文件是自上而下的执行方式，但引入的css和javascript的顺序有所不同，css引入执行加载时，程序仍然往下执行，而执行到&lt;script&gt;脚本是则中断线程，待该script脚本执行结束之后程序才继续往下执行。\n\n　　　　所以，大部分网上讨论是将script脚本放在&lt;body&gt;之后，那样dom的生成就不会因为长时间执行script脚本而延迟阻塞，加快了页面的加载速度。\n\n　　　　但又不能将所有的script放在body之后，因为有一些页面的效果的实现，是需要预先动态的加载一些js脚本。所以这些脚本应该放在&lt;body&gt;之前。\n\n　　　　其次，不能将需要访问dom元素的js放在body之前，因为此时还没有开始生成dom，所以在body之前的访问dom元素的js会出错，或者无效\n\n　　　　直接上代码<pre><code>&lt;/head&gt;\n &lt;script type=&quot;text/javascript&quot;&gt;\n    document.getElementById(&quot;text&quot;).innerHTML=&quot;hello world&quot;;\n &lt;/script&gt;\n&lt;body&gt;\n    &lt;h1 id=&quot;text&quot;&gt;&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>　　　　此时结果空白一片。\n\n　　　　将script脚本放在body之后<pre><code>&lt;body&gt;\n    &lt;h1 id=&quot;text&quot;&gt;&lt;/h1&gt;\n&lt;/body&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    document.getElementById(&quot;text&quot;).innerHTML=&quot;hello world&quot;;\n &lt;/script&gt;</code></pre>　有了结果\n\n　　　　所以，我认为script放置位置的原则“页面效果实现类的js应该放在body之前，动作，交互，事件驱动，需要访问dom属性的js都可以放在body之后”。', '2018-04-13 11:21:00', '博客园', 'https://www.cnblogs.com/iamwangxupeng/p/4950255.html'),
(145, '五大流浏览器内核及其代表', 'web_emmet', 'baike', '浏览器的内核是分为两个部分的，一是渲染引擎，另一个是JS引擎。现在JS引擎比较独立，内核更加倾向于说渲染引擎。\r\n\r\n1、Trident内核：代表作品是IE，因IE捆绑在Windows中，所以占有极高的份额，又称为IE内核或MSHTML，此内核只能用于Windows平台，且不是开源的。\r\n\r\n    代表作品还有腾讯、Maxthon（遨游）、360浏览器等。但由于市场份额比较大，曾经出现脱离了W3C标准的时候，同时IE版本比较多，\r\n\r\n    存在很多的兼容性问题。\r\n\r\n2、Gecko内核：代表作品是Firefox，即火狐浏览器。因火狐是最多的用户，故常被称为firefox内核它是开源的，最大优势是跨平台，在Microsoft Windows、Linux、MacOs X等主\r\n  要操作系统中使用。\r\n\r\n   Mozilla是网景公司在第一次浏览器大战败给微软之后创建的。有兴趣的同学可以了解一下浏览器大战\r\n\r\n3、Webkit内核：代表作品是Safari、曾经的Chrome，是开源的项目。\r\n\r\n4、Presto内核：代表作品是Opera，Presto是由Opera Software开发的浏览器排版引擎，它是世界公认最快的渲染速度的引擎。在13年之后，Opera宣布加入谷歌阵营，弃用了\r\n   Presto \r\n\r\n5、Blink内核：由Google和Opera Software开发的浏览器排版引擎，2013年4月发布。现在Chrome内核是Blink。谷歌还开发了自己的JS引擎，V8，使JS运行速度极大地提高了\r\n\r\n讲解比较粗糙，有兴趣的同学可以google搜索下，我就算是抛砖引玉了。', '2018-04-16 16:58:00', 'CSDN', 'https://blog.csdn.net/u014753892/article/details/52713841'),
(146, 'Chrome内核解析 -- 背景篇：Chromium/Blink的工作流程', 'yunchao_he', 'baike', '本节简单介绍下Chromium/Blink绘制页面的基本工作流程。用户点击链接或输入网址，到最终显示网页内容，经历了以下几个重要步骤：\r\n\r\n1. Chromium的启动和资源加载\r\n\r\n用户输入URL（如www.163,com）并回车，Chrome会立即调用资源加载器，加载网页本身（比如index.html)。解析HTML时，如果发现某个节点还指向的其它的HTML文件，以及JS文件，CSS文件，图片，音视频文件等其它资源，也会加载这些资源。解析新加载的HTML，JS文件，CSS文件时，如果还指向其它需要加载的资源，则继续加载。整个过程类似于深度优先算法，伴随着HTML, CSS和JS的解析与执行而不断发现新的资源需要加载，如此往复，直到所有的资源全部加载完成。\r\n\r\n\r\n\r\n2. 解析HTML, CSS, 执行Javascript\r\n\r\n从网络接收到的HTML文件（实际上是字符流），会被解析成一个个Token，并构建Dom tree。同时还会解析CSS并构建RenderObject Tree，解析并执行JS。它和资源加载过程有重叠，因为解析HTML/CSS/JS过程可能发现当前结点或文件指向一个或多个新的HTML/CSS/JS文件。那么问题来了，当前HTML/CSS/JS解析过程中发现需要加载新资源，是否会打断当前的解析过程呢？这得看情况，如果新加载的文件是HTML/CSS/JS，这时的新加载是同步的，会暂停当前文件的解析，先加载新的文件。待加载完成后再解析当前文件。而如果新加载的文件是图片或音视频文件，则发起异步加载请求（通常有单独的加载线程），而无需打断当前的解析过程。\r\n\r\n\r\n\r\n3. 构建DOM Tree, RenderObject Tree, RenderLayer Tree以及创建绘图上下文\r\n\r\n上文提到，解析HTML时，将字符流解析成一个个Token, 并根据Token构建DOM tree. 而在解析CSS时，会根据CSS提供的Style信息把可视的DOM构建成RenderObject，从而形成RenderObject Tree. 而解析和执行JS时，可能修改DOM tree和RenderObject Tree. \r\n\r\n另外，特殊的DOM(Canvas, WebGL, Video, Pepper3D, CSS 3D Transformation Dom)会建立单独的RenderLayer, 以加快后期的布局计算和绘制过程。而所有的其它结点则位于Root Layer。这样，又形成了一颗RenderLayer Tree。这些RenderLayer很可能有自己的绘图存储空间（BackingStore，或者RenderSurface), 而这往往又涉及到3D Context的创建，以及相应资源的申请。比如BackingStore可能只是位于主存(main memory)的二维数组来保存像素信息，也可能是显存上的一块Texture，或者显存上的离屏的FBO(FrameBuffer Object)。\r\n\r\n\r\n\r\n4. 布局(Layout)\r\n\r\n负责计算各个DOM的位置，它和CSS解析以及RenderObject的创建密切相关。位置信息往往会添加到RenderObject Tree中。而且JS的执行或用户事件（如拖拽等触摸动作或鼠标事件）可能会导致页面需要重新计算布局。\r\n\r\n\r\n\r\n5. 绘制(Paint)与合成(Composite)\r\n\r\n将上述的RenderObject Tree, RenderLayer Tree等提供的信息，调用图形库将各个Layer都绘制出来，转化成像素信息以便显示。由于多个Layer对应着多层像素图，它们需要按照合适的顺序（z-order)合成在一起，并最终与浏览器的UI合成，得到合成后的像素信息写到Framebuffer, 供监视器显示。\r\n\r\n\r\n\r\n以上是Chromium/Blink的绘制页面的基本工作流程。\r\n\r\n\r\n\r\n实际上，JS或用户操作会动态修改页面，从而需要反复计算布局和绘制，甚至重新发起URL导航。而且JS的执行往往是由requestAnimationFrame / setInterval / timeout 等注册的循环事件，所以页面的反复绘制与更新，以及用户的操作请求（比如滑动页面），实际上是处于一个由事件驱动的main loop里。', '2018-04-16 16:51:00', 'CSDN', 'https://blog.csdn.net/yunchao_he/article/details/41697489');
INSERT INTO `wu_blog` (`id`, `post_title`, `post_author`, `post_type`, `post_content`, `post_date`, `post_from`, `post_link`) VALUES
(147, '逐行分析jQuery源码', '晴晴加油', 'JS', '<span style=\"color: #ff0000; font-size: 15px; background-color: #ffffff;\">注意：本次源码分析选择2.0.3(因为不支持IE6、7、8，就少了很多兼容的hack的写法，对了解jQuery的实现原理有很大的帮助)</span>\r\n1.jQuery有不同的版本，从2.x版本便不再支持IE6、7、8\r\n&nbsp; &nbsp;将jQuery拆分长框架一点一点进行了解\r\n2.\r\n<pre><code>(<span style=\"color: #0000ff;\">function</span> ())();</code></pre>\r\n这个叫匿名函数自执行\r\n3.匿名函数自执行的好处是什么呢？\r\n&nbsp; &nbsp;<span style=\"background-color: #00ff00;\">匿名函数自执行里面的所有东西都是一个局部的。防止和其他的代码冲突。</span>\r\n栗子①\r\n<pre><code>\r\n(function () {<br />&nbsp; &nbsp;var a=10;<br />})();<br />alert(a);\r\n\r\n</code></pre>\r\n控制台报错，说a is not defined。\r\n4.如何能够访问到匿名函数自执行中的方法呢？\r\n&nbsp; 很多种方法(⊙o⊙)哦。可以把你要对外提供的接口作为window的属性或者是方法。\r\n栗子②\r\n<pre><code>(<span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> () {\r\n    </span><span style=\"color: #0000ff;\">var</span> a=10<span style=\"color: #000000;\">;\r\n    \r\n    </span><span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\"> abc(){\r\n        alert(a);\r\n    }\r\n    //将abc方法作为window的方法，就可以在匿名函数自执行外面进行访问了\r\n    window.abc</span>=<span style=\"color: #000000;\">abc;\r\n})();\r\nabc();</span></code></pre>\r\n&nbsp;\r\n但是要对外提供接口，我们才能找到使用的方法和属性\r\n5.在jQuery中，$()是jQuery()的简写方式。\r\n6.在jQuery文件中第21行到第94行就是定义了一些变量和函数。\r\n&nbsp; 其中，60-64行是一个特别重要的函数,就是平时用的$() jQuery()对外的接口\r\n<pre><code><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> Define a local copy of jQuery</span>\r\njQuery = <span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\">( selector, context ) {\r\n    </span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> The jQuery object is actually just the init constructor \'enhanced\'</span>\r\n    <span style=\"color: #0000ff;\">return</span> <span style=\"color: #0000ff;\">new</span><span style=\"color: #000000;\"> jQuery.fn.init( selector, context, rootjQuery );\r\n},</span></code></pre>\r\n但是现在这个jQuery还是以局部变量的形式存在，要提供对外的<span style=\"color: #ff0000;\">接口</span>，才能使用。提供接口在第8823-8827行\r\n<pre><code><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\"> If there is a window object, that at least has a document property,</span><span style=\"color: #008000;\">\r\n//</span><span style=\"color: #008000;\"> define jQuery and $ identifiers</span>\r\n<span style=\"color: #0000ff;\">if</span> ( <span style=\"color: #0000ff;\">typeof</span> window === \"object\" &amp;&amp; <span style=\"color: #0000ff;\">typeof</span> window.document === \"object\"<span style=\"color: #000000;\"> ) {\r\n    window.jQuery </span>= window.$ =<span style=\"color: #000000;\"> jQuery;\r\n}</span></code></pre>\r\n7.在第96-283行，都是给jQuery对象添加一些方法和属性。\r\n&nbsp; prototype(原型)是面向对象的东西，所以说，jQuery就是一个基于面向对象的程序，jQuery里面写的都是跟面向对象有关的。\r\n<pre><code>//96行<br />jQuery.fn = jQuery.prototype</code></pre>\r\n8.为什么jQuery是一个基于面向对象的程序？？\r\n&nbsp; 栗子③\r\n<pre><code>//jQuery是这样调用方法的对吧。是不是和下面数组使用方法的方式非常像。<br />//但是实际上$(\"div\")他本身是一个函数调用，但是函数调用的执行结果是一个对象，所以，这就是为什么说jQuery是基于面向对象的程序喽~~~<br />$(\"div\"<span style=\"color: #000000;\">).css();\r\n$(</span>\"div\"<span style=\"color: #000000;\">).text();\r\n<br />//这是Array对象方法的使用方式，先实例化一个对象，然后使用对象调用方法。\r\n</span><span style=\"color: #0000ff;\">var</span> arr=<span style=\"color: #0000ff;\">new</span> Array(3<span style=\"color: #000000;\">);\r\narr.sort();\r\narr.splice();</span></code></pre>\r\n<pre><code>//61--64<br />jQuery = <span style=\"color: #0000ff;\">function</span><span style=\"color: #000000;\">( selector, context ) {\r\n</span>    //在这个函数执行完了就是一个new构造函数的过程，返回的就是一个jQuery对象~~既然返回的是对象，当然可以调用方法喽~~\r\n    <span style=\"color: #0000ff;\">return</span> <span style=\"color: #0000ff;\">new</span><span style=\"color: #000000;\"> jQuery.fn.init( selector, context, rootjQuery );\r\n}</span></code></pre>\r\n9.285--347行--&gt; &nbsp;extend:是jQuery当中的一个继承方法，希望后续添加的方法都能挂在jQuery对象上，很方便扩展\r\n10.\r\n<pre><code><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">通过使用对象调用的方法，是实例方法。</span>\r\n<span style=\"color: #000000;\">$().text();\r\n$().html();\r\n\r\n</span><span style=\"color: #008000;\">//</span><span style=\"color: #008000;\">$是一个函数，在函数下面来扩展方法的话，就是扩展一些静态方法</span><span style=\"color: #008000;\">\r\n//</span><span style=\"color: #008000;\">在jQuery当中，给面向对象扩展静态属性和静态方法叫做扩展工具方法<br />//工具方法和实例方法区别就在于，它既可以给jQuery对象来用，也可以给源生的JS来用，实例方法只能给jQuery对象调用<br /></span><span style=\"color: #000000;\">$.trim();\r\n$.proxy();</span></code></pre>\r\n11.静态方法和实例方法在jQuery中的关系？\r\n&nbsp; 可以把静态方法看作是在jQuery中的最底层，而实例方法是上一层或者是更高层的。\r\n&nbsp; 很多方法都是实例方法，里面调用的都是工具方法。\r\n12.877行--2856行&nbsp; Sizzle 复杂选择器的实现\r\n13.2880行--3042行&nbsp; Callbacks 回调对象 : 函数的统一管理\r\n', '2018-04-16 13:24:00', '博客园', 'https://www.cnblogs.com/yuqingfamily/p/5785593.html'),
(148, 'HTML embed标签使用方法和属性详解', '每天进步多一点', 'html', '一、基本语法<br />&nbsp;<br />代码如下:<br />&nbsp;<br />embed src=url<br />&nbsp;<br />说明：embed可以用来插入各种多媒体，格式可以是 Midi、Wav、AIFF、AU、MP3等等，Netscape及新版的IE 都支持。url为音频或视频文件及其路径，可以是相对路径或绝对路径。<br />&nbsp;<br />示例:<br />&nbsp;<br />代码如下:<br />&nbsp;\r\n&lt;embed src=\"your.mid\"&gt;<br />&nbsp;<br />二、属性设置<br />&nbsp;<br />1、自动播放：<br />&nbsp;<br />语法：autostart=true、false<br />&nbsp;<br />说明：该属性规定音频或视频文件是否在下载完之后就自动播放。<br />&nbsp;<br />true：音乐文件在下载完之后自动播放；<br />&nbsp;<br />false：音乐文件在下载完之后不自动播放。<br />&nbsp;<br />示例：<br />&nbsp;<br />代码如下:<br />&nbsp;<br />&lt;embed src=\"your.mid\" autostart=true&gt;<br />&nbsp;<br />&lt;embed src=\"your.mid\" autostart=false&gt;<br />&nbsp;<br />2、循环播放：<br />&nbsp;<br />语法：loop=正整数、true、false<br />&nbsp;<br />说明：该属性规定音频或视频文件是否循环及循环次数。<br />&nbsp;<br />属性值为正整数值时，音频或视频文件的循环次数与正整数值相同；<br />&nbsp;<br />属性值为true时，音频或视频文件循环；<br />&nbsp;<br />属性值为false时，音频或视频文件不循环。<br />&nbsp;<br />示例：<br />&nbsp;<br />代码如下:<br />&nbsp;<br />&lt;embed src=\"your.mid\" autostart=true loop=2&gt;<br />&nbsp;<br />&lt;embed src=\"your.mid\" autostart=true loop=true&gt;<br />&nbsp;<br />&lt;embed src=\"your.mid\" autostart=true loop=false&gt;<br />&nbsp;<br />3、面板显示：<br />&nbsp;<br />语法：hidden=ture、no<br />&nbsp;<br />说明：该属性规定控制面板是否显示，默认值为no。<br />&nbsp;<br />ture：隐藏面板；<br />&nbsp;<br />no：显示面板。<br />&nbsp;<br />示例：<br />&nbsp;<br />代码如下:<br />&nbsp;<br />&lt;embed src=\"your.mid\" hidden=ture&gt;<br />&nbsp;<br />&lt;embed src=\"your.mid\" hidden=no&gt;<br />&nbsp;<br />4、开始时间：<br />&nbsp;<br />语法：starttime=mm:ss（分：秒）<br />&nbsp;<br />说明：该属性规定音频或视频文件开始播放的时间。未定义则从文件开头播放。<br />&nbsp;<br />示例：<br />&nbsp;<br />代码如下:<br />&nbsp;<br />&lt;embed src=\"your.mid\" starttime=\"00:10\"&gt;<br />&nbsp;<br />5、音量大小：<br />&nbsp;<br />语法：volume=0-100之间的整数<br />&nbsp;<br />说明：该属性规定音频或视频文件的音量大小。未定义则使用系统本身的设定。<br />&nbsp;<br />示例：<br />&nbsp;<br />代码如下:<br />&nbsp;<br />&lt;embed src=\"your.mid\" volume=\"10\"&gt;<br />&nbsp;<br />6、容器属性：<br />&nbsp;<br />语法：height=# width=#<br />&nbsp;<br />说明：取值为正整数或百分数，单位为像素。该属性规定控制面板的高度和宽度。<br />&nbsp;<br />height：控制面板的高度；<br />&nbsp;<br />width：控制面板的宽度。<br />&nbsp;<br />示例：<br />&nbsp;<br />代码如下:<br />&nbsp;<br />&lt;embed src=\"your.mid\" height=200 width=200&gt;<br />&nbsp;<br />7、容器单位：<br />&nbsp;<br />语法：units=pixels、en<br />&nbsp;<br />说明：该属性指定高和宽的单位为pixels或en。<br />&nbsp;<br />示例：<br />&nbsp;<br />代码如下:<br />&nbsp;<br />&lt;embed src=\"your.mid\" units=\"pixels\" height=200 width=200&gt;<br />&nbsp;<br />&lt;embed src=\"your.mid\" units=\"en\" height=200 width=200&gt;<br />&nbsp;<br />8、外观设置：<br />&nbsp;<br />语法：controls=console、smallconsole、playbutton、pausebutton、stopbutton、volumelever 说明：该属性规定控制面板的外观。默认值是console。<br />&nbsp;<br />console：一般正常面板；<br />&nbsp;<br />smallconsole：较小的面板；<br />&nbsp;<br />playbutton：只显示播放按钮；<br />&nbsp;<br />pausebutton：只显示暂停按钮；<br />&nbsp;<br />stopbutton：只显示停止按钮；<br />&nbsp;<br />volumelever：只显示音量调节按钮。<br />&nbsp;<br />示例：<br />&nbsp;<br />代码如下:<br />&nbsp;<br />&lt;embed src=\"your.mid\" controls=smallconsole&gt;<br />&nbsp;<br />&lt;embed src=\"your.mid\" controls=volumelever&gt;<br />&nbsp;<br />9、对象名称：<br />&nbsp;<br />语法：name=#<br />&nbsp;<br />说明：#为对象的名称。该属性给对象取名，以便其他对象利用。<br />&nbsp;<br />示例：<br />&nbsp;<br />代码如下:<br />&nbsp;<br />&lt;embed src=\"your.mid\" name=\"video\"&gt;<br />&nbsp;<br />10、说明文字：<br />&nbsp;<br />语法：title=#<br />&nbsp;<br />说明：#为说明的文字。该属性规定音频或视频文件的说明文字。<br />&nbsp;<br />示例：<br />&nbsp;<br />代码如下:<br />&nbsp;<br />&lt;embed src=\"your.mid\" title=\"第一首歌\"&gt;<br />&nbsp;<br />11、前景色和背景色：<br />&nbsp;<br />语法：palette=color|color<br />&nbsp;<br />说明：该属性表示嵌入的音频或视频文件的前景色和背景色，第一个值为前景色，第二个值为背景色，中间用 | 隔开。color可以是RGB色（RRGGBB）也可以是颜色名，还可以是transparent （透明）。<br />&nbsp;<br />示例：<br />&nbsp;<br />代码如下:<br />&nbsp;<br />&lt;embed src=\"your.mid\" palette=\"red|black\"&gt;<br />&nbsp;<br />12、对齐方式：<br />&nbsp;<br />语法：align=top、bottom、center、baseline、 left、right、texttop、middle、absmiddle、absbottom<br />&nbsp;<br />说明：该属性规定控制面板和当前行中的对象的对齐方式。<br />&nbsp;<br />center：控制面板居中；<br />&nbsp;<br />left：控制面板居左；<br />&nbsp;<br />right：控制面板居右；<br />&nbsp;<br />top：控制面板的顶部与当前行中的最高对象的顶部对齐；<br />&nbsp;<br />bottom：控制面板的底部与当前行中的对象的基线对齐；<br />&nbsp;<br />baseline：控制面板的底部与文本的基线对齐；<br />&nbsp;<br />texttop：控制面板的顶部与当前行中的最高的文字顶部对齐；<br />&nbsp;<br />middle：控制面板的中间与当前行的基线对齐；<br />&nbsp;<br />absmiddle：控制面板的中间与当前文本或对象的中间对齐；<br />&nbsp;<br />absbottom：控制面板的底部与文字的底部对齐。<br />&nbsp;<br />示例：<br />&nbsp;<br />代码如下:<br />&nbsp;<br />&lt;embed src=\"your.mid\" align=top&gt;<br />&nbsp;<br />&lt;embed src=\"your.mid\" align=center&gt;\r\n&nbsp;\r\n&nbsp;\r\n<strong>编码与格式的误区</strong>\r\n很多人将编码和格式误认为是同一个东西，往往以视频文件的后缀来唯一确定视频文件的支持程度。而事实上，用一句话来概括就是：视频的文件后缀（假设没有恶意修改后缀）实际上代表一种封装格式，而视频或者音频的编码算法与封装格式本身无直接的关系：同样的封装格式（即同样的后缀）可以封装不同编码算法的视频和音频。而视频播放设备或软件是否支持视频的播放，不仅仅要看封装格式，还要看编码算法。认清这一点是理解和排查问题的基础。\r\n封装格式规定了视频的所有内容，包括图像，声音，字幕，系统控制等，其中以图像和声音最为关键。\r\n<strong>从</strong><strong>MPEG</strong><strong>说起</strong>\r\nMPEG是一个定义视频规格的国际组织，他们曾经推出的MPEG-1和MPEG-2实际上分别就是大家熟知的VCD和DVD，不过这都是远古的东西了。我们来看看跟本文主题有关的MPEG-4规范。\r\n<a href=\"http://zh.wikipedia.org/wiki/MPEG-4\" target=\"_blank\">MPEG-4</a>规范规定了文件后缀名为.mp4，目前包括三种图像编码和压缩算法：<a href=\"http://zh.wikipedia.org/wiki/XviD\" target=\"_blank\">Xvid</a>\\DivX\\AVC(H.264)，其中Xvid和DivX也可以统称为MPEG-4 Part 2或者MPEG-4 Visual，而更为知名的H.264和AVC是相同的概念。音频方面则是AAC。以下关于兼容的内容，来源于<a href=\"http://en.wikipedia.org/wiki/Html_video_tag\" target=\"_blank\">维基百科</a>和格式工厂以及笔者的测试：\r\n<ul>\r\n<li>Android浏览器：支持DivX和AVC，Xvid应该不支持</li>\r\n<li>iPhone和iPad（iOS）：支持DivX和AVC，Xvid不支持</li>\r\n<li>Chrome：支持AVC，不支持DivX和Xvid。谷歌曾在2011年初<a href=\"http://www.guao.hk/posts/chrome-removes-h-264-codec.html\" target=\"_blank\">宣布</a>由于许可问题，将移除Chrome浏览器对AVC(H.264)的支持。但是直到目前的版本，AVC还在被支持。另外，实际测试下来，如果是DivX和AAC封装在mp4中的话，chrome可以播放，但是只有声音(AAC)。</li>\r\n<li>Firefox和Opera：还是由于许可的问题，Firefox和Opera逐渐动摇了对AVC的支持，笔者在最新的Firefox中测试AVC仍然可以播放（<a href=\"http://en.wikipedia.org/wiki/Html_video_tag\" target=\"_blank\">维基百科</a>的解释是可能与系统本身具有解码器有关）；至于DivX和Xvid，笔者在Firefox下的测试结果是不支持。从维基百科的兼容列表看，Opera对AVC支持的不好。</li>\r\n<li>IE：笔者的IE11能够支持AVC，不支持DivX和Xvid</li>\r\n</ul>\r\n<strong>WebM</strong><strong>的倡导</strong>\r\n由于AVC(H.264)的授权问题，以Chrome、Firefox、Opera为首的开源阵营开始动摇对AVC的支持，尽管目前这些浏览器仍然能够支持AVC，但是它们也倾向于一个叫做<a href=\"http://en.wikipedia.org/wiki/WebM_Project\" target=\"_blank\">WebM</a>的开源多媒体项目，该项目包括一个叫VP8的新的开源视频编解码方案。目前VP8已经发展到了VP9。作为封装格式的WebM具有.webm的后缀和video/webm的MIME类型。在音频方面，可以使用<a href=\"http://en.wikipedia.org/wiki/Vorbis\" target=\"_blank\">Vorbis</a>/<a href=\"http://en.wikipedia.org/wiki/Opus_(audio_format)\" target=\"_blank\">Opus</a>。从兼容性看，Chrome、Firefox、Opera对VP8的兼容性相当理想，但是Safari和IE几乎无法支持。\r\n<strong>开源的</strong><strong>Ogg</strong>\r\n<a href=\"http://en.wikipedia.org/wiki/Ogg\" target=\"_blank\">Ogg</a>几乎与WebM相同，开源，被广泛的在开源平台支持。其视频编码方案称为<a href=\"http://en.wikipedia.org/wiki/Theora\" target=\"_blank\">Theora</a>(有VP3发展而来，由<a href=\"http://xiph.org/\" target=\"_blank\">Xiph.org基金会开发</a>，可被用于任何封装格式)，音频为<a href=\"http://en.wikipedia.org/wiki/Vorbis\" target=\"_blank\">Vorbis</a>。后缀通常为.ogv或.ogg，MIME类型为video/ogg。在兼容性上，Chrome、Firefox、Opera能够支持（但是Opera在移动平台上无法支持），但是Safari和IE几乎无法支持。\r\n<strong>Html5</strong><strong>方案</strong>\r\n以上的讨论实际上的大前提是：视频基于Html5的&lt;video&gt;方案。现在我们来总结一下兼容性：\r\n<table border=\"0\" cellpadding=\"0\">\r\n<thead>\r\n<tr>\r\n<td>\r\n<strong>Codecs/container</strong>\r\n</td>\r\n<td>\r\n<strong>IE</strong>\r\n</td>\r\n<td>\r\n<strong>Firefox</strong>\r\n</td>\r\n<td>\r\n<strong>Safari</strong>\r\n</td>\r\n<td>\r\n<strong>Chrome</strong>\r\n</td>\r\n<td>\r\n<strong>Opera</strong>\r\n</td>\r\n<td>\r\n<strong>iPhone</strong>\r\n</td>\r\n<td>\r\n<strong>Android</strong>\r\n</td>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>\r\n<strong>Theora+Vorbis+Ogg</strong>\r\n</td>\r\n<td>\r\n&middot;\r\n</td>\r\n<td>\r\n3.5+\r\n</td>\r\n<td>\r\n&nbsp;\r\n</td>\r\n<td>\r\n5.0+\r\n</td>\r\n<td>\r\n10.5+\r\n</td>\r\n<td>\r\n&middot;\r\n</td>\r\n<td>\r\n&middot;\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n<strong>H.264+AAC+MP4</strong>\r\n</td>\r\n<td>\r\n9.0+\r\n</td>\r\n<td>\r\n&middot;\r\n</td>\r\n<td>\r\n3.0+\r\n</td>\r\n<td>\r\n5.0+<sup>&Dagger;</sup>\r\n</td>\r\n<td>\r\n&middot;\r\n</td>\r\n<td>\r\n3.0+\r\n</td>\r\n<td>\r\n2.0+\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n<strong>WebM</strong>\r\n</td>\r\n<td>\r\n9.0+<sup>*</sup>\r\n</td>\r\n<td>\r\n4.0+\r\n</td>\r\n<td>\r\n&nbsp;\r\n</td>\r\n<td>\r\n6.0+\r\n</td>\r\n<td>\r\n10.6+\r\n</td>\r\n<td>\r\n&middot;\r\n</td>\r\n<td>\r\n2.3+\r\n</td>\r\n</tr>\r\n<tr>\r\n<td colspan=\"8\">\r\n* IE9 &ldquo;<a href=\"http://windowsteamblog.com/windows/b/bloggingwindows/archive/2010/05/19/another-follow-up-on-html5-video-in-ie9.aspx\" target=\"_blank\">只有当用户安装了VP8的编解码器时</a>&rdquo;才能支持VP8。\r\n</td>\r\n</tr>\r\n<tr>\r\n<td colspan=\"8\">\r\n&Dagger; Google Chrome 2011年<a href=\"http://blog.chromium.org/2011/01/more-about-chrome-html-video-codec.html\" target=\"_blank\">宣布</a> <a href=\"http://blog.chromium.org/2011/01/html-video-codec-support-in-chrome.html\" target=\"_blank\">放弃H.264</a>, 但是&ldquo;还没兑现&rdquo;。\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n可以看出现在主流的仍然是MP4(AVC)，但是为了解决&ldquo;开源阵营&rdquo;对AVC的摇摆不定，可以选择利用video的多源方案，在AVC的基础上额外提供对webm或ogg的支持：\r\n&lt;video poster=\"movie.jpg\" controls&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;source src=\"movie.webm\" type=\'video/webm; codecs=\"vp8.0, vorbis\"\'&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;source src=\"movie.ogg\" type=\'video/ogg; codecs=\"theora, vorbis\"\'&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;source src=\"movie.mp4\" type=\'video/mp4; codecs=\"avc1.4D401E, mp4a.40.2\"\'&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;p&gt;This is fallback content&lt;/p&gt;\r\n&lt;/video&gt;\r\n浏览器会根据自己的偏好来选择具体加载那种格式的流媒体文件，当然服务端必须对同一个视频提供多种格式的支持，具体可以这么做：\r\n<ol>\r\n<li>提供一个WebM的视频版本（VP8+Vorbis）</li>\r\n<li>提供一个MP4的视频版本（H.264+AAC(low complexity)）</li>\r\n<li>提供Ogg版本（Theora+Vorbis）</li>\r\n</ol>\r\n服务端推荐使用nginx，尽量注意MIME类型的配置正确\r\n<strong>旧版本的</strong><strong>IE</strong><strong>和</strong><strong>flash</strong>\r\n在html5流行之前，通用的视频播放解决方案是flash和flv（flash从9开始支持h.264的mp4）。但是随着ios设备的流行，flash已经不是万能药了，越来越多的视频网站提供多元的解决方案，而且偏向于html5：也就是说，通过检测agent是否支持html5来决定使用video还是flash。在面对IE8以下的浏览器时，flash几乎是唯一的选择(silverlight的接受度普遍不高)。\r\n当然针对flash和flv的方案，也有多种实现方法，笔者能够想到的有如下两种：\r\n<ul>\r\n<li>服务端根据agent的类型，输出不同的html，如果支持html5就输出video+mp4(avc)和webm（或者ogg），否则输出flash相关的标签或脚本</li>\r\n<li>使用<a href=\"https://github.com/aFarkas/html5shiv\" target=\"_blank\">html5shiv</a>和<a href=\"http://diveintohtml5.info/j/html5-video.js\" target=\"_blank\">html5-video</a>是IE也能够支持video标签，并且使用Flash播放器来代替原生的video播放，<a href=\"http://webdesign.about.com/od/video/ss/html5-video_9.htm\" target=\"_blank\">参考</a></li>\r\n<li>将object内嵌在video中： </li>\r\n<li>&lt;video id=\"movie\" width=\"320\" height=\"240\" preload controls&gt;</li>\r\n<li>&nbsp;&nbsp;&lt;source src=\"pr6.webm\" type=\"video/webm; codecs=vp8,vorbis\" /&gt;</li>\r\n<li>&nbsp;&nbsp;&lt;source src=\"pr6.ogv\" type=\"video/ogg; codecs=theora,vorbis\" /&gt;</li>\r\n<li>&nbsp;&nbsp;&lt;source src=\"pr6.mp4\" /&gt;</li>\r\n<li>&nbsp;&nbsp;&lt;object width=\"320\" height=\"240\" type=\"application/x-shockwave-flash\"</li>\r\n<li>&nbsp;&nbsp;&nbsp;&nbsp;data=\"flowplayer-3.2.1.swf\"&gt;</li>\r\n<li>&nbsp;&nbsp;&nbsp;&nbsp;&lt;param name=\"movie\" value=\"flowplayer-3.2.1.swf\" /&gt;</li>\r\n<li>&nbsp;&nbsp;&nbsp;&nbsp;&lt;param name=\"allowfullscreen\" value=\"true\" /&gt;</li>\r\n<li>&nbsp;&nbsp;&nbsp;&nbsp;&lt;param name=\"flashvars\" value=\"config={\'clip\': {\'url\': \'http://wearehugh.com/dih5/pr6.mp4\', \'autoPlay\':false, \'autoBuffering\':true}}\" /&gt;</li>\r\n<li>&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Download video as &lt;a href=\"pr6.mp4\"&gt;MP4&lt;/a&gt;, &lt;a href=\"pr6.webm\"&gt;WebM&lt;/a&gt;, or &lt;a href=\"pr6.ogv\"&gt;Ogg&lt;/a&gt;.&lt;/p&gt;</li>\r\n<li>&nbsp;&nbsp;&lt;/object&gt;</li>\r\n</ul>\r\n&lt;/video&gt;\r\n<strong>工具</strong>\r\n<ul>\r\n<li><a href=\"http://www.pcfreetime.com/cn/\" target=\"_blank\">格式工厂</a>是推荐的比较好的格式转换工具，支持格式转换、视频分割、添加水印等，甚至可以用命令行和参数运行，笔者发现百度云存储提供视频转化和托管服务就是用的格式工厂做视频转化的。但是目前为止，格式工厂不能支持webm和ogg。</li>\r\n<li><a href=\"http://www.dvdvideosoft.com/\" target=\"_blank\">DVDVideoSoft Free Studio</a>界面比较酷，功能也比较强大，更重要的是其能够支持webm。</li>\r\n<li><a href=\"http://www.ffmpeg.org/\" target=\"_blank\">ffmpeg</a>是一个开源的跨平台的提供视频和音频转化的解决方案，其中包括一个可用的转化工具（命令行形式），和一些可扩展和调用的类库，对于对视频有自动化转化和深度定制需求的用户是不错的选择。</li>\r\n<li><a href=\"http://diveintohtml5.info/video.html#ffmpeg2theora\" target=\"_blank\">ffmpeg2theora</a>可以有效的对ffmpeg在theora上的补充，也是基于命令行执行</li>\r\n<li><a href=\"http://diveintohtml5.info/video.html#handbrake-gui\" target=\"_blank\">HandBrake</a> 支持命令行和GUI，作为ffmpeg的补充，进行H.264的转化</li>\r\n<li><a href=\"http://www.mirovideoconverter.com/\" target=\"_blank\">Miro Video Converter</a>也是一款开源的视频转化软件，对各种设备和格式的支持都很不错，有mac版和windows版，推荐mac用户使用。</li>\r\n</ul>', '2018-04-19 13:59:00', '博客园', 'https://www.cnblogs.com/lgx5/p/5714494.html'),
(149, '来理解undefined 和 null 区别', '码疯', 'baike', '之前虽然也知道这两个之间的区别，但是让我描述的话，感觉上还是说的不是很清楚。今天也详细看了一次这个知识点，现在来说说这两者间的区别。\r\n\r\nnull： Null类型，代表“空值”，代表一个空对象指针，使用typeof运算得到 “object”，所以你可以认为它是一个特殊的对象值。\r\n\r\nundefined： Undefined类型，当一个声明了一个变量未初始化时，得到的就是undefined。\r\n\r\nnull是javascript的关键字，可以认为是对象类型，它是一个空对象指针，和其它语言一样都是代表“空值”，不过 undefined 却是javascript才有的。undefined是在ECMAScript第三版引入的，为了区分空指针对象和未初始化的变量，它是一个预定义的全局变量。没有返回值的函数返回为undefined，没有实参的形参也是undefined。\r\n\r\njavaScript权威指南： null 和 undefined 都表示“值的空缺”，你可以认为undefined是表示系统级的、出乎意料的或类似错误的值的空缺，而null是表示程序级的、正常的或在意料之中的值的空缺。\r\n\r\n哈哈哈！！是不是感觉不是在说人话。如果和我一样不是很能听懂，请看下面。\r\n\r\njavaScript高级程序设计： 在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。   null值则是表示空对象指针。\r\n\r\n最后，我的理解就是： undefined是访问一个未初始化的变量时返回的值，而null是访问一个尚未存在的对象时所返回的值。因此，可以把undefined看作是空的变量，而null看作是空的对象。\r\n\r\n在定义一个想保存对象的变量时，就可以让该变量先保存null值，这样既能体现null是一个空指针对象，也能更好的区分null和undefined。', '2018-04-20 20:33:00', '博客园', 'https://www.cnblogs.com/ly0612/p/6696982.html'),
(150, 'v-if 和 v-show', '六月的海', 'JS', '关于条件渲染\r\n所谓条件渲染，就是根据不同的条件，使用不同的模板来生成 html。 在 Vue.js 中，使用 v-if 和 v-show 指令来控制条件渲染。\r\n\r\n区别\r\nv-show 会在app初始化的时候编译并且渲染，并且在之后一直存在。当切换v-show模块时，只是简单的更改css。\r\nv-if 当切换v-if模块时，Vue.js 有一个局部编译/卸载过程，因为 v-if 之中的模板也可能包括数据绑定或子组件。v-if 是真实的条件渲染，因为它会确保条件块在切换当中合适地销毁与重建条件块内的事件监听器和子组件。 v-if 是惰性的，如果为false，则什么也不错-不编译，不渲染。 当第一次条件为真时，才开始编译。\r\n\r\n建议\r\nv-show的切换消耗比较低，但是不会重新渲染子组件，所以最好用于静态的内容或者不需要重新构建结构的组件。而 v-if 比较适合不太频繁的切换状态的组件。所以项目设计的时候，不要对复杂的业务设计模块太频繁的视图切换。尽量将静态内容和动态内容分离到不同的模块中。\r\n\r\n在切换 v-if 块时，Vue.js 有一个局部编译/卸载过程，因为 v-if 之中的模板也可能包括数据绑定或子组件。v-if 是真实的条件渲染，因为它会确保条件块在切换当中合适地销毁与重建条件块内的事件监听器和子组件。\r\nv-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。\r\n相比之下，v-show 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。\r\n一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好', '2018-04-20 14:38:00', '博客园', 'https://www.cnblogs.com/Rexxar/p/5578441.html');

-- --------------------------------------------------------

--
-- 表的结构 `wu_demo`
--

CREATE TABLE `wu_demo` (
  `id` bigint(20) NOT NULL,
  `demo_title` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'demo名称',
  `demo_author` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 'demo作者',
  `demo_link` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'demo链接',
  `demo_img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'demo图片'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='諾的DEMO';

--
-- 转存表中的数据 `wu_demo`
--

INSERT INTO `wu_demo` (`id`, `demo_title`, `demo_author`, `demo_link`, `demo_img`) VALUES
(1, '党建教育系统', '吴广诺', 'dangjian', 'dangjian.jpg'),
(2, '标签云', '', 'cloudTag', 'cloudtag.png'),
(3, '标签云', 'chestnut647', 'cloudTag_2', 'cloudtag_2.png'),
(4, '一个简单的 Canvas 游戏', 'chestnut647', 'canvasGame', 'canvasgame.png'),
(5, '无限滚动加载数据', 'chestnut647', 'infiniteScroll', 'infinitescroll.png'),
(6, '执行指令的盒子', 'chestnut647', 'instuctedBox', 'instuctedbox.png'),
(7, '各种排序算法动画', 'aTool在线工具', 'http://www.atool.org/sort.php', 'sort.png'),
(8, 'PHP 验证码实例', '', 'validate', 'validate.png'),
(9, '百度地图 API 演示', 'admin', 'baiduMapApi', 'baiduMapApi.jpg'),
(10, '粒子动态背景', 'Vincent Garreau', 'particles', 'particles.png'),
(11, '爱心树', 'hackerzhou', 'tearsback', 'tearsback.jpg'),
(12, '北京奥星广益有限公司', 'admin', 'axgy', 'axgy.jpg'),
(13, '心形背景', '', 'love', 'love.png'),
(14, 'Fixed 文字悬浮', 'admin', 'bg-fixed', 'bg-fixed.png'),
(15, 'PHP 表单验证', 'admin', 'form', 'form.png'),
(16, 'canvas 玫瑰', '', 'canvasRose', 'canvasRose.jpg'),
(17, ' 分片上传', 'lovefc', 'fcup', 'fcup.png'),
(18, 'Bootstrap 日期插件', 'AuspeXeu', 'bootstrap-datetimepicker', 'bootstrap-datetimepicker.png'),
(19, 'jQuery 日历插件', '', 'calendar', 'calendar.png'),
(20, '自制时钟', '', 'clock', 'clock.png');

-- --------------------------------------------------------

--
-- 表的结构 `wu_diary`
--

CREATE TABLE `wu_diary` (
  `id` bigint(20) UNSIGNED NOT NULL,
  `diary_title` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '日记标题',
  `diary_key` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci COMMENT '日记关键词',
  `diary_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '日记内容',
  `diary_date` datetime NOT NULL DEFAULT '0000-00-00 00:00:00' COMMENT '发布日期'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='諾的日记';

--
-- 转存表中的数据 `wu_diary`
--

INSERT INTO `wu_diary` (`id`, `diary_title`, `diary_key`, `diary_content`, `diary_date`) VALUES
(1, 'Day:1', '忙', '    一箱箱沙丁鱼罐头沿着公路被送往岛内，一节一空的车厢又从岛内运出来。而我则是茫茫大海之中的一条咸鱼，任人摆布。\n    最近一段时间可能不会更新这个版块了。主要是因为\"I have no time for game.\"我还没有适应如此匆忙的生活。加之最近还接了一个项目需要加班加点的完成。真实的体会到生活的艰辛。', '2017-10-16 17:06:24'),
(5, '前赤壁赋', '古诗,苏轼', '    最近几天，苏东坡的《前赤壁赋》总是在我的脑海中回响。乘客的吊古伤今之情与苏子的矢志不移，流淌在全诗之间的超脱豁达使我热泪盈眶。\r\n    “盖将自其变者而观之，而天地曾不能一瞬；自其不变者而观之，则物与我皆无尽也，而又何羡乎!”豁达的宇宙观和人生观，看待问题的独特角度，身处逆境中的超脱、乐观，随缘自适的精神状态……随着我年龄的增长，阅历的增加，对古诗词的理解也更进一步，感同身受，苏子的一席话使我灵魂得到升华。', '2017-09-04 07:11:56'),
(6, '离？归？', '古诗,悲伤', '    明天我就要走了，离开生养我的故乡。心中自然是五味杂陈：\r\n    我要只身前往那个看起来美好的城市，那个繁华的第二故乡。厦门的发展前景好的自然不必多说。纵使心中有失魂落魄也不与外人说，长风破浪会有时。', '2017-09-05 00:26:14'),
(7, '青玉德天下第一', '炉石,退坑', '    BB再次把削弱的利刃指向了经典卡。激活，小斧头，蛤诚然是强力单卡，但平衡组面对更加IMBA的终极赖皮却不管不顾，卡牌削弱方式也简单粗暴。错的时间，错的方式，削了对的卡。\r\n    这游戏好难，也许这次我就真的退坑了呢？', '2017-09-06 02:45:59'),
(8, '心好累', '私人,消极', '    很困，但是睡不着。腿很酸，两天前的疲倦还挂在脸上：躺在床上不想动弹。垃圾桶中的瓶瓶罐罐溢了出来，一把椅子歪歪斜斜的靠在桌前，桌上杂物堆积如山。\r\n    心里上的压力使人由内而外的感到疲惫和焦躁，脸上起痘、嘴巴长泡、腰腿酸痛、食欲不振、内分泌失调、昼夜颠倒。对所有的事物都提不起兴趣。', '2017-09-08 06:53:20'),
(9, '向前看', '回忆,消极', '    三天过去了，孤独又茫然。总想搞些小项目却又懒的实施。\r\n    大脑腐蚀度渐渐增加，运行速度越来越差劲，间或有想法也心血来潮一分钟；成品率逐渐降低，半拉的工程逐渐增多。我已不再是曾经的自己，也许再也回不到从前了吧。那就不要回头', '2017-09-09 21:31:13'),
(10, '两个夏天', '天气,故乡', '    一路从北方的小城南下，天气愈加燥热。在北方经历了八月末的降温降雨之后，迎来了九月的新一轮烈阳，只不过我身处更加接近北回归线的厦门。\r\n    太阳炙烤着大地，空气中弥漫的热浪，让人喘不过气来，没有一丝风，一幢幢高楼大厦上的玻璃幕墙反射着刺眼的光亮——这是我今年经历的第二个夏天。', '2017-09-10 21:22:47'),
(11, '重拾梦想', '梦想,创作', '    “曾梦想仗剑走天涯，看一看世界的繁华”我想努力融入这个世界，在社会的洪流中起伏。\n    这并不简单，我想。可是我愿去尝试，愿打磨自己，包装自己，把自己最好的一面展示给世界。好久没有上传新文章了，我得好好的把这几个月学习到的新技术，新思想表达出来。', '2017-09-12 00:24:22'),
(17, '楼上楼下', '宿舍,回忆', '    早有耳闻梅苑B宿舍要迎来学妹，今天中午终于看到了有提前赶到的学妹陆续入住：我刚走出电梯，一行三人便提着行李进入了电梯。她们就住在我大计院的楼上7楼和8楼，我的最后一年也许就这样和她们生活在一起。\r\n    记得我初中时，学和住都在副教学楼，那是一栋一二楼教室、三楼住女生、四五楼住男生的楼。只是三四楼之间用厚实的铁门锁着...', '2017-09-13 07:38:32'),
(18, '凡勃伦效应', '经济,科学', '    凡勃伦效应是指消费者对一种商品需求的程度因其标价的增加而增加。它反映了人们进行挥霍性消费的心理愿望。商品价格定得越高，越能受到消费者的青睐。\r\n    利用人性弱点凡勃伦效应来制定营销策略，使消费者从数量，质量购买阶段过渡到感性购买阶段，既满足消费者虚荣心，同时又从中获得更大的收益。', '2017-09-14 08:40:32'),
(20, 'Idea', '思考,积极', '    趁着年轻，大脑会产生很多新奇的想法，付出行动努力去实现。趁着现在，赶紧记录下来。我热爱新技术，尤其对网站前端后端感兴趣。经历了这么多，现在的我不再对什么事情抱有幻想，也不期待奇迹的发生。只想踏踏实实的做好每一件事，使自己变强大，只有靠自身的努力才能换来别人的尊重。', '2017-09-14 17:31:55'),
(21, '醉翁亭', '古诗,欧阳修', '    最近一段时间总是会莫名的在脑海中浮现出一些高中时期背诵的古诗文。果然高中生活才是生命中最深刻的记忆。\r\n    山水之乐，得之心而寓之酒也的，那是欧阳修；苍颜白发，颓然乎其间者的，也是欧阳修。经典的古文越读越带感，越品越有味，重温《醉翁亭记》使我身心沉寂在恬淡的情境里，获得了一种平衡、和谐的感受，如田园一般，淡雅而自然，婉转而流畅。', '2017-09-16 07:00:08'),
(22, '无业游民', '膜.知识', '    昨天校招表现很差，现场笔试的题目使我深深的感到了无知的可怕，无知意味着失业，在这个社会中，没有钱就意味着一无是处。\r\n    从前长者教导我们：“还是要提高自己的姿势水平！”长者的人生经验根本不需要我用自身去实验，知识真的是太重要了，离开它将无法在社会中生存。知识使人谦虚，无知才会使人骄傲。', '2017-09-19 18:00:31'),
(23, '一分耕耘，一分收获', '运气,影', '    影，谢谢你的运气。刚刚接到电话，我面试通过了，我要开始一边上课，一边在软件园实习了！！我现在真的是好高兴好高兴。\n    这是我第一次参加校招会，在第一家公司投递的第一张简历，但是我非常幸运的通过了笔试，一面和二面。每次面试完后我都感觉自己会被刷下来，可我还是有惊无险的通过了。也许是运气使然吧，我希望我同时也希望你在将来的学习生活中一切顺利。', '2017-09-28 01:14:44'),
(26, '国庆节计划', '假期,计划', '    放假啦(其实大四一周六天假)，实习工作已确认，没什么事情值得去操劳了。是时候好好放松下，解放自己了!回家是不可能的，附近转悠转悠还是比较现实的。\r\n    不过即使是假期，我也要为自己制定一个学习计划。最近正在自学javaSE，那就每天看一个单元的视频吧，毕竟作为严谨完整的语言，java在未来可预见的十年内不会衰败。', '2017-09-29 07:00:21'),
(27, 'Bootstrap', 'CSS,Bootstrap', '    最近几天，我热衷于把我的网站使用 Bootstrap 进行响应式设计，以适应移动设备。今天午间，网站重构基本完工，极大地简化了网站源码复杂程度。页面简洁美观，响应式设计灵活方便，排版布局赏心悦目，我直接把原来自己写的十几K的css文件给删了。\r\n(有时候，我觉的造轮子是不可避免的一个必经过程)', '2017-10-01 02:38:16'),
(28, 'UTF-8无BOM', '编码,UTF', '    我总要上下四方寻求，得到一种最黑，最黑，最黑的咒文，先来诅咒一切使用 BOM 的 UTF-8 文件。Windows 总是自做聪明的做一些别人无法理解的事情！UTF-8 是不需要 BOM 头的！\n    HTML空白行，DIV 之间的间隔，莫名其妙的乱码！明明相同的两段代码，显示效果却有偏差，我排查了一上午才发现是文件编码的问题，U+FEFF！可恶！', '2017-10-03 18:53:42'),
(29, '长者说', '长者,膜', '<video width=\"240\" height=\"180\" controls poster=\"http://oourcagfr.bkt.clouddn.com/elder/+1s.png\" preload=\"metadata\"><source src=\"http://oourcagfr.bkt.clouddn.com/长者怒斥香港记者.mp4\" type=\"video/mp4\">您的浏览器不支持 video 标签。</video>', '2017-10-08 07:23:59'),
(30, 'canvas', 'H5,canvas', '<canvas id=\"love\" width=\"150\" eight=\"150\">您的浏览器不支持canvas!</canvas>利用canvas画图<script>var c = document.getElementById(\"love\");var ctx = c.getContext(\"2d\");ctx.beginPath();ctx.moveTo(75,40);ctx.bezierCurveTo(75,37,70,25,50,25);ctx.bezierCurveTo(20,25,20,62.5,20,62.5);ctx.bezierCurveTo(20,80,40,102,75,120);ctx.bezierCurveTo(110,102,130,80,130,62.5);ctx.bezierCurveTo(130,62.5,130,25,100,25);ctx.bezierCurveTo(85,25,75,37,75,40);ctx.fillStyle=\"#f00\";ctx.fill();</script>', '2017-10-12 03:55:31'),
(31, '某天', '忙', '    一箱箱沙丁鱼罐头沿着公路被送往岛内，一节一空的车厢又从岛内运出来。而我则是茫茫大海之中的一条咸鱼，任人摆布。\n    最近一段时间可能不会更新这个版块了。主要是因为\"I have no time for game.\"我还没有适应如此匆忙的生活。加之最近还接了一个项目需要加班加点的完成。真实的体会到生活的艰辛。', '2017-10-16 17:06:24');

-- --------------------------------------------------------

--
-- 表的结构 `wu_doc`
--

CREATE TABLE `wu_doc` (
  `id` bigint(20) NOT NULL,
  `doc_title` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '文档标题',
  `doc_price` decimal(18,2) DEFAULT NULL COMMENT '文档价格',
  `doc_link` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '文档链接',
  `doc_img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '文档图片'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='开发文档';

--
-- 转存表中的数据 `wu_doc`
--

INSERT INTO `wu_doc` (`id`, `doc_title`, `doc_price`, `doc_link`, `doc_img`) VALUES
(1, 'ThinkPHP5.0完全开发手册', NULL, 'https://www.kancloud.cn/manual/thinkphp5', 'thinkphp5.jpg'),
(2, 'ThinkPHP5.1完全开发手册', NULL, 'https://www.kancloud.cn/manual/thinkphp5_1', 'thinkphp5_1.png'),
(3, 'ThinkPHP3.2.3完全开发手册', NULL, 'https://www.kancloud.cn/manual/thinkphp', 'thinkphp.png'),
(4, 'Composer中文文档', NULL, 'https://www.kancloud.cn/thinkphp/composer', 'composer.png'),
(5, 'Laravel 5中文文档', NULL, 'https://www.kancloud.cn/baidu/laravel5', 'laravel5.png'),
(6, 'Yii 2.0 权威指南', NULL, 'https://www.kancloud.cn/manual/yii2-guide', 'yii2.0.jpg'),
(7, '菜鸟教程', NULL, 'http://www.runoob.com/', 'runoob.png'),
(8, 'W3school在线教程', NULL, 'http://www.w3school.com.cn/', 'w3school.png'),
(9, '开源中国在线文档', NULL, 'http://tool.oschina.net/apidocs', 'oschina.png'),
(10, '程序员手册大全', NULL, 'http://manual.51yip.com/', '51yip.png'),
(11, 'MyBatis', NULL, 'http://www.mybatis.org/mybatis-3/zh/index.html', 'mybatis.png'),
(12, '我爱读者网', NULL, 'http://www.52duzhe.com/', '52duzhe.png'),
(13, 'Bootstrap 4 中文文档', NULL, 'https://v4.bootcss.com/docs/4.0/getting-started/introduction/', 'bootstrap4.0.png'),
(14, 'jQuery API 中文文档', NULL, 'https://www.jquery123.com/', 'jquery.png'),
(15, 'Vue.js中文文档', NULL, 'https://vuejs.bootcss.com/v2/guide/', 'vue.png'),
(16, 'angularjs教程', NULL, 'http://www.angularjs.net.cn/tutorial/', 'angularjs.jpg'),
(17, 'React中文文档', NULL, 'http://www.css88.com/react/docs/hello-world.html', 'react.png'),
(18, 'JavaScript全栈教程', NULL, 'https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000', 'JavaScript.png'),
(19, 'Python 3 教程', NULL, 'http://www.runoob.com/python3/python3-tutorial.html', 'python3.png'),
(20, 'PHP手册', NULL, 'http://php.net/manual/zh/', 'php.png'),
(21, 'JDK7 API', NULL, 'https://docs.oracle.com/javase/7/docs/api/', 'jdk7api.jpg'),
(22, 'J2EE6 API', NULL, 'http://tool.oschina.net/apidocs/apidoc?api=javaEE6', 'j2ee6api.jpg'),
(25, 'FontAwesome 图标', NULL, 'https://fontawesome.com/how-to-use/', 'fontawesome.png'),
(26, 'Node.js API 文档', NULL, 'http://nodejs.cn/api/', 'nodejs.png'),
(27, 'wangEditor3 使用手册', NULL, 'https://www.kancloud.cn/wangfupeng/wangeditor3/332599', 'wangeditor3.png'),
(28, 'MDN Web 文档', NULL, 'https://developer.mozilla.org/zh-CN/', 'MDN.png');

-- --------------------------------------------------------

--
-- 表的结构 `wu_game`
--

CREATE TABLE `wu_game` (
  `id` bigint(20) NOT NULL,
  `game_title` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '游戏名称',
  `game_author` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '游戏作者',
  `game_link` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '游戏链接',
  `game_img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '游戏图片'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='諾的H5游戏';

--
-- 转存表中的数据 `wu_game`
--

INSERT INTO `wu_game` (`id`, `game_title`, `game_author`, `game_link`, `game_img`) VALUES
(1, '贪吃蛇', '', 'PizzaSnake', 'PizzaSnake.jpg'),
(2, '2048', '', '2048', '2048.png'),
(3, '中国象棋', '', 'ChineseChess', 'ChineseChess.jpg'),
(4, '打砖块', '', 'dazhuankuai', 'dazhuankuai.png'),
(5, '像素鸟', '', 'flappy-bird', 'flappy-bird.png'),
(6, '飞扬的文字', '', 'flappy-text', 'flappy-text.png'),
(7, '水果忍者', '', 'fruit-ninja', 'fruit-ninja.jpg'),
(8, '三国连连看', '', 'lianliankan', 'lianliankan.jpg'),
(9, '无限马里奥', '', 'mario', 'mario.jpg'),
(10, '魔塔', '', 'mota', 'mota.jpg'),
(11, '贪吃蛇', '', 'snake', 'snake.png'),
(12, '俄罗斯方块', '', 'tetris', 'tetris.png'),
(13, '2048', 'liusaint1992', '2048_2', '2048_2.png'),
(14, '扫雷', 'liusaint1992', 'mine', 'mine.png'),
(15, '数独', 'liusaint1992', 'soduku', 'soduku.png'),
(16, '拼图游戏', '', 'jigsawPuzzle', 'jigsawPuzzle.jpg'),
(17, 'H5 生命游戏', ' lifegame', 'game_of_life', 'game_of_life.png');

-- --------------------------------------------------------

--
-- 表的结构 `wu_tool`
--

CREATE TABLE `wu_tool` (
  `id` bigint(20) NOT NULL,
  `tool_title` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '工具名称',
  `tool_author` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '工具作者',
  `tool_from` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '原链接',
  `tool_link` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '工具链接',
  `tool_img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '工具图片'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='諾的工具箱';

--
-- 转存表中的数据 `wu_tool`
--

INSERT INTO `wu_tool` (`id`, `tool_title`, `tool_author`, `tool_from`, `tool_link`, `tool_img`) VALUES
(1, '颜色表及html代码', '', '', 'color', 'color.jpg'),
(2, '字体样式', '', '', 'font-family', 'font-family.png'),
(3, '浏览器的工作原理', 'Tali Garsiel and Paul Irish', 'html5rocks', 'https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/', 'browser.jpg'),
(4, 'PHP 信息查询', 'admin', '', 'phpinfo', 'phpinfo.png'),
(5, '图片转码 base64', '', '', 'img2base64', 'img2base64.jpg'),
(6, '图片裁剪', '', '', 'crop-image', 'crop-image.jpg'),
(7, '图片转字符画', '', '', 'img2txt', 'img2txt.png'),
(8, '菜鸟工具\n(编译/前端)', 'runoob.com', 'https://c.runoob.com/', 'https://c.runoob.com/', 'c.runoob.com.png');

--
-- Indexes for dumped tables
--

--
-- Indexes for table `wu_blog`
--
ALTER TABLE `wu_blog`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `wu_demo`
--
ALTER TABLE `wu_demo`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `wu_diary`
--
ALTER TABLE `wu_diary`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `wu_doc`
--
ALTER TABLE `wu_doc`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `wu_game`
--
ALTER TABLE `wu_game`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `wu_tool`
--
ALTER TABLE `wu_tool`
  ADD PRIMARY KEY (`id`);

--
-- 在导出的表使用AUTO_INCREMENT
--

--
-- 使用表AUTO_INCREMENT `wu_blog`
--
ALTER TABLE `wu_blog`
  MODIFY `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=151;

--
-- 使用表AUTO_INCREMENT `wu_diary`
--
ALTER TABLE `wu_diary`
  MODIFY `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=32;

--
-- 使用表AUTO_INCREMENT `wu_doc`
--
ALTER TABLE `wu_doc`
  MODIFY `id` bigint(20) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=29;
COMMIT;